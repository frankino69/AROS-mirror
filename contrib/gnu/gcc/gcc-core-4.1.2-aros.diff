diff -uwNr gcc-4.1.2/configure.in gcc-4.1.2.new/configure.in
--- gcc-4.1.2/configure.in	2006-11-21 18:48:36.000000000 +0100
+++ gcc-4.1.2.new/configure.in	2006-11-21 18:48:36.000000000 +0100
@@ -292,6 +292,9 @@
   ppc*-*-pe)
     noconfigdirs="$noconfigdirs patch diff make tk tcl expect dejagnu autoconf automake texinfo bison send-pr gprof rcs guile perl itcl gnuserv"
     ;;
+  *-*-aros*)
+    noconfigdirs="patch diff make tk tcl expect dejagnu autoconf automake texinfo bison send-pr gprof rcs guile perl itcl tix gnuserv gdb"
+    ;;
   powerpc-*-beos*)
     noconfigdirs="$noconfigdirs tk itcl libgui gdb dejagnu readline"
     ;;
@@ -979,6 +982,8 @@
     # Build the stage2 and stage3 compilers with -fomit-frame-pointer.
     host_makefile_frag="config/mh-x86omitfp"
     ;;
+  *-*-aros*)
+    ;;
 esac
 fi
 
diff -uwNr gcc-4.1.2/fixincludes/configure gcc-4.1.2.new/fixincludes/configure
--- gcc-4.1.2/fixincludes/configure	2005-07-16 16:17:51.000000000 +0200
+++ gcc-4.1.2.new/fixincludes/configure	2006-11-21 18:48:36.000000000 +0100
@@ -2561,6 +2561,7 @@
 fi
 else
   case $host in
+        *-*-aros* | \
 	i?86-*-msdosdjgpp* | \
 	i?86-*-mingw32* | \
 	*-*-beos* )
diff -uwNr gcc-4.1.2/fixincludes/configure.ac gcc-4.1.2.new/fixincludes/configure.ac
--- gcc-4.1.2/fixincludes/configure.ac	2005-07-16 16:17:51.000000000 +0200
+++ gcc-4.1.2.new/fixincludes/configure.ac	2006-11-21 18:48:36.000000000 +0100
@@ -47,6 +47,7 @@
 	TARGET=oneprocess
 fi],
 [case $host in
+        *-*-aros* | \
 	i?86-*-msdosdjgpp* | \
 	i?86-*-mingw32* | \
 	*-*-beos* )
diff -uwNr gcc-4.1.2/gcc/c-incpath.c gcc-4.1.2.new/gcc/c-incpath.c
--- gcc-4.1.2/gcc/c-incpath.c	2005-06-25 04:02:01.000000000 +0200
+++ gcc-4.1.2.new/gcc/c-incpath.c	2006-11-21 18:48:36.000000000 +0100
@@ -37,7 +37,7 @@
 # define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))
 # define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))
 #else
-# if (defined _WIN32 && !defined (_UWIN)) || defined __MSDOS__
+# if (defined _WIN32 && !defined (_UWIN)) || defined __MSDOS__ || defined __AROS__
 #  define INO_T_EQ(A, B) 0
 # else
 #  define INO_T_EQ(A, B) ((A) == (B))
diff -uwNr gcc-4.1.2/gcc/config/aros.h gcc-4.1.2.new/gcc/config/aros.h
--- gcc-4.1.2/gcc/config/aros.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.1.2.new/gcc/config/aros.h	2008-04-21 17:51:43.000000000 +0200
@@ -0,0 +1,102 @@
+/* Definitions for AROS
+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   Contributed by Fabio Alemagna
+   Based upon linux.h, contributed by Eric Youngdale.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+/* AROS uses ctype from libc.a. I am not sure how complete it is.
+   For now, we play safe. It may change later.  */
+
+#if 0
+#undef MULTIBYTE_CHARS
+#define MULTIBYTE_CHARS 1
+#endif
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+	builtin_define_std ("unix");		\
+	builtin_define_std ("AROS");            \
+	builtin_define ("__ELF__");		\
+	builtin_assert ("system=posix");	\
+	if (flag_pic)				\
+	  {					\
+	    builtin_define ("__PIC__");		\
+	    builtin_define ("__pic__");		\
+	  }					\
+    }						\
+  while (0)
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef MD_EXEC_PREFIX
+#undef MD_STARTFILE_PREFIX
+
+/* Provide a STARTFILE_SPEC appropriate for AROS. AROS has its own
+   set of startup files which also take care of handling C++
+   constructors/destructors.  */
+
+#undef	STARTFILE_SPEC
+#define STARTFILE_SPEC \
+  "%{detach:detach.o%s} startup.o%s %{nix:nixmain.o%s}"
+
+/* Provide a ENDFILE_SPEC appropriate for AROS. */
+
+#undef	ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "-lautoinit"
+
+/* This is for -profile to use -lc_p instead of -lc.  */
+#ifndef CC1_SPEC
+#define CC1_SPEC "%{profile:-p}"
+#endif
+
+/* The GNU C++ standard library requires that these macros be defined.  */
+#undef CPLUSPLUS_CPP_SPEC
+#define CPLUSPLUS_CPP_SPEC "-D_GNU_SOURCE %(cpp)"
+
+#undef	LIB_SPEC
+#define LIB_SPEC \
+  "-lamiga -larossupport -larosc -lm"
+
+#if !defined(USE_GNULIBC_1) && defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
+
+/* AROS uses its own collect-like program for the moment.  */
+#undef LINKER_NAME
+#define LINKER_NAME "collect-aros"
+
+/* Define this so we can compile MS code for use with WINE.  */
+#define HANDLE_PRAGMA_PACK_PUSH_POP
+
+#define TARGET_HAS_F_SETLKW
diff -uwNr gcc-4.1.2/gcc/config/i386/aros64.h gcc-4.1.2.new/gcc/config/i386/aros64.h
--- gcc-4.1.2/gcc/config/i386/aros64.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.1.2.new/gcc/config/i386/aros64.h	2006-11-21 18:48:36.000000000 +0100
@@ -0,0 +1,44 @@
+/* Definitions for AMD x86_64 running AROS systems with ELF64 format.
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002
+   Free Software Foundation, Inc.
+   Contributed by Fabio Alemagna.
+   Based upon i386/aros.h by Stanislaw Szymczyk.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+
+#define TARGET_VERSION fprintf (stderr, " (x86_64 AROS/ELF)");
+
+#undef CPP_SPEC
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+
+/* The svr4 ABI for the i386 says that records and unions are returned
+   in memory.  In the 64bit compilation we will turn this flag off in
+   override_options, as we never do pcc_struct_return scheme on this target.  */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+/* Provide a LINK_SPEC appropriate for AROS.  */
+
+#undef	LINK_SPEC
+#define LINK_SPEC "%{!m32:-m elf_x86_64} %{m32:-m elf_i386}" 
+
+/* FIXME: AROS doesn't support dw2 unwinding yet.  */
+#undef MD_FALLBACK_FRAME_STATE_FOR
diff -uwNr gcc-4.1.2/gcc/config/i386/aros.h gcc-4.1.2.new/gcc/config/i386/aros.h
--- gcc-4.1.2/gcc/config/i386/aros.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.1.2.new/gcc/config/i386/aros.h	2006-11-21 18:48:36.000000000 +0100
@@ -0,0 +1,120 @@
+/* Definitions for Intel 386 running AROS systems with ELF format.
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002
+   Free Software Foundation, Inc.
+   Contributed by Fabio Alemagna.
+   Based upon i386/linux.h by Eric Youngdale.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Output at beginning of assembler file.  */
+/* The .file command should always begin the output.  */
+#undef TARGET_ASM_FILE_START_FILE_DIRECTIVE
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+
+#define TARGET_VERSION fprintf (stderr, " (i386 AROS/ELF)");
+
+/* The svr4 ABI for the i386 says that records and unions are returned
+   in memory.  */
+#undef DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 1
+
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+
+/* Output assembler code to FILE to call the profiler.
+   To the best of my knowledge, no Linux libc has required the label
+   argument to mcount.  */
+
+#define NO_PROFILE_COUNTERS 1
+
+#undef MCOUNT_NAME
+#define MCOUNT_NAME "mcount"
+
+/* The GLIBC version of mcount for the x86 assumes that there is a
+   frame, so we cannot allow profiling without a frame pointer.  */
+
+#undef SUBTARGET_FRAME_POINTER_REQUIRED
+#define SUBTARGET_FRAME_POINTER_REQUIRED current_function_profile
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "long int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+#undef CPP_SPEC
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
+
+#undef CC1_SPEC
+#define CC1_SPEC "%(cc1_cpu) %{profile:-p}"
+
+/* Provide a LINK_SPEC appropriate for AROS.  */
+
+#undef	LINK_SPEC
+#define LINK_SPEC "-m elf_i386"
+
+/* A C statement (sans semicolon) to output to the stdio stream
+   FILE the assembler definition of uninitialized global DECL named
+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.
+   Try to use asm_output_aligned_bss to implement this macro.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* A C statement to output to the stdio stream FILE an assembler
+   command to advance the location counter to a multiple of 1<<LOG
+   bytes if it is within MAX_SKIP bytes.
+
+   This is used to align code labels according to Intel recommendations.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)			\
+  do {									\
+    if ((LOG) != 0) {							\
+      if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG));	\
+      else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
+    }									\
+  } while (0)
+#endif
+
+/* Handle special EH pointer encodings.  Absolute, pc-relative, and
+   indirect are handled automatically.  */
+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \
+  do {									\
+    if ((SIZE) == 4 && ((ENCODING) & 0x70) == DW_EH_PE_datarel)		\
+      {									\
+        fputs (ASM_LONG, FILE);			\
+        assemble_name (FILE, XSTR (ADDR, 0));				\
+	fputs (((ENCODING) & DW_EH_PE_indirect ? "@GOT" : "@GOTOFF"), FILE); \
+        goto DONE;							\
+      }									\
+  } while (0)
+
+
+/* FIXME: AROS doesn't support dw2 unwinding yet.  */
+#undef MD_FALLBACK_FRAME_STATE_FOR
diff -uwNr gcc-4.1.2/gcc/config.gcc gcc-4.1.2.new/gcc/config.gcc
--- gcc-4.1.2/gcc/config.gcc	2006-10-16 01:12:23.000000000 +0200
+++ gcc-4.1.2.new/gcc/config.gcc	2008-04-21 17:58:48.000000000 +0200
@@ -513,6 +513,26 @@
       ;;
   esac
   ;;
+*-*-aros*)
+  # On AROS, the setup is just about the same on
+  # each different CPU.  The specific machines that we
+  # support are matched above and just set $cpu_type.
+  ##xm_defines=POSIX
+  ##tm_file="${cpu_type}/gnu.h"
+  ##extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o"
+  # AROS always uses ELF.
+  elf=yes
+  # GNU tools are the only tools.
+  gnu_ld=yes
+  gas=yes
+  thread_file=single
+  use_collect2=no
+  xm_defines='STDC_HEADERS=1'
+  # These details are the same as for Linux.
+  # But here we need a little extra magic.
+  ##tmake_file="t-slibgcc-elf-ver t-linux t-gnu"
+  ;;
+
 *-*-openbsd*)
   tmake_file="t-libc-ok t-openbsd t-libgcc-pic"
   case ${enable_threads} in
@@ -1060,6 +1080,12 @@
 	esac
 	tmake_file="${tmake_file} i386/t-linux64 i386/t-crtfm"
 	;;
+i[34567]86-*-aros*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h aros.h i386/aros.h"
+	;;
+x86_64-*-aros*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h aros.h i386/x86-64.h i386/aros64.h"
+	;;	
 i[34567]86-*-gnu*)
 	;;
 i[34567]86-pc-msdosdjgpp*)
diff -uwNr gcc-4.1.2/gcc/config.host gcc-4.1.2.new/gcc/config.host
--- gcc-4.1.2/gcc/config.host	2006-02-05 17:18:20.000000000 +0100
+++ gcc-4.1.2.new/gcc/config.host	2006-11-21 18:48:36.000000000 +0100
@@ -200,4 +200,7 @@
     out_host_hook_obj=host-hpux.o
     host_xmake_file=x-hpux
     ;;
+  *-*-aros*)
+    host_can_use_collect2=no
+    ;;
 esac
--- gcc-4.1.2/gcc/gcc.c	2006-11-07 15:26:21.000000000 +0100
+++ gcc-4.1.2.new/gcc/gcc.c	2008-05-21 22:08:33.000000000 +0200
@@ -3596,7 +3596,7 @@
 	{
 	  /* -pipe has to go into the switches array as well as
 	     setting a flag.  */
-	  use_pipes = 1;
+	  use_pipes = 0;
 	  n_switches++;
 	}
       else if (strcmp (argv[i], "-###") == 0)
diff -uwNr gcc-4.1.2/gcc/libgcov.c gcc-4.1.2.new/gcc/libgcov.c
--- gcc-4.1.2/gcc/libgcov.c	2005-07-13 18:28:25.000000000 +0200
+++ gcc-4.1.2.new/gcc/libgcov.c	2008-04-21 18:48:51.000000000 +0200
@@ -37,7 +37,7 @@
 #if defined(inhibit_libc)
 #define IN_LIBGCOV (-1)
 #else
-#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */
+// #undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */
 #include <stdio.h>
 #define IN_LIBGCOV 1
 #if defined(L_gcov)
diff -uwNr gcc-4.1.2/include/filenames.h gcc-4.1.2.new/include/filenames.h
--- gcc-4.1.2/include/filenames.h	2005-05-10 17:22:21.000000000 +0200
+++ gcc-4.1.2.new/include/filenames.h	2006-11-21 18:48:36.000000000 +0100
@@ -40,6 +40,12 @@
 #define IS_ABSOLUTE_PATH(f)	(IS_DIR_SEPARATOR((f)[0]) || (((f)[0]) && ((f)[1] == ':')))
 #define FILENAME_CMP(s1, s2)	strcasecmp(s1, s2)
 
+#elif defined __AROS__
+
+#define IS_DIR_SEPARATOR(c)	((c) == '/' || (c) == ':')
+#define IS_ABSOLUTE_PATH(f)	(IS_DIR_SEPARATOR((f)[0]) || (strchr((f), ':') != NULL))
+#define FILENAME_CMP(s1, s2)	strcasecmp(s1, s2)
+
 #else  /* not DOSish */
 
 #define IS_DIR_SEPARATOR(c)	((c) == '/')
diff -uwNr gcc-4.1.2/include/libiberty.h gcc-4.1.2.new/include/libiberty.h
--- gcc-4.1.2/include/libiberty.h	2005-09-26 22:55:10.000000000 +0200
+++ gcc-4.1.2.new/include/libiberty.h	2008-04-21 17:42:37.000000000 +0200
@@ -97,7 +97,7 @@
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (__AROS__) || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
diff -uwNr gcc-4.1.2/libiberty/configure gcc-4.1.2.new/libiberty/configure
--- gcc-4.1.2/libiberty/configure	2005-07-22 05:14:38.000000000 +0200
+++ gcc-4.1.2.new/libiberty/configure	2008-05-06 23:59:36.000000000 +0200
@@ -8086,6 +8086,7 @@
      *-*-mingw* | *-*-winnt*)	pexecute=./pex-win32.o  ;;
      *-*-msdosdjgpp*)		pexecute=./pex-djgpp.o  ;;
      *-*-msdos*)		pexecute=./pex-msdos.o  ;;
+     *-*-aros*)			pexecute=./pex-aros.o   ;;
      *)				pexecute=./pex-unix.o   ;;
 esac
 
diff -uwNr gcc-4.1.2/libiberty/configure.ac gcc-4.1.2.new/libiberty/configure.ac
--- gcc-4.1.2/libiberty/configure.ac	2005-07-22 05:14:38.000000000 +0200
+++ gcc-4.1.2.new/libiberty/configure.ac	2006-11-21 18:48:36.000000000 +0100
@@ -598,6 +598,7 @@
      *-*-mingw* | *-*-winnt*)	pexecute=./pex-win32.o  ;;
      *-*-msdosdjgpp*)		pexecute=./pex-djgpp.o  ;;
      *-*-msdos*)		pexecute=./pex-msdos.o  ;;
+     *-*-aros*)			pexecute=./pex-aros.o   ;;
      *)				pexecute=./pex-unix.o   ;;
 esac
 AC_SUBST(pexecute)
diff -uwNr gcc-4.1.2/libiberty/Makefile.in gcc-4.1.2.new/libiberty/Makefile.in
--- gcc-4.1.2/libiberty/Makefile.in	2006-07-04 22:30:34.000000000 +0200
+++ gcc-4.1.2.new/libiberty/Makefile.in	2006-11-21 18:48:36.000000000 +0100
@@ -145,7 +145,7 @@
 	objalloc.c obstack.c						\
 	partition.c pexecute.c						\
 	 pex-common.c pex-djgpp.c pex-msdos.c pex-one.c			\
-	 pex-unix.c pex-win32.c						\
+	 pex-unix.c pex-win32.c	pex-aros.c				\
          physmem.c putenv.c						\
 	random.c regex.c rename.c rindex.c				\
 	safe-ctype.c setenv.c sigsetmask.c snprintf.c sort.c spaces.c	\
@@ -194,7 +194,7 @@
 	./memchr.o ./memcmp.o ./memcpy.o ./memmove.o ./mempcpy.o	\
 	 ./memset.o ./mkstemps.o					\
 	./pex-djgpp.o ./pex-msdos.o					\
-	 ./pex-unix.o ./pex-win32.o					\
+	 ./pex-unix.o ./pex-win32.o ./pex-aros.o			\
 	 ./putenv.o							\
 	./random.o ./rename.o ./rindex.o				\
 	./setenv.o ./sigsetmask.o ./snprintf.o ./stpcpy.o ./stpncpy.o	\
@@ -820,6 +820,13 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/pexecute.c $(OUTPUT_OPTION)
 
+./pex-aros.o: $(srcdir)/pex-aros.c config.h $(INCDIR)/ansidecl.h \
+	$(INCDIR)/libiberty.h $(srcdir)/pex-common.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/pex-aros.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/pex-aros.c $(OUTPUT_OPTION)
+
 ./physmem.o: $(srcdir)/physmem.c config.h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -uwNr gcc-4.1.2/libiberty/pex-aros.c gcc-4.1.2.new/libiberty/pex-aros.c
--- gcc-4.1.2/libiberty/pex-aros.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.1.2.new/libiberty/pex-aros.c	2008-05-07 00:02:50.000000000 +0200
@@ -0,0 +1,291 @@
+/* Utilities to execute a program in a subprocess (possibly linked by pipes
+   with other subprocesses), and wait for it.  AROS specialization.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005
+   Free Software Foundation, Inc.
+
+This file is part of the libiberty library.
+Libiberty is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+Libiberty is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with libiberty; see the file COPYING.LIB.  If not,
+write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+#include "pex-common.h"
+
+#include <stdio.h>
+#include <errno.h>
+#ifdef NEED_DECLARATION_ERRNO
+extern int errno;
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <process.h>
+
+/* Use ECHILD if available, otherwise use EINVAL.  */
+#ifdef ECHILD
+#define PWAIT_ERROR ECHILD
+#else
+#define PWAIT_ERROR EINVAL
+#endif
+
+#if defined (S_IRUSR) && defined (S_IWUSR) && defined (S_IRGRP) && defined (S_IWGRP) && defined (S_IROTH) && defined (S_IWOTH)
+#define PUBLIC_MODE  \
+    (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)
+#else
+#define PUBLIC_MODE 0666
+#endif
+
+static int pex_aros_open_read (struct pex_obj *, const char *, int);
+static int pex_aros_open_write (struct pex_obj *, const char *, int);
+static long pex_aros_exec_child (struct pex_obj *, int, const char *,
+				  char * const *, int, int, int, int,
+				  const char **, int *);
+static int pex_aros_close (struct pex_obj *, int);
+static int pex_aros_wait (struct pex_obj *, long, int *, struct pex_time *,
+			   int, const char **, int *);
+
+/* The list of functions we pass to the common routines.  */
+
+const struct pex_funcs funcs =
+{
+  pex_aros_open_read,
+  pex_aros_open_write,
+  pex_aros_exec_child,
+  pex_aros_close,
+  pex_aros_wait,
+  NULL, /* pipe */
+  NULL, /* fdopenr */
+  NULL  /* cleanup */
+};
+
+/* Return a newly initialized pex_obj structure.  */
+
+struct pex_obj *
+pex_init (int flags, const char *pname, const char *tempbase)
+{
+  /* Pipes in AROS are currently broken. */
+  flags &= ~ PEX_USE_PIPES;
+  return pex_init_common (flags, pname, tempbase, &funcs);
+}
+
+/* Open a file for reading.  */
+
+static int
+pex_aros_open_read (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
+		    int binary ATTRIBUTE_UNUSED)
+{
+  return open (name, O_RDONLY);
+}
+
+/* Open a file for writing.  */
+
+static int
+pex_aros_open_write (struct pex_obj *obj ATTRIBUTE_UNUSED, const char *name,
+		     int binary ATTRIBUTE_UNUSED)
+{
+  /* Note that we can't use O_EXCL here because gcc may have already
+     created the temporary file via make_temp_file.  */
+  return open (name, O_WRONLY | O_CREAT | O_TRUNC, PUBLIC_MODE);
+}
+
+/* Close a file.  */
+
+static int
+pex_aros_close (struct pex_obj *obj ATTRIBUTE_UNUSED, int fd)
+{
+  return close (fd);
+}
+
+/* Execute a child.  */
+
+static long
+pex_aros_exec_child (struct pex_obj *obj, int flags, const char *executable,
+		      char * const * argv, int in, int out, int errdes,
+		      int toclose ATTRIBUTE_UNUSED,
+		      const char **errmsg, int *err)
+{
+  int org_in, org_out, org_errdes;
+  int status;
+  int *statuses;
+
+  org_in = -1;
+  org_out = -1;
+  org_errdes = -1;
+
+  if (in != STDIN_FILE_NO)
+    {
+      org_in = dup (STDIN_FILE_NO);
+      if (org_in < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup";
+	  return -1;
+	}
+      if (dup2 (in, STDIN_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (close (in) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "close";
+	  return -1;
+	}
+    }
+
+  if (out != STDOUT_FILE_NO)
+    {
+      org_out = dup (STDOUT_FILE_NO);
+      if (org_out < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup";
+	  return -1;
+	}
+      if (dup2 (out, STDOUT_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (close (out) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "close";
+	  return -1;
+	}
+    }
+
+  if (errdes != STDERR_FILE_NO
+      || (flags & PEX_STDERR_TO_STDOUT) != 0)
+    {
+      org_errdes = dup (STDERR_FILE_NO);
+      if (org_errdes < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup";
+	  return -1;
+	}
+      if (dup2 ((flags & PEX_STDERR_TO_STDOUT) != 0 ? STDOUT_FILE_NO : errdes,
+		 STDERR_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (errdes != STDERR_FILE_NO)
+	{
+	  if (close (errdes) < 0)
+	    {
+	      *err = errno;
+	      *errmsg = "close";
+	      return -1;
+	    }
+	}
+    }
+
+  status = (((flags & PEX_SEARCH) != 0 ? spawnvp : spawnv)
+	    (P_WAIT, executable, (char * const *) argv));
+
+  if (status == -1)
+    {
+      *err = errno;
+      *errmsg = ((flags & PEX_SEARCH) != 0) ? "spawnvp" : "spawnv";
+    }
+
+  if (in != STDIN_FILE_NO)
+    {
+      if (dup2 (org_in, STDIN_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (close (org_in) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "close";
+	  return -1;
+	}
+    }
+
+  if (out != STDOUT_FILE_NO)
+    {
+      if (dup2 (org_out, STDOUT_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (close (org_out) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "close";
+	  return -1;
+	}
+    }
+
+  if (errdes != STDERR_FILE_NO
+      || (flags & PEX_STDERR_TO_STDOUT) != 0)
+    {
+      if (dup2 (org_errdes, STDERR_FILE_NO) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "dup2";
+	  return -1;
+	}
+      if (close (org_errdes) < 0)
+	{
+	  *err = errno;
+	  *errmsg = "close";
+	  return -1;
+	}
+    }
+
+  /* Save the exit status for later.  When we are called, obj->count
+     is the number of children which have executed before this
+     one.  */
+  statuses = (int *) obj->sysdep;
+  statuses = XRESIZEVEC (int, statuses, obj->count + 1);
+  statuses[obj->count] = status;
+  obj->sysdep = (void *) statuses;
+
+  return obj->count;
+}
+
+/* Wait for a child process to complete.  Actually the child process
+   has already completed, and we just need to return the exit
+   status.  */
+
+static int
+pex_aros_wait (struct pex_obj *obj, long pid, int *status,
+		struct pex_time *time, int done ATTRIBUTE_UNUSED,
+		const char **errmsg ATTRIBUTE_UNUSED,
+		int *err ATTRIBUTE_UNUSED)
+{
+  int *statuses;
+
+  if (time != NULL)
+    memset (time, 0, sizeof *time);
+
+  statuses = (int *) obj->sysdep;
+  *status = statuses[pid];
+
+  return 0;
+}
