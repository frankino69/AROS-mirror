!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
$memfile	tool/memleak3.tcl	/^process_input $memfile memmap$/;"	p
(INTEGER	www/datatype3.tcl	/^classes (INTEGER and REAL) and TEXT before performing a comparison.$/;"	c
ACCEPT	tool/lemon.c	/^    ACCEPT,$/;"	e	enum:action::e_action	file:
ADDR	vdbe.h	88;"	d
ALTER	tool/mkkeywordhash.c	33;"	d	file:
ALTER	tool/mkkeywordhash.c	35;"	d	file:
ALWAYS	tool/mkkeywordhash.c	37;"	d	file:
ARRAYSIZE	where.c	113;"	d	file:
ATTACH	tool/mkkeywordhash.c	39;"	d	file:
ATTACH	tool/mkkeywordhash.c	41;"	d	file:
AUTOINCR	tool/mkkeywordhash.c	44;"	d	file:
AUTOINCR	tool/mkkeywordhash.c	46;"	d	file:
Action_add	tool/lemon.c	/^void Action_add(app,type,sp,arg)$/;"	f
Action_new	tool/lemon.c	/^struct action *Action_new(){$/;"	f
Action_sort	tool/lemon.c	/^struct action *Action_sort(ap)$/;"	f
AddHyperlinks	www/capi3.tcl	/^proc AddHyperlinks {txt} {$/;"	p
Addr	sqliteInt.h	253;"	d
Agg	vdbeInt.h	/^struct Agg {$/;"	s
Agg	vdbeInt.h	/^typedef struct Agg Agg;$/;"	t
AggElem	vdbeInt.h	/^struct AggElem {$/;"	s
AggElem	vdbeInt.h	/^typedef struct AggElem AggElem;$/;"	t
AggExpr	sqliteInt.h	/^struct AggExpr {$/;"	s
AggExpr	sqliteInt.h	/^typedef struct AggExpr AggExpr;$/;"	t
AggInsert	vdbe.c	/^static int AggInsert(Agg *p, char *zKey, int nKey){$/;"	f	file:
AggregateInfo	select.c	/^struct AggregateInfo {$/;"	s	file:
AggregateInfo	select.c	/^typedef struct AggregateInfo AggregateInfo;$/;"	t	file:
Argv0	shell.c	/^static STRPTR Argv0;$/;"	v	file:
ArraySize	shell.c	291;"	d	file:
ArraySize	sqliteInt.h	324;"	d
AttachKey	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	s	file:
AuthContext	sqliteInt.h	/^struct AuthContext {$/;"	s
AuthContext	sqliteInt.h	/^typedef struct AuthContext AuthContext;$/;"	t
AuxData	vdbeInt.h	/^  struct AuxData {$/;"	s	struct:VdbeFunc
BLOCKSIZE	os_test.c	56;"	d	file:
BLOCK_OFFSET	os_test.c	57;"	d	file:
BMS	where.c	512;"	d	file:
BOOL	sqliteInt.h	/^		typedef u8 BOOL;$/;"	t
BTREE_INTKEY	btree.h	86;"	d
BTREE_LEAFDATA	btree.h	88;"	d
BTREE_MEMORY	btree.h	55;"	d
BTREE_NO_READLOCK	btree.h	54;"	d
BTREE_OMIT_JOURNAL	btree.h	53;"	d
BTREE_ZERODATA	btree.h	87;"	d
B_FALSE	tool/lemon.c	/^typedef enum {B_FALSE=0, B_TRUE} Boolean;$/;"	e	file:
B_TRUE	tool/lemon.c	/^typedef enum {B_FALSE=0, B_TRUE} Boolean;$/;"	e	file:
Bitmask	sqliteInt.h	/^typedef unsigned int Bitmask;$/;"	t
Bool	vdbeInt.h	/^typedef unsigned char Bool;$/;"	t
Boolean	tool/lemon.c	/^typedef enum {B_FALSE=0, B_TRUE} Boolean;$/;"	t	file:
Bt	btree.c	/^typedef Btree Bt;$/;"	t	file:
BtCursor	btree.c	/^struct BtCursor {$/;"	s	file:
BtCursor	btree.h	/^typedef struct BtCursor BtCursor;$/;"	t
Btree	btree.c	/^struct Btree {$/;"	s	file:
Btree	btree.h	/^typedef struct Btree Btree;$/;"	t
BusyHandler	sqliteInt.h	/^struct BusyHandler {$/;"	s
BusyHandler	sqliteInt.h	/^typedef struct BusyHandler BusyHandler;$/;"	t
CHECK_FOR_INTERRUPT	vdbe.c	414;"	d	file:
CHECK_PAGE	pager.c	496;"	d	file:
CHECK_PAGE	pager.c	504;"	d	file:
CODEC	pager.c	200;"	d	file:
CODEC	pager.c	202;"	d	file:
COMPLETE	tool/lemon.c	/^    COMPLETE,              \/* The status is used during followset and *\/$/;"	e	enum:config::<anonymous>	file:
COMPOUND	tool/mkkeywordhash.c	49;"	d	file:
COMPOUND	tool/mkkeywordhash.c	51;"	d	file:
CONFLICT	tool/lemon.c	/^    CONFLICT,                \/* Was a reduce, but part of a conflict *\/$/;"	e	enum:action::e_action	file:
CONFLICT	tool/mkkeywordhash.c	54;"	d	file:
CONFLICT	tool/mkkeywordhash.c	56;"	d	file:
CONST_STRPTR	sqliteInt.h	/^		typedef const char* CONST_STRPTR;$/;"	t
CellInfo	btree.c	/^struct CellInfo {$/;"	s	file:
CellInfo	btree.c	/^typedef struct CellInfo CellInfo;$/;"	t	file:
Cleanup	vdbeaux.c	/^static void Cleanup(Vdbe *p){$/;"	f	file:
Code	www/opcode.tcl	/^proc Code {body} {$/;"	p
Code	www/sqlite.tcl	/^proc Code {body} {$/;"	p
Code	www/vdbe.tcl	/^proc Code {body} {$/;"	p
CollSeq	sqliteInt.h	/^struct CollSeq {$/;"	s
CollSeq	sqliteInt.h	/^typedef struct CollSeq CollSeq;$/;"	t
Column	sqliteInt.h	/^struct Column {$/;"	s
Column	sqliteInt.h	/^typedef struct Column Column;$/;"	t
CompressTables	tool/lemon.c	/^void CompressTables(lemp)$/;"	f
ConfigPrint	tool/lemon.c	/^void ConfigPrint(fp,cfp)$/;"	f
Configcmp	tool/lemon.c	/^int Configcmp(a,b)$/;"	f
Configlist_add	tool/lemon.c	/^struct config *Configlist_add(rp,dot)$/;"	f
Configlist_addbasis	tool/lemon.c	/^struct config *Configlist_addbasis(rp,dot)$/;"	f
Configlist_basis	tool/lemon.c	/^struct config *Configlist_basis(){$/;"	f
Configlist_closure	tool/lemon.c	/^void Configlist_closure(lemp)$/;"	f
Configlist_eat	tool/lemon.c	/^void Configlist_eat(cfp)$/;"	f
Configlist_init	tool/lemon.c	/^void Configlist_init(){$/;"	f
Configlist_reset	tool/lemon.c	/^void Configlist_reset(){$/;"	f
Configlist_return	tool/lemon.c	/^struct config *Configlist_return(){$/;"	f
Configlist_sort	tool/lemon.c	/^void Configlist_sort(){$/;"	f
Configlist_sortbasis	tool/lemon.c	/^void Configlist_sortbasis(){$/;"	f
Configtable_clear	tool/lemon.c	/^void Configtable_clear(f)$/;"	f
Configtable_find	tool/lemon.c	/^struct config *Configtable_find(key)$/;"	f
Configtable_init	tool/lemon.c	/^void Configtable_init(){$/;"	f
Configtable_insert	tool/lemon.c	/^int Configtable_insert(data)$/;"	f
Context	md5.c	/^struct Context {$/;"	s	file:
Context	vdbeInt.h	/^struct Context {$/;"	s
Context	vdbeInt.h	/^typedef struct Context Context;$/;"	t
CountCtx	func.c	/^struct CountCtx {$/;"	s	file:
CountCtx	func.c	/^typedef struct CountCtx CountCtx;$/;"	t	file:
Cursor	vdbeInt.h	/^struct Cursor {$/;"	s
Cursor	vdbeInt.h	/^typedef struct Cursor Cursor;$/;"	t
D	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
DATA_TO_PGHDR	pager.c	210;"	d	file:
DB_FILE	test/threadtest2.c	28;"	d	file:
DB_SchemaLoaded	sqliteInt.h	397;"	d
DB_UnresetViews	sqliteInt.h	398;"	d
DateTime	date.c	/^struct DateTime {$/;"	s	file:
DateTime	date.c	/^typedef struct DateTime DateTime;$/;"	t	file:
Db	sqliteInt.h	/^struct Db {$/;"	s
Db	sqliteInt.h	/^typedef struct Db Db;$/;"	t
DbBusyHandler	tclsqlite.c	/^static int DbBusyHandler(void *cd, int nTries){$/;"	f	file:
DbClearProperty	sqliteInt.h	385;"	d
DbCommitHandler	tclsqlite.c	/^static int DbCommitHandler(void *cd){$/;"	f	file:
DbDeleteCmd	tclsqlite.c	/^static void DbDeleteCmd(void *db){$/;"	f	file:
DbFixer	sqliteInt.h	/^struct DbFixer {$/;"	s
DbFixer	sqliteInt.h	/^typedef struct DbFixer DbFixer;$/;"	t
DbHasAnyProperty	sqliteInt.h	383;"	d
DbHasProperty	sqliteInt.h	382;"	d
DbMain	tclsqlite.c	/^static int DbMain(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbObjCmd	tclsqlite.c	/^static int DbObjCmd(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbProgressHandler	tclsqlite.c	/^static int DbProgressHandler(void *cd){$/;"	f	file:
DbSetProperty	sqliteInt.h	384;"	d
DbTraceHandler	tclsqlite.c	/^static void DbTraceHandler(void *cd, const char *zSql){$/;"	f	file:
Deephemeralize	vdbe.c	116;"	d	file:
DigestToBase16	md5.c	/^static void DigestToBase16(unsigned char *digest, char *zBuf)$/;"	f	file:
Dynamicify	vdbe.c	102;"	d	file:
EP_Agg	sqliteInt.h	871;"	d
EP_Error	sqliteInt.h	873;"	d
EP_FromJoin	sqliteInt.h	870;"	d
EP_Not	sqliteInt.h	874;"	d
EP_Resolved	sqliteInt.h	872;"	d
EP_VarSelect	sqliteInt.h	875;"	d
ERRLOC	sqliteInt.h	207;"	d
ERRLOC	sqliteInt.h	210;"	d
ERRMSGSIZE	tool/lemon.c	1260;"	d	file:
ERROR	tool/lemon.c	/^    ERROR,$/;"	e	enum:action::e_action	file:
EXCLUSIVE_LOCK	os.h	113;"	d
EXPLAIN	tool/mkkeywordhash.c	59;"	d	file:
EXPLAIN	tool/mkkeywordhash.c	61;"	d	file:
EXTRA_SIZE	btree.c	291;"	d	file:
ErrorMsg	tool/lemon.c	/^void ErrorMsg(const char *filename, int lineno, const char *format, ...){$/;"	f
Example	www/lang.tcl	/^proc Example {text} {$/;"	p
Exit	test/threadtest1.c	/^static void Exit(int rc){$/;"	f	file:
Expr	sqliteInt.h	/^struct Expr {$/;"	s
Expr	sqliteInt.h	/^typedef struct Expr Expr;$/;"	t
ExprClearProperty	sqliteInt.h	884;"	d
ExprHasAnyProperty	sqliteInt.h	882;"	d
ExprHasProperty	sqliteInt.h	881;"	d
ExprInfo	where.c	/^struct ExprInfo {$/;"	s	file:
ExprInfo	where.c	/^typedef struct ExprInfo ExprInfo;$/;"	t	file:
ExprList	sqliteInt.h	/^struct ExprList {$/;"	s
ExprList	sqliteInt.h	/^typedef struct ExprList ExprList;$/;"	t
ExprList_item	sqliteInt.h	/^  struct ExprList_item {$/;"	s	struct:ExprList
ExprMaskSet	where.c	/^struct ExprMaskSet {$/;"	s	file:
ExprMaskSet	where.c	/^typedef struct ExprMaskSet ExprMaskSet;$/;"	t	file:
ExprSetProperty	sqliteInt.h	883;"	d
F1	md5.c	70;"	d	file:
F2	md5.c	71;"	d	file:
F3	md5.c	72;"	d	file:
F4	md5.c	73;"	d	file:
FALSE	sqliteInt.h	221;"	d
FILEHANDLEID	pager.c	59;"	d	file:
FILEHANDLEID	pager.c	62;"	d	file:
FKEY	tool/mkkeywordhash.c	64;"	d	file:
FKEY	tool/mkkeywordhash.c	66;"	d	file:
FKey	sqliteInt.h	/^struct FKey {$/;"	s
FKey	sqliteInt.h	/^typedef struct FKey FKey;$/;"	t
FLAG_INTERN	printf.c	107;"	d	file:
FLAG_SIGNED	printf.c	106;"	d	file:
FLAG_STRING	printf.c	108;"	d	file:
FORCE_ALIGNMENT	pager.c	137;"	d	file:
FindActions	tool/lemon.c	/^void FindActions(lemp)$/;"	f
FindFirstSets	tool/lemon.c	/^void FindFirstSets(lemp)$/;"	f
FindFollowSets	tool/lemon.c	/^void FindFollowSets(lemp)$/;"	f
FindLinks	tool/lemon.c	/^void FindLinks(lemp)$/;"	f
FindRulePrecedences	tool/lemon.c	/^void FindRulePrecedences(xp)$/;"	f
FindStates	tool/lemon.c	/^void FindStates(lemp)$/;"	f
FuncDef	sqliteInt.h	/^struct FuncDef {$/;"	s
FuncDef	sqliteInt.h	/^typedef struct FuncDef FuncDef;$/;"	t
HEADING	www/lockingv3.tcl	/^proc HEADING {level title} {$/;"	p
Hash	hash.h	/^struct Hash {$/;"	s
Hash	hash.h	/^typedef struct Hash Hash;$/;"	t
HashElem	hash.h	/^struct HashElem {$/;"	s
HashElem	hash.h	/^typedef struct HashElem HashElem;$/;"	t
Heading	www/download.tcl	/^proc Heading {title} {$/;"	p
INCOMPLETE	tool/lemon.c	/^    INCOMPLETE             \/*    shift computations *\/$/;"	e	enum:config::<anonymous>	file:
INITIALIZE	tool/lemon.c	/^    INITIALIZE,$/;"	e	enum:pstate::e_state	file:
INT16_TYPE	sqliteInt.h	176;"	d
INT8_TYPE	sqliteInt.h	182;"	d
INTERFACE	lempar.c	22;"	d	file:
INTERFACE	parse.c	60;"	d	file:
INTERFACE	tool/lempar.c	22;"	d	file:
IN_RHS	tool/lemon.c	/^    IN_RHS,$/;"	e	enum:pstate::e_state	file:
ISAUTOVACUUM	btree.c	3728;"	d	file:
ISAUTOVACUUM	btree.c	3730;"	d	file:
ISOPT	tool/lemon.c	1597;"	d	file:
IdChar	tokenize.c	68;"	d	file:
IdList	sqliteInt.h	/^struct IdList {$/;"	s
IdList	sqliteInt.h	/^typedef struct IdList IdList;$/;"	t
IdList_item	sqliteInt.h	/^  struct IdList_item {$/;"	s	struct:IdList
Index	sqliteInt.h	/^struct Index {$/;"	s
Index	sqliteInt.h	/^typedef struct Index Index;$/;"	t
InitData	sqliteInt.h	/^} InitData;$/;"	t
Integerify	vdbe.c	127;"	d	file:
IntegrityCk	btree.c	/^struct IntegrityCk {$/;"	s	file:
IntegrityCk	btree.c	/^typedef struct IntegrityCk IntegrityCk;$/;"	t	file:
JOURNAL_HDR_SZ	pager.c	353;"	d	file:
JOURNAL_PG_SZ	pager.c	346;"	d	file:
JT_ERROR	sqliteInt.h	971;"	d
JT_INNER	sqliteInt.h	966;"	d
JT_LEFT	sqliteInt.h	968;"	d
JT_NATURAL	sqliteInt.h	967;"	d
JT_OUTER	sqliteInt.h	970;"	d
JT_RIGHT	sqliteInt.h	969;"	d
KeyClass	sqliteInt.h	/^typedef struct KeyClass KeyClass;$/;"	t
KeyInfo	sqliteInt.h	/^struct KeyInfo {$/;"	s
KeyInfo	sqliteInt.h	/^typedef struct KeyInfo KeyInfo;$/;"	t
Keylist	vdbeInt.h	/^struct Keylist {$/;"	s
Keylist	vdbeInt.h	/^typedef struct Keylist Keylist;$/;"	t
Keyword	tool/mkkeywordhash.c	/^struct Keyword {$/;"	s	file:
Keyword	tool/mkkeywordhash.c	/^typedef struct Keyword Keyword;$/;"	t	file:
Keyword	www/lang.tcl	/^proc Keyword {name} {$/;"	p
LEFT	tool/lemon.c	/^    LEFT,$/;"	e	enum:symbol::e_assoc	file:
LHS_ALIAS_1	tool/lemon.c	/^    LHS_ALIAS_1,$/;"	e	enum:pstate::e_state	file:
LHS_ALIAS_2	tool/lemon.c	/^    LHS_ALIAS_2,$/;"	e	enum:pstate::e_state	file:
LHS_ALIAS_3	tool/lemon.c	/^    LHS_ALIAS_3,$/;"	e	enum:pstate::e_state	file:
LINESIZE	tool/lemon.c	2849;"	d	file:
LINEWIDTH	tool/lemon.c	1261;"	d	file:
LISTSIZE	tool/lemon.c	1566;"	d	file:
LONGDOUBLE_TYPE	sqliteInt.h	185;"	d
LikeOp	parse.c	/^struct LikeOp {$/;"	s	file:
LimitVal	parse.c	/^struct LimitVal {$/;"	s	file:
Link	www/mingw.tcl	/^proc Link {path {file {}}} {$/;"	p
M	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
MASTER_NAME	sqliteInt.h	307;"	d
MASTER_ROOT	sqliteInt.h	313;"	d
MAXRHS	tool/lemon.c	25;"	d	file:
MAXRHS	tool/lemon.c	27;"	d	file:
MAX_6BYTE	vdbeaux.c	1646;"	d	file:
MAX_ATTACHED	sqliteInt.h	120;"	d
MAX_PAGES	sqliteInt.h	69;"	d
MAX_PAGES	sqliteInt.h	71;"	d
MAX_PREPARED_STMTS	tclsqlite.c	26;"	d	file:
MAX_ROWID	vdbe.c	3006;"	d	file:
MAX_ROWID	vdbe.c	3012;"	d	file:
MD5Context	md5.c	/^typedef char MD5Context[88];$/;"	t	file:
MD5Final	md5.c	/^static void MD5Final(unsigned char digest[16], MD5Context *pCtx)$/;"	f	file:
MD5Init	md5.c	/^static void MD5Init(MD5Context *pCtx)$/;"	f	file:
MD5STEP	md5.c	76;"	d	file:
MD5Transform	md5.c	/^static void MD5Transform(uint32 buf[4], const uint32 in[16])$/;"	f	file:
MD5Update	md5.c	/^void MD5Update(MD5Context *pCtx, const unsigned char *buf, unsigned int len)$/;"	f	file:
MEMDB	pager.c	362;"	d	file:
MEMDB	pager.c	364;"	d	file:
MEM_AggCtx	vdbeInt.h	181;"	d
MEM_Blob	vdbeInt.h	164;"	d
MEM_Dyn	vdbeInt.h	172;"	d
MEM_Ephem	vdbeInt.h	174;"	d
MEM_Int	vdbeInt.h	162;"	d
MEM_Null	vdbeInt.h	160;"	d
MEM_Real	vdbeInt.h	163;"	d
MEM_Short	vdbeInt.h	175;"	d
MEM_Static	vdbeInt.h	173;"	d
MEM_Str	vdbeInt.h	161;"	d
MEM_Term	vdbeInt.h	171;"	d
METHOD	www/tclsqlite.tcl	/^proc METHOD {name text} {$/;"	p
MODE_Column	shell.c	267;"	d	file:
MODE_Csv	shell.c	273;"	d	file:
MODE_Html	shell.c	270;"	d	file:
MODE_Insert	shell.c	271;"	d	file:
MODE_Line	shell.c	266;"	d	file:
MODE_List	shell.c	268;"	d	file:
MODE_NUM_OF	shell.c	274;"	d	file:
MODE_Semi	shell.c	269;"	d	file:
MODE_Tcl	shell.c	272;"	d	file:
MX_CELL	btree.c	229;"	d	file:
MX_CELL_SIZE	btree.c	223;"	d	file:
Md5_Init	md5.c	/^int Md5_Init(Tcl_Interp *interp)$/;"	f
Md5_Register	md5.c	/^void Md5_Register(sqlite3 *db)$/;"	f
Mem	vdbeInt.h	/^struct Mem {$/;"	s
Mem	vdbeInt.h	/^typedef struct Mem Mem;$/;"	t
MemPage	btree.c	/^struct MemPage {$/;"	s	file:
MemPage	btree.c	/^typedef struct MemPage MemPage;$/;"	t	file:
MemoryCheck	tool/lemon.c	271;"	d	file:
Merge	vdbe.c	/^static Sorter *Merge(Sorter *pLeft, Sorter *pRight, KeyInfo *pKeyInfo){$/;"	f	file:
MinMaxCtx	func.c	/^struct MinMaxCtx {$/;"	s	file:
MinMaxCtx	func.c	/^typedef struct MinMaxCtx MinMaxCtx;$/;"	t	file:
NB	btree.c	3625;"	d	file:
NBFS	vdbeInt.h	102;"	d
NDELAY	main.c	314;"	d	file:
NEXT	tool/lemon.c	1498;"	d	file:
NKEYWORD	tool/mkkeywordhash.c	/^static int NKEYWORD = (sizeof(aKeywordTable)\/sizeof(aKeywordTable[0]));$/;"	v	file:
NN	btree.c	3624;"	d	file:
NONE	tool/lemon.c	/^    NONE,$/;"	e	enum:symbol::e_assoc	file:
NONTERMINAL	tool/lemon.c	/^    NONTERMINAL$/;"	e	enum:symbol::<anonymous>	file:
NOPUSH_MASK_0	opcodes.h	135;"	d
NOPUSH_MASK_1	opcodes.h	136;"	d
NOPUSH_MASK_2	opcodes.h	137;"	d
NOPUSH_MASK_3	opcodes.h	138;"	d
NOPUSH_MASK_4	opcodes.h	139;"	d
NOPUSH_MASK_5	opcodes.h	140;"	d
NOPUSH_MASK_6	opcodes.h	141;"	d
NOPUSH_MASK_7	opcodes.h	142;"	d
NOPUSH_MASK_8	opcodes.h	143;"	d
NOPUSH_MASK_9	opcodes.h	144;"	d
NOT_USED	tool/lemon.c	/^    NOT_USED                 \/* Deleted by compression *\/$/;"	e	enum:action::e_action	file:
NO_LOCK	os.h	109;"	d
NO_OFFSET	tool/lemon.c	215;"	d	file:
NSORT	vdbeInt.h	143;"	d
NULL	www/datatype3.tcl	/^class NULL come first, followed by INTEGER and REAL values$/;"	c
NULL_ALWAYS_DISTINCT	sqliteInt.h	99;"	d
NULL_DISTINCT_FOR_UNIQUE	sqliteInt.h	112;"	d
NUM_PREPARED_STMTS	tclsqlite.c	25;"	d	file:
N_GUARD	util.c	76;"	d	file:
N_PG_HASH	pager.c	220;"	d	file:
NameContext	sqliteInt.h	/^struct NameContext {$/;"	s
NameContext	sqliteInt.h	/^typedef struct NameContext NameContext;$/;"	t
Nonterminal	www/lang.tcl	/^proc Nonterminal {name} {$/;"	p
OE_Abort	sqliteInt.h	716;"	d
OE_Cascade	sqliteInt.h	724;"	d
OE_Default	sqliteInt.h	726;"	d
OE_Fail	sqliteInt.h	717;"	d
OE_Ignore	sqliteInt.h	718;"	d
OE_None	sqliteInt.h	714;"	d
OE_Replace	sqliteInt.h	719;"	d
OE_Restrict	sqliteInt.h	721;"	d
OE_Rollback	sqliteInt.h	715;"	d
OE_SetDflt	sqliteInt.h	723;"	d
OE_SetNull	sqliteInt.h	722;"	d
OMIT_TEMPDB	sqliteInt.h	85;"	d
OMIT_TEMPDB	sqliteInt.h	87;"	d
OPFLAG_LASTROWID	sqliteInt.h	1176;"	d
OPFLAG_NCHANGE	sqliteInt.h	1175;"	d
OPT_DBL	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::<anonymous>	file:
OPT_FDBL	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::<anonymous>	file:
OPT_FFLAG	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::<anonymous>	file:
OPT_FINT	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::<anonymous>	file:
OPT_FLAG	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::<anonymous>	file:
OPT_FSTR	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	e	enum:s_options::<anonymous>	file:
OPT_INT	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::<anonymous>	file:
OPT_STR	tool/lemon.c	/^  enum { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:s_options::<anonymous>	file:
OP_AbsValue	opcodes.h	102;"	d
OP_Add	opcodes.h	122;"	d
OP_AddImm	opcodes.h	53;"	d
OP_AggContextPop	opcodes.h	88;"	d
OP_AggContextPush	opcodes.h	20;"	d
OP_AggFocus	opcodes.h	11;"	d
OP_AggFunc	opcodes.h	42;"	d
OP_AggGet	opcodes.h	106;"	d
OP_AggInit	opcodes.h	110;"	d
OP_AggNext	opcodes.h	13;"	d
OP_AggReset	opcodes.h	114;"	d
OP_AggSet	opcodes.h	64;"	d
OP_And	opcodes.h	32;"	d
OP_AutoCommit	opcodes.h	25;"	d
OP_BitAnd	opcodes.h	69;"	d
OP_BitNot	opcodes.h	126;"	d
OP_BitOr	opcodes.h	108;"	d
OP_Blob	opcodes.h	121;"	d
OP_Callback	opcodes.h	76;"	d
OP_Clear	opcodes.h	94;"	d
OP_Close	opcodes.h	43;"	d
OP_CollSeq	opcodes.h	21;"	d
OP_Column	opcodes.h	5;"	d
OP_Concat	opcodes.h	68;"	d
OP_ContextPop	opcodes.h	107;"	d
OP_ContextPush	opcodes.h	77;"	d
OP_CreateIndex	opcodes.h	45;"	d
OP_CreateTable	opcodes.h	70;"	d
OP_Delete	opcodes.h	87;"	d
OP_Destroy	opcodes.h	116;"	d
OP_Distinct	opcodes.h	112;"	d
OP_Divide	opcodes.h	63;"	d
OP_DropIndex	opcodes.h	79;"	d
OP_DropTable	opcodes.h	85;"	d
OP_DropTrigger	opcodes.h	78;"	d
OP_Dup	opcodes.h	92;"	d
OP_Eq	opcodes.h	14;"	d
OP_Expire	opcodes.h	23;"	d
OP_ForceInt	opcodes.h	118;"	d
OP_Found	opcodes.h	127;"	d
OP_Function	opcodes.h	31;"	d
OP_Ge	opcodes.h	10;"	d
OP_Gosub	opcodes.h	62;"	d
OP_Goto	opcodes.h	93;"	d
OP_Gt	opcodes.h	26;"	d
OP_Halt	opcodes.h	50;"	d
OP_HexBlob	opcodes.h	4;"	d
OP_IdxDelete	opcodes.h	81;"	d
OP_IdxGE	opcodes.h	80;"	d
OP_IdxGT	opcodes.h	95;"	d
OP_IdxInsert	opcodes.h	111;"	d
OP_IdxIsNull	opcodes.h	47;"	d
OP_IdxLT	opcodes.h	52;"	d
OP_IdxRowid	opcodes.h	73;"	d
OP_If	opcodes.h	17;"	d
OP_IfMemPos	opcodes.h	7;"	d
OP_IfNot	opcodes.h	84;"	d
OP_Insert	opcodes.h	115;"	d
OP_Integer	opcodes.h	65;"	d
OP_IntegrityCk	opcodes.h	29;"	d
OP_IsNull	opcodes.h	72;"	d
OP_IsUnique	opcodes.h	46;"	d
OP_Last	opcodes.h	71;"	d
OP_Le	opcodes.h	97;"	d
OP_ListRead	opcodes.h	89;"	d
OP_ListReset	opcodes.h	90;"	d
OP_ListRewind	opcodes.h	28;"	d
OP_ListWrite	opcodes.h	44;"	d
OP_Lt	opcodes.h	113;"	d
OP_MakeRecord	opcodes.h	86;"	d
OP_MemIncr	opcodes.h	61;"	d
OP_MemLoad	opcodes.h	3;"	d
OP_MemMax	opcodes.h	56;"	d
OP_MemStore	opcodes.h	123;"	d
OP_MoveGe	opcodes.h	125;"	d
OP_MoveGt	opcodes.h	9;"	d
OP_MoveLe	opcodes.h	83;"	d
OP_MoveLt	opcodes.h	96;"	d
OP_Multiply	opcodes.h	38;"	d
OP_MustBeInt	opcodes.h	49;"	d
OP_Ne	opcodes.h	105;"	d
OP_Negative	opcodes.h	104;"	d
OP_NewRowid	opcodes.h	37;"	d
OP_Next	opcodes.h	109;"	d
OP_Noop	opcodes.h	34;"	d
OP_Not	opcodes.h	100;"	d
OP_NotExists	opcodes.h	59;"	d
OP_NotFound	opcodes.h	48;"	d
OP_NotNull	opcodes.h	16;"	d
OP_NotUsed_125	opcodes.h	131;"	d
OP_NotUsed_126	opcodes.h	132;"	d
OP_NotUsed_127	opcodes.h	133;"	d
OP_Null	opcodes.h	120;"	d
OP_NullRow	opcodes.h	128;"	d
OP_OpenPseudo	opcodes.h	119;"	d
OP_OpenRead	opcodes.h	22;"	d
OP_OpenTemp	opcodes.h	60;"	d
OP_OpenWrite	opcodes.h	15;"	d
OP_Or	opcodes.h	58;"	d
OP_ParseSchema	opcodes.h	41;"	d
OP_Pop	opcodes.h	19;"	d
OP_Prev	opcodes.h	67;"	d
OP_Pull	opcodes.h	99;"	d
OP_Push	opcodes.h	57;"	d
OP_ReadCookie	opcodes.h	117;"	d
OP_Real	opcodes.h	8;"	d
OP_Remainder	opcodes.h	36;"	d
OP_ResetCount	opcodes.h	75;"	d
OP_Return	opcodes.h	35;"	d
OP_Rewind	opcodes.h	124;"	d
OP_RowData	opcodes.h	55;"	d
OP_RowKey	opcodes.h	12;"	d
OP_Rowid	opcodes.h	51;"	d
OP_SetCookie	opcodes.h	6;"	d
OP_SetNumColumns	opcodes.h	101;"	d
OP_ShiftLeft	opcodes.h	91;"	d
OP_ShiftRight	opcodes.h	74;"	d
OP_Sort	opcodes.h	27;"	d
OP_SortInsert	opcodes.h	30;"	d
OP_SortNext	opcodes.h	66;"	d
OP_SortReset	opcodes.h	24;"	d
OP_Statement	opcodes.h	54;"	d
OP_String	opcodes.h	40;"	d
OP_String8	opcodes.h	18;"	d
OP_Subtract	opcodes.h	33;"	d
OP_Transaction	opcodes.h	103;"	d
OP_Vacuum	opcodes.h	82;"	d
OP_Variable	opcodes.h	39;"	d
OP_VerifyCookie	opcodes.h	98;"	d
OS_OTHER	os.h	27;"	d
OS_UNIX	os.h	31;"	d
OS_UNIX	os.h	34;"	d
OS_UNIX	os.h	37;"	d
OS_UNIX	os.h	40;"	d
OS_UNIX	os_test.c	36;"	d	file:
OS_UNIX	os_test.c	38;"	d	file:
OS_UNIX	os_test.h	18;"	d
OS_UNIX	os_test.h	20;"	d
OS_WIN	os.h	30;"	d
OS_WIN	os.h	33;"	d
OS_WIN	os.h	36;"	d
OS_WIN	os.h	44;"	d
O_BINARY	os_aros.c	51;"	d	file:
O_LARGEFILE	os_aros.c	41;"	d	file:
O_LARGEFILE	os_aros.c	44;"	d	file:
O_LARGEFILE	os_aros.c	45;"	d	file:
O_NOFOLLOW	os_aros.c	48;"	d	file:
Op	vdbeInt.h	/^typedef struct VdbeOp Op;$/;"	t
OpenCounter	os_common.h	123;"	d
OpenCounter	os_common.h	125;"	d
Operator	www/lang.tcl	/^proc Operator {name} {$/;"	p
OptArg	tool/lemon.c	/^char *OptArg(n)$/;"	f
OptErr	tool/lemon.c	/^void OptErr(n)$/;"	f
OptInit	tool/lemon.c	/^int OptInit(a,o,err)$/;"	f
OptNArgs	tool/lemon.c	/^int OptNArgs(){$/;"	f
OptPrint	tool/lemon.c	/^void OptPrint(){$/;"	f
OsFile	os_aros.h	/^struct OsFile {$/;"	s
OsFile	os_aros.h	/^typedef struct OsFile OsFile;$/;"	t
OsFile	os_test.c	35;"	d	file:
OsFile	os_test.c	39;"	d	file:
OsFile	os_test.h	/^typedef struct OsTestFile* OsFile;$/;"	t
OsFile	os_test.h	17;"	d
OsFile	os_test.h	21;"	d
OsTestFile	os_test.h	/^struct OsTestFile {$/;"	s
OsTestFile	os_test.h	/^typedef struct OsTestFile OsTestFile;$/;"	t
P3_COLLSEQ	vdbe.h	67;"	d
P3_DYNAMIC	vdbe.h	65;"	d
P3_FUNCDEF	vdbe.h	68;"	d
P3_KEYINFO	vdbe.h	69;"	d
P3_KEYINFO_HANDOFF	vdbe.h	80;"	d
P3_MEM	vdbe.h	71;"	d
P3_NOTUSED	vdbe.h	64;"	d
P3_STATIC	vdbe.h	66;"	d
P3_VDBEFUNC	vdbe.h	70;"	d
PAGERID	pager.c	58;"	d	file:
PAGERID	pager.c	61;"	d	file:
PAGER_ERR_CORRUPT	pager.c	312;"	d	file:
PAGER_ERR_DISK	pager.c	313;"	d	file:
PAGER_ERR_FULL	pager.c	309;"	d	file:
PAGER_ERR_LOCK	pager.c	311;"	d	file:
PAGER_ERR_MEM	pager.c	310;"	d	file:
PAGER_EXCLUSIVE	pager.c	113;"	d	file:
PAGER_MAX_PGNO	pager.c	385;"	d	file:
PAGER_MJ_PGNO	pager.c	380;"	d	file:
PAGER_NO_READLOCK	pager.h	62;"	d
PAGER_OMIT_JOURNAL	pager.h	61;"	d
PAGER_RESERVED	pager.c	112;"	d	file:
PAGER_SECTOR_SIZE	pager.c	370;"	d	file:
PAGER_SHARED	pager.c	111;"	d	file:
PAGER_SYNCED	pager.c	114;"	d	file:
PAGER_UNLOCK	pager.c	110;"	d	file:
PAGESIZE	tool/diffdb.c	13;"	d	file:
PENDING_BYTE	os.h	170;"	d
PENDING_BYTE_PAGE	btree.c	412;"	d	file:
PENDING_LOCK	os.h	112;"	d
PGHDR_TO_DATA	pager.c	209;"	d	file:
PGHDR_TO_EXTRA	pager.c	211;"	d	file:
PGHDR_TO_HIST	pager.c	212;"	d	file:
PRAGMA	tool/mkkeywordhash.c	69;"	d	file:
PRAGMA	tool/mkkeywordhash.c	71;"	d	file:
PRECEDENCE_MARK_1	tool/lemon.c	/^    PRECEDENCE_MARK_1,$/;"	e	enum:pstate::e_state	file:
PRECEDENCE_MARK_2	tool/lemon.c	/^    PRECEDENCE_MARK_2,$/;"	e	enum:pstate::e_state	file:
PREFIXLIMIT	tool/lemon.c	1262;"	d	file:
PRIVATE	tool/lemon.c	22;"	d	file:
PTF_INTKEY	btree.c	244;"	d	file:
PTF_LEAF	btree.c	247;"	d	file:
PTF_LEAFDATA	btree.c	246;"	d	file:
PTF_ZERODATA	btree.c	245;"	d	file:
PTRMAP_BTREE	btree.c	469;"	d	file:
PTRMAP_FREEPAGE	btree.c	466;"	d	file:
PTRMAP_ISPAGE	btree.c	432;"	d	file:
PTRMAP_OVERFLOW1	btree.c	467;"	d	file:
PTRMAP_OVERFLOW2	btree.c	468;"	d	file:
PTRMAP_PAGENO	btree.c	430;"	d	file:
PTRMAP_PTROFFSET	btree.c	431;"	d	file:
PTRMAP_ROOTPAGE	btree.c	465;"	d	file:
Pager	pager.c	/^struct Pager {$/;"	s	file:
Pager	pager.h	/^typedef struct Pager Pager;$/;"	t
Parse	lempar.c	/^void Parse($/;"	f
Parse	sqliteInt.h	/^struct Parse {$/;"	s
Parse	sqliteInt.h	/^typedef struct Parse Parse;$/;"	t
Parse	tool/lemon.c	/^void Parse(gp)$/;"	f
Parse	tool/lempar.c	/^void Parse($/;"	f
ParseAlloc	lempar.c	/^void *ParseAlloc(void *(*mallocProc)(size_t)){$/;"	f
ParseAlloc	tool/lempar.c	/^void *ParseAlloc(void *(*mallocProc)(size_t)){$/;"	f
ParseFree	lempar.c	/^void ParseFree($/;"	f
ParseFree	tool/lempar.c	/^void ParseFree($/;"	f
ParseTokenName	lempar.c	/^const char *ParseTokenName(int tokenType){$/;"	f
ParseTokenName	tool/lempar.c	/^const char *ParseTokenName(int tokenType){$/;"	f
ParseTrace	lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
ParseTrace	tool/lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
PgHdr	pager.c	/^struct PgHdr {$/;"	s	file:
PgHdr	pager.c	/^typedef struct PgHdr PgHdr;$/;"	t	file:
PgHistory	pager.c	/^struct PgHistory {$/;"	s	file:
PgHistory	pager.c	/^typedef struct PgHistory PgHistory;$/;"	t	file:
Pgno	pager.h	/^typedef unsigned int Pgno;$/;"	t
PlinkPrint	tool/lemon.c	/^PRIVATE void PlinkPrint(out,plp,tag)$/;"	f
Plink_add	tool/lemon.c	/^void Plink_add(plpp,cfp)$/;"	f
Plink_copy	tool/lemon.c	/^void Plink_copy(to,from)$/;"	f
Plink_delete	tool/lemon.c	/^void Plink_delete(plp)$/;"	f
Plink_new	tool/lemon.c	/^struct plink *Plink_new(){$/;"	f
PrintAction	tool/lemon.c	/^int PrintAction(struct action *ap, FILE *fp, int indent){$/;"	f
Product	www/download.tcl	/^proc Product {pattern desc} {$/;"	p
Programs	www/different.tcl	/^  process.  Programs that want to access the database communicate$/;"	p
QueryCoder	expr.c	/^struct QueryCoder {$/;"	s	file:
QueryCoder	expr.c	/^typedef struct QueryCoder QueryCoder;$/;"	t	file:
QueryResult	test/threadtest1.c	/^struct QueryResult {$/;"	s	file:
RD_RESOLVED	tool/lemon.c	/^    RD_RESOLVED,             \/* Was reduce.  Precedence resolved conflict *\/$/;"	e	enum:action::e_action	file:
READ_UTF16BE	utf.c	187;"	d	file:
READ_UTF16LE	utf.c	177;"	d	file:
READ_UTF8	utf.c	111;"	d	file:
REDUCE	tool/lemon.c	/^    REDUCE,$/;"	e	enum:action::e_action	file:
REFINFO	pager.c	401;"	d	file:
REFINFO	pager.c	403;"	d	file:
REINDEX	tool/mkkeywordhash.c	74;"	d	file:
REINDEX	tool/mkkeywordhash.c	76;"	d	file:
RESERVED_BYTE	os.h	172;"	d
RESERVED_LOCK	os.h	111;"	d
RESYNC_AFTER_DECL_ERROR	tool/lemon.c	/^    RESYNC_AFTER_DECL_ERROR,$/;"	e	enum:pstate::e_state	file:
RESYNC_AFTER_RULE_ERROR	tool/lemon.c	/^    RESYNC_AFTER_RULE_ERROR,$/;"	e	enum:pstate::e_state	file:
RHS_ALIAS_1	tool/lemon.c	/^    RHS_ALIAS_1,$/;"	e	enum:pstate::e_state	file:
RHS_ALIAS_2	tool/lemon.c	/^    RHS_ALIAS_2,$/;"	e	enum:pstate::e_state	file:
RIGHT	tool/lemon.c	/^    RIGHT,$/;"	e	enum:symbol::e_assoc	file:
ROUND8	btree.c	217;"	d	file:
RSKIP_UTF16BE	utf.c	220;"	d	file:
RSKIP_UTF16LE	utf.c	213;"	d	file:
Realify	vdbe.c	135;"	d	file:
Release	vdbe.c	85;"	d	file:
ReportHeader	tool/lemon.c	/^void ReportHeader(lemp)$/;"	f
ReportOutput	tool/lemon.c	/^void ReportOutput(lemp)$/;"	f
ReportTable	tool/lemon.c	/^void ReportTable(lemp, mhflag)$/;"	f
Reprint	tool/lemon.c	/^void Reprint(lemp)$/;"	f
SAVE_SZ	build.c	134;"	d	file:
SCHEMA_TABLE	sqliteInt.h	318;"	d
SEEK	os_common.h	39;"	d
SEEK	os_common.h	50;"	d
SETFNC	sqliteInt.h	208;"	d
SETFNC	sqliteInt.h	211;"	d
SET_FULLSYNC	os.h	76;"	d
SET_FULLSYNC	os_aros.h	78;"	d
SET_FULLSYNC	os_test.h	22;"	d
SHARED_FIRST	os.h	173;"	d
SHARED_LOCK	os.h	110;"	d
SHARED_SIZE	os.h	174;"	d
SHIFT	tool/lemon.c	/^    SHIFT,$/;"	e	enum:action::e_action	file:
SH_RESOLVED	tool/lemon.c	/^    SH_RESOLVED,             \/* Was a shift.  Precedence resolved conflict *\/$/;"	e	enum:action::e_action	file:
SKIP_UTF16BE	utf.c	197;"	d	file:
SKIP_UTF16LE	utf.c	204;"	d	file:
SKIP_UTF8	utf.c	129;"	d	file:
SQLITE3_TEXT	sqlite3.h	815;"	d
SQLITE_ABORT	sqlite3.h	163;"	d
SQLITE_AFF_INTEGER	sqliteInt.h	589;"	d
SQLITE_AFF_NONE	sqliteInt.h	592;"	d
SQLITE_AFF_NUMERIC	sqliteInt.h	590;"	d
SQLITE_AFF_TEXT	sqliteInt.h	591;"	d
SQLITE_ALTER_TABLE	sqlite3.h	453;"	d
SQLITE_ANY	sqlite3.h	1079;"	d
SQLITE_ATTACH	sqlite3.h	451;"	d
SQLITE_AUTH	sqlite3.h	182;"	d
SQLITE_BIGENDIAN	sqliteInt.h	200;"	d
SQLITE_BLOB	sqlite3.h	802;"	d
SQLITE_BUSY	sqlite3.h	164;"	d
SQLITE_BUSY_RESERVED_LOCK	pager.c	130;"	d	file:
SQLITE_CANTOPEN	sqlite3.h	173;"	d
SQLITE_CONSTRAINT	sqlite3.h	178;"	d
SQLITE_COPY	sqlite3.h	427;"	d
SQLITE_CORRUPT	sqlite3.h	170;"	d
SQLITE_CREATE_INDEX	sqlite3.h	428;"	d
SQLITE_CREATE_TABLE	sqlite3.h	429;"	d
SQLITE_CREATE_TEMP_INDEX	sqlite3.h	430;"	d
SQLITE_CREATE_TEMP_TABLE	sqlite3.h	431;"	d
SQLITE_CREATE_TEMP_TRIGGER	sqlite3.h	432;"	d
SQLITE_CREATE_TEMP_VIEW	sqlite3.h	433;"	d
SQLITE_CREATE_TRIGGER	sqlite3.h	434;"	d
SQLITE_CREATE_VIEW	sqlite3.h	435;"	d
SQLITE_CountRows	sqliteInt.h	499;"	d
SQLITE_DEFAULT_AUTOVACUUM	btree.h	31;"	d
SQLITE_DEFAULT_FILE_PERMISSIONS	os_aros.h	98;"	d
SQLITE_DEFAULT_PAGE_SIZE	pager.h	23;"	d
SQLITE_DELETE	sqlite3.h	436;"	d
SQLITE_DENY	sqlite3.h	462;"	d
SQLITE_DETACH	sqlite3.h	452;"	d
SQLITE_DONE	sqlite3.h	187;"	d
SQLITE_DROP_INDEX	sqlite3.h	437;"	d
SQLITE_DROP_TABLE	sqlite3.h	438;"	d
SQLITE_DROP_TEMP_INDEX	sqlite3.h	439;"	d
SQLITE_DROP_TEMP_TABLE	sqlite3.h	440;"	d
SQLITE_DROP_TEMP_TRIGGER	sqlite3.h	441;"	d
SQLITE_DROP_TEMP_VIEW	sqlite3.h	442;"	d
SQLITE_DROP_TRIGGER	sqlite3.h	443;"	d
SQLITE_DROP_VIEW	sqlite3.h	444;"	d
SQLITE_EMPTY	sqlite3.h	175;"	d
SQLITE_ERROR	sqlite3.h	160;"	d
SQLITE_FLOAT	sqlite3.h	800;"	d
SQLITE_FORMAT	sqlite3.h	183;"	d
SQLITE_FULL	sqlite3.h	172;"	d
SQLITE_FullColNames	sqliteInt.h	497;"	d
SQLITE_HASH_BINARY	hash.h	76;"	d
SQLITE_HASH_STRING	hash.h	75;"	d
SQLITE_IGNORE	sqlite3.h	463;"	d
SQLITE_INSERT	sqlite3.h	445;"	d
SQLITE_INTEGER	sqlite3.h	799;"	d
SQLITE_INTERNAL	sqlite3.h	161;"	d
SQLITE_INTERRUPT	sqlite3.h	168;"	d
SQLITE_IOERR	sqlite3.h	169;"	d
SQLITE_InTrans	sqliteInt.h	495;"	d
SQLITE_Initialized	sqliteInt.h	493;"	d
SQLITE_InternChanges	sqliteInt.h	496;"	d
SQLITE_Interrupt	sqliteInt.h	494;"	d
SQLITE_LITTLEENDIAN	sqliteInt.h	201;"	d
SQLITE_LOCKED	sqlite3.h	165;"	d
SQLITE_MAGIC_BUSY	sqliteInt.h	517;"	d
SQLITE_MAGIC_CLOSED	sqliteInt.h	516;"	d
SQLITE_MAGIC_ERROR	sqliteInt.h	518;"	d
SQLITE_MAGIC_OPEN	sqliteInt.h	515;"	d
SQLITE_MAX_PAGE	pager.h	43;"	d
SQLITE_MAX_PAGE_SIZE	pager.h	37;"	d
SQLITE_MAX_VARIABLE_NUMBER	sqliteInt.h	125;"	d
SQLITE_MIN_SLEEP_MS	os_aros.h	89;"	d
SQLITE_MIN_SLEEP_MS	os_aros.h	91;"	d
SQLITE_MISMATCH	sqlite3.h	179;"	d
SQLITE_MISUSE	sqlite3.h	180;"	d
SQLITE_NOLFS	sqlite3.h	181;"	d
SQLITE_NOMEM	sqlite3.h	166;"	d
SQLITE_NOTADB	sqlite3.h	185;"	d
SQLITE_NOTFOUND	sqlite3.h	171;"	d
SQLITE_NULL	sqlite3.h	803;"	d
SQLITE_N_BTREE_META	btree.h	24;"	d
SQLITE_NoReadlock	sqliteInt.h	507;"	d
SQLITE_NullCallback	sqliteInt.h	502;"	d
SQLITE_OK	sqlite3.h	159;"	d
SQLITE_OS_COMMON_H	os_common.h	24;"	d
SQLITE_PERM	sqlite3.h	162;"	d
SQLITE_PRAGMA	sqlite3.h	446;"	d
SQLITE_PROTOCOL	sqlite3.h	174;"	d
SQLITE_RANGE	sqlite3.h	184;"	d
SQLITE_READ	sqlite3.h	447;"	d
SQLITE_READONLY	sqlite3.h	167;"	d
SQLITE_REINDEX	sqlite3.h	454;"	d
SQLITE_ROW	sqlite3.h	186;"	d
SQLITE_SCHEMA	sqlite3.h	176;"	d
SQLITE_SELECT	sqlite3.h	448;"	d
SQLITE_SO_ASC	sqliteInt.h	583;"	d
SQLITE_SO_DESC	sqliteInt.h	584;"	d
SQLITE_STATIC	sqlite3.h	1051;"	d
SQLITE_ShortColNames	sqliteInt.h	498;"	d
SQLITE_SqlTrace	sqliteInt.h	504;"	d
SQLITE_TEMPNAME_SIZE	os_aros.h	83;"	d
SQLITE_TEXT	sqlite3.h	811;"	d
SQLITE_TEXT	sqlite3.h	813;"	d
SQLITE_TOOBIG	sqlite3.h	177;"	d
SQLITE_TRANSACTION	sqlite3.h	449;"	d
SQLITE_TRANSIENT	sqlite3.h	1052;"	d
SQLITE_UPDATE	sqlite3.h	450;"	d
SQLITE_UTF16	sqlite3.h	1078;"	d
SQLITE_UTF16BE	sqlite3.h	1077;"	d
SQLITE_UTF16LE	sqlite3.h	1076;"	d
SQLITE_UTF16NATIVE	sqliteInt.h	400;"	d
SQLITE_UTF8	sqlite3.h	1075;"	d
SQLITE_VERSION	sqlite3.h	32;"	d
SQLITE_VERSION	sqlite3.h	34;"	d
SQLITE_VERSION_NUMBER	sqlite3.h	49;"	d
SQLITE_VERSION_NUMBER	sqlite3.h	51;"	d
SQLITE_VdbeListing	sqliteInt.h	505;"	d
SQLITE_VdbeTrace	sqliteInt.h	492;"	d
SQLITE_WriteSchema	sqliteInt.h	506;"	d
SRT_Callback	sqliteInt.h	1075;"	d
SRT_Discard	sqliteInt.h	1082;"	d
SRT_Except	sqliteInt.h	1079;"	d
SRT_Exists	sqliteInt.h	1085;"	d
SRT_Mem	sqliteInt.h	1076;"	d
SRT_Set	sqliteInt.h	1077;"	d
SRT_Sorter	sqliteInt.h	1083;"	d
SRT_Subroutine	sqliteInt.h	1084;"	d
SRT_Table	sqliteInt.h	1080;"	d
SRT_TempTable	sqliteInt.h	1081;"	d
SRT_Union	sqliteInt.h	1078;"	d
STRICMP	build.c	819;"	d	file:
STRPTR	sqliteInt.h	/^		typedef char* STRPTR;$/;"	t
SUBQUERY	tool/mkkeywordhash.c	79;"	d	file:
SUBQUERY	tool/mkkeywordhash.c	81;"	d	file:
SWAP	where.c	239;"	d	file:
Section	www/lang.tcl	/^proc Section {name label} {$/;"	p
Section	www/pragma.tcl	/^proc Section {name {label {}}} {$/;"	p
Select	sqliteInt.h	/^struct Select {$/;"	s
Select	sqliteInt.h	/^typedef struct Select Select;$/;"	t
Set	vdbeInt.h	/^struct Set {$/;"	s
Set	vdbeInt.h	/^typedef struct Set Set;$/;"	t
SetAdd	tool/lemon.c	/^int SetAdd(s,e)$/;"	f
SetFind	tool/lemon.c	106;"	d	file:
SetFree	tool/lemon.c	/^void SetFree(s)$/;"	f
SetNew	tool/lemon.c	/^char *SetNew(){$/;"	f
SetPrint	tool/lemon.c	/^PRIVATE void SetPrint(out,set,lemp)$/;"	f
SetSize	tool/lemon.c	/^void SetSize(n)$/;"	f
SetUnion	tool/lemon.c	/^int SetUnion(s1,s2)$/;"	f
SimulateDiskfullError	os_common.h	109;"	d
SimulateDiskfullError	os_common.h	115;"	d
SimulateIOError	os_common.h	101;"	d
SimulateIOError	os_common.h	114;"	d
SimulateIOError	os_common.h	94;"	d
Sorter	vdbeInt.h	/^struct Sorter {$/;"	s
Sorter	vdbeInt.h	/^typedef struct Sorter Sorter;$/;"	t
SqlCollate	tclsqlite.c	/^struct SqlCollate {$/;"	s	file:
SqlCollate	tclsqlite.c	/^typedef struct SqlCollate SqlCollate;$/;"	t	file:
SqlFunc	tclsqlite.c	/^struct SqlFunc {$/;"	s	file:
SqlFunc	tclsqlite.c	/^typedef struct SqlFunc SqlFunc;$/;"	t	file:
SqlPreparedStmt	tclsqlite.c	/^struct SqlPreparedStmt {$/;"	s	file:
SqlPreparedStmt	tclsqlite.c	/^typedef struct SqlPreparedStmt SqlPreparedStmt;$/;"	t	file:
Sqlite3_Init	tclsqlite.c	/^int Sqlite3_Init(Tcl_Interp *interp){$/;"	f
Sqlite3_SafeInit	tclsqlite.c	/^int Sqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
SqliteDb	tclsqlite.c	/^struct SqliteDb {$/;"	s	file:
SqliteDb	tclsqlite.c	/^typedef struct SqliteDb SqliteDb;$/;"	t	file:
Sqlite_Init	tclsqlite.c	/^int Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Sqlite_SafeInit	tclsqlite.c	/^int Sqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
SrcList	sqliteInt.h	/^struct SrcList {$/;"	s
SrcList	sqliteInt.h	/^typedef struct SrcList SrcList;$/;"	t
SrcList_item	sqliteInt.h	/^  struct SrcList_item {$/;"	s	struct:SrcList
State_arrayof	tool/lemon.c	/^struct state **State_arrayof()$/;"	f
State_find	tool/lemon.c	/^struct state *State_find(key)$/;"	f
State_init	tool/lemon.c	/^void State_init(){$/;"	f
State_insert	tool/lemon.c	/^int State_insert(data,key)$/;"	f
State_new	tool/lemon.c	/^struct state *State_new()$/;"	f
StdDevCtx	func.c	/^struct StdDevCtx {$/;"	s	file:
StdDevCtx	func.c	/^typedef struct StdDevCtx StdDevCtx;$/;"	t	file:
Stringify	vdbe.c	91;"	d	file:
Strsafe	tool/lemon.c	/^char *Strsafe(y)$/;"	f
Strsafe_find	tool/lemon.c	/^char *Strsafe_find(key)$/;"	f
Strsafe_init	tool/lemon.c	/^void Strsafe_init(){$/;"	f
Strsafe_insert	tool/lemon.c	/^int Strsafe_insert(data)$/;"	f
SumCtx	func.c	/^struct SumCtx {$/;"	s	file:
SumCtx	func.c	/^typedef struct SumCtx SumCtx;$/;"	t	file:
Symbol_Nth	tool/lemon.c	/^struct symbol *Symbol_Nth(n)$/;"	f
Symbol_arrayof	tool/lemon.c	/^struct symbol **Symbol_arrayof()$/;"	f
Symbol_count	tool/lemon.c	/^int Symbol_count()$/;"	f
Symbol_find	tool/lemon.c	/^struct symbol *Symbol_find(key)$/;"	f
Symbol_init	tool/lemon.c	/^void Symbol_init(){$/;"	f
Symbol_insert	tool/lemon.c	/^int Symbol_insert(data,key)$/;"	f
Symbol_new	tool/lemon.c	/^struct symbol *Symbol_new(x)$/;"	f
Symbolcmpp	tool/lemon.c	/^int Symbolcmpp(struct symbol **a, struct symbol **b){$/;"	f
Syntax	common.tcl	/^proc Syntax {args} {$/;"	p
Syntax	www/common.tcl	/^proc Syntax {args} {$/;"	p
TCLSH_MAIN	tclsqlite.c	/^int TCLSH_MAIN(int argc, char **argv){$/;"	f
TCLSH_MAIN	tclsqlite.c	1781;"	d	file:
TEMP_FILE_PREFIX	os.h	89;"	d
TEMP_MASTER_NAME	sqliteInt.h	308;"	d
TEMP_PAGES	sqliteInt.h	74;"	d
TEMP_PAGES	sqliteInt.h	76;"	d
TEMP_STORE	sqliteInt.h	145;"	d
TERMINAL	tool/lemon.c	/^    TERMINAL,$/;"	e	enum:symbol::<anonymous>	file:
TEST_INCR	pager.c	301;"	d	file:
TEST_INCR	pager.c	303;"	d	file:
TIMER_ELAPSED	os_common.h	78;"	d
TIMER_ELAPSED	os_common.h	82;"	d
TIMER_END	os_common.h	77;"	d
TIMER_END	os_common.h	81;"	d
TIMER_START	os_common.h	76;"	d
TIMER_START	os_common.h	80;"	d
TK_ABORT	parse.h	28;"	d
TK_ADD	parse.h	139;"	d
TK_AFTER	parse.h	29;"	d
TK_AGG_FUNCTION	parse.h	8;"	d
TK_ALL	parse.h	110;"	d
TK_ALTER	parse.h	61;"	d
TK_AND	parse.h	63;"	d
TK_AS	parse.h	25;"	d
TK_ASC	parse.h	30;"	d
TK_ATTACH	parse.h	31;"	d
TK_AUTOINCR	parse.h	100;"	d
TK_BEFORE	parse.h	32;"	d
TK_BEGIN	parse.h	12;"	d
TK_BETWEEN	parse.h	66;"	d
TK_BITAND	parse.h	77;"	d
TK_BITNOT	parse.h	89;"	d
TK_BITOR	parse.h	78;"	d
TK_BLOB	parse.h	129;"	d
TK_BY	parse.h	120;"	d
TK_CASCADE	parse.h	33;"	d
TK_CASE	parse.h	133;"	d
TK_CHECK	parse.h	97;"	d
TK_COLLATE	parse.h	99;"	d
TK_COLUMN	parse.h	7;"	d
TK_COLUMNKW	parse.h	140;"	d
TK_COMMA	parse.h	26;"	d
TK_COMMENT	parse.h	5;"	d
TK_COMMIT	parse.h	17;"	d
TK_CONCAT	parse.h	86;"	d
TK_CONFLICT	parse.h	34;"	d
TK_CONSTRAINT	parse.h	92;"	d
TK_CONST_FUNC	parse.h	9;"	d
TK_CREATE	parse.h	20;"	d
TK_CTIME_KW	parse.h	60;"	d
TK_DATABASE	parse.h	35;"	d
TK_DEFAULT	parse.h	93;"	d
TK_DEFERRABLE	parse.h	106;"	d
TK_DEFERRED	parse.h	14;"	d
TK_DELETE	parse.h	102;"	d
TK_DESC	parse.h	36;"	d
TK_DETACH	parse.h	37;"	d
TK_DISTINCT	parse.h	114;"	d
TK_DOT	parse.h	115;"	d
TK_DROP	parse.h	108;"	d
TK_EACH	parse.h	38;"	d
TK_ELSE	parse.h	136;"	d
TK_END	parse.h	18;"	d
TK_END_OF_FILE	parse.h	1;"	d
TK_EQ	parse.h	71;"	d
TK_ESCAPE	parse.h	76;"	d
TK_EXCEPT	parse.h	112;"	d
TK_EXCLUSIVE	parse.h	16;"	d
TK_EXISTS	parse.h	132;"	d
TK_EXPLAIN	parse.h	11;"	d
TK_FAIL	parse.h	39;"	d
TK_FLOAT	parse.h	128;"	d
TK_FOR	parse.h	40;"	d
TK_FOREIGN	parse.h	107;"	d
TK_FROM	parse.h	116;"	d
TK_FUNCTION	parse.h	6;"	d
TK_GE	parse.h	75;"	d
TK_GROUP	parse.h	121;"	d
TK_GT	parse.h	72;"	d
TK_HAVING	parse.h	122;"	d
TK_ID	parse.h	27;"	d
TK_IGNORE	parse.h	41;"	d
TK_ILLEGAL	parse.h	2;"	d
TK_IMMEDIATE	parse.h	15;"	d
TK_IN	parse.h	67;"	d
TK_INDEX	parse.h	137;"	d
TK_INITIALLY	parse.h	42;"	d
TK_INSERT	parse.h	104;"	d
TK_INSTEAD	parse.h	43;"	d
TK_INTEGER	parse.h	127;"	d
TK_INTERSECT	parse.h	111;"	d
TK_INTO	parse.h	125;"	d
TK_IS	parse.h	65;"	d
TK_ISNULL	parse.h	68;"	d
TK_JOIN	parse.h	117;"	d
TK_JOIN_KW	parse.h	91;"	d
TK_KEY	parse.h	46;"	d
TK_LE	parse.h	73;"	d
TK_LIKE_KW	parse.h	44;"	d
TK_LIMIT	parse.h	123;"	d
TK_LP	parse.h	23;"	d
TK_LSHIFT	parse.h	79;"	d
TK_LT	parse.h	74;"	d
TK_MATCH	parse.h	45;"	d
TK_MINUS	parse.h	82;"	d
TK_NE	parse.h	70;"	d
TK_NOT	parse.h	64;"	d
TK_NOTNULL	parse.h	69;"	d
TK_NULL	parse.h	94;"	d
TK_OF	parse.h	47;"	d
TK_OFFSET	parse.h	48;"	d
TK_ON	parse.h	101;"	d
TK_OR	parse.h	62;"	d
TK_ORDER	parse.h	119;"	d
TK_PLUS	parse.h	81;"	d
TK_PRAGMA	parse.h	49;"	d
TK_PRIMARY	parse.h	95;"	d
TK_RAISE	parse.h	50;"	d
TK_REFERENCES	parse.h	98;"	d
TK_REGISTER	parse.h	130;"	d
TK_REINDEX	parse.h	58;"	d
TK_REM	parse.h	85;"	d
TK_RENAME	parse.h	59;"	d
TK_REPLACE	parse.h	51;"	d
TK_RESTRICT	parse.h	52;"	d
TK_ROLLBACK	parse.h	19;"	d
TK_ROW	parse.h	53;"	d
TK_RP	parse.h	24;"	d
TK_RSHIFT	parse.h	80;"	d
TK_SELECT	parse.h	113;"	d
TK_SEMI	parse.h	10;"	d
TK_SET	parse.h	105;"	d
TK_SLASH	parse.h	84;"	d
TK_SPACE	parse.h	3;"	d
TK_STAR	parse.h	83;"	d
TK_STATEMENT	parse.h	54;"	d
TK_STRING	parse.h	90;"	d
TK_TABLE	parse.h	21;"	d
TK_TEMP	parse.h	22;"	d
TK_THEN	parse.h	135;"	d
TK_TO	parse.h	138;"	d
TK_TRANSACTION	parse.h	13;"	d
TK_TRIGGER	parse.h	55;"	d
TK_UMINUS	parse.h	87;"	d
TK_UNCLOSED_STRING	parse.h	4;"	d
TK_UNION	parse.h	109;"	d
TK_UNIQUE	parse.h	96;"	d
TK_UPDATE	parse.h	103;"	d
TK_UPLUS	parse.h	88;"	d
TK_USING	parse.h	118;"	d
TK_VACUUM	parse.h	56;"	d
TK_VALUES	parse.h	126;"	d
TK_VARIABLE	parse.h	131;"	d
TK_VIEW	parse.h	57;"	d
TK_WHEN	parse.h	134;"	d
TK_WHERE	parse.h	124;"	d
TOKEN	lempar.c	542;"	d	file:
TOKEN	parse.c	3175;"	d	file:
TOKEN	tool/lempar.c	542;"	d	file:
TRACE	btree.c	367;"	d	file:
TRACE	btree.c	370;"	d	file:
TRACE	os_common.h	40;"	d
TRACE	os_common.h	51;"	d
TRACE1	os_common.h	41;"	d
TRACE1	os_common.h	52;"	d
TRACE1	pager.c	34;"	d	file:
TRACE1	pager.c	40;"	d	file:
TRACE2	os_common.h	42;"	d
TRACE2	os_common.h	53;"	d
TRACE2	pager.c	35;"	d	file:
TRACE2	pager.c	41;"	d	file:
TRACE2	shell.c	58;"	d	file:
TRACE2	shell.c	60;"	d	file:
TRACE3	os_common.h	43;"	d
TRACE3	os_common.h	54;"	d
TRACE3	pager.c	36;"	d	file:
TRACE3	pager.c	42;"	d	file:
TRACE4	os_common.h	44;"	d
TRACE4	os_common.h	55;"	d
TRACE4	pager.c	37;"	d	file:
TRACE4	pager.c	43;"	d	file:
TRACE5	os_common.h	45;"	d
TRACE5	os_common.h	56;"	d
TRACE5	pager.c	38;"	d	file:
TRACE5	pager.c	44;"	d	file:
TRACE6	os_common.h	46;"	d
TRACE6	os_common.h	57;"	d
TRACE7	os_common.h	47;"	d
TRACE7	os_common.h	58;"	d
TRANS_NONE	btree.c	323;"	d	file:
TRANS_READ	btree.c	324;"	d	file:
TRANS_WRITE	btree.c	325;"	d	file:
TRIGGER	tool/mkkeywordhash.c	84;"	d	file:
TRIGGER	tool/mkkeywordhash.c	86;"	d	file:
TRIGGER_AFTER	sqliteInt.h	1218;"	d
TRIGGER_BEFORE	sqliteInt.h	1217;"	d
TRUE	sqliteInt.h	218;"	d
TabResult	table.c	/^typedef struct TabResult {$/;"	s	file:
TabResult	table.c	/^} TabResult;$/;"	t	file:
Table	sqliteInt.h	/^struct Table {$/;"	s
Table	sqliteInt.h	/^typedef struct Table Table;$/;"	t
Tcl_InitStubs	tclsqlite.c	1704;"	d	file:
Tcl_InitStubs	tclsqlite.c	1705;"	d	file:
Tclsqlite3_Init	tclsqlite.c	/^int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite3_SafeInit	tclsqlite.c	/^int Tclsqlite3_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Tclsqlite_Init	tclsqlite.c	/^int Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite_SafeInit	tclsqlite.c	/^int Tclsqlite_SafeInit(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Token	sqliteInt.h	/^struct Token {$/;"	s
Token	sqliteInt.h	/^typedef struct Token Token;$/;"	t
TrigEvent	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	s	file:
Trigger	sqliteInt.h	/^struct Trigger {$/;"	s
Trigger	sqliteInt.h	/^typedef struct Trigger Trigger;$/;"	t
TriggerStack	sqliteInt.h	/^struct TriggerStack {$/;"	s
TriggerStack	sqliteInt.h	/^typedef struct TriggerStack TriggerStack;$/;"	t
TriggerStep	sqliteInt.h	/^struct TriggerStep {$/;"	s
TriggerStep	sqliteInt.h	/^typedef struct TriggerStep TriggerStep;$/;"	t
UINT16_TYPE	sqliteInt.h	173;"	d
UINT32_TYPE	sqliteInt.h	170;"	d
UINT64_TYPE	sqliteInt.h	164;"	d
UINT64_TYPE	sqliteInt.h	166;"	d
UINT8_TYPE	sqliteInt.h	179;"	d
UNK	tool/lemon.c	/^    UNK$/;"	e	enum:symbol::e_assoc	file:
UTF_TRANSLATION_NEEDED	tclsqlite.c	35;"	d	file:
UpperToLower	tool/mkkeywordhash.c	240;"	d	file:
UpperToLower	util.c	550;"	d	file:
VACUUM	tool/mkkeywordhash.c	89;"	d	file:
VACUUM	tool/mkkeywordhash.c	91;"	d	file:
VDBE_MAGIC_DEAD	vdbeInt.h	357;"	d
VDBE_MAGIC_HALT	vdbeInt.h	356;"	d
VDBE_MAGIC_INIT	vdbeInt.h	354;"	d
VDBE_MAGIC_RUN	vdbeInt.h	355;"	d
VIEW	tool/mkkeywordhash.c	94;"	d	file:
VIEW	tool/mkkeywordhash.c	96;"	d	file:
Vdbe	vdbe.h	/^typedef struct Vdbe Vdbe;$/;"	t
Vdbe	vdbeInt.h	/^struct Vdbe {$/;"	s
VdbeComment	vdbe.h	127;"	d
VdbeComment	vdbe.h	129;"	d
VdbeFunc	vdbeInt.h	/^struct VdbeFunc {$/;"	s
VdbeFunc	vdbeInt.h	/^typedef struct VdbeFunc VdbeFunc;$/;"	t
VdbeOp	vdbe.h	/^struct VdbeOp {$/;"	s
VdbeOp	vdbe.h	/^typedef struct VdbeOp VdbeOp;$/;"	t
VdbeOpList	vdbe.h	/^struct VdbeOpList {$/;"	s
VdbeOpList	vdbe.h	/^typedef struct VdbeOpList VdbeOpList;$/;"	t
WAITING_FOR_ARROW	tool/lemon.c	/^    WAITING_FOR_ARROW,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DATATYPE_SYMBOL	tool/lemon.c	/^    WAITING_FOR_DATATYPE_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_ARG	tool/lemon.c	/^    WAITING_FOR_DECL_ARG,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_KEYWORD	tool/lemon.c	/^    WAITING_FOR_DECL_KEYWORD,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DECL_OR_RULE	tool/lemon.c	/^    WAITING_FOR_DECL_OR_RULE,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_DESTRUCTOR_SYMBOL	tool/lemon.c	/^    WAITING_FOR_DESTRUCTOR_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_FALLBACK_ID	tool/lemon.c	/^    WAITING_FOR_FALLBACK_ID$/;"	e	enum:pstate::e_state	file:
WAITING_FOR_PRECEDENCE_SYMBOL	tool/lemon.c	/^    WAITING_FOR_PRECEDENCE_SYMBOL,$/;"	e	enum:pstate::e_state	file:
WRITE_UTF16BE	utf.c	165;"	d	file:
WRITE_UTF16LE	utf.c	153;"	d	file:
WRITE_UTF8	utf.c	133;"	d	file:
WhereInfo	sqliteInt.h	/^struct WhereInfo {$/;"	s
WhereInfo	sqliteInt.h	/^typedef struct WhereInfo WhereInfo;$/;"	t
WhereLevel	sqliteInt.h	/^struct WhereLevel {$/;"	s
WhereLevel	sqliteInt.h	/^typedef struct WhereLevel WhereLevel;$/;"	t
Y	date.c	/^  int Y, M, D;     \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
YYACTIONTYPE	parse.c	97;"	d	file:
YYCODETYPE	parse.c	95;"	d	file:
YYERRORSYMBOL	parse.c	123;"	d	file:
YYERRSYMDT	parse.c	124;"	d	file:
YYFALLBACK	parse.c	125;"	d	file:
YYMINORTYPE	parse.c	/^} YYMINORTYPE;$/;"	t	file:
YYNOCODE	parse.c	96;"	d	file:
YYNRULE	parse.c	122;"	d	file:
YYNSTATE	parse.c	121;"	d	file:
YYSTACKDEPTH	parse.c	116;"	d	file:
YY_ACCEPT_ACTION	lempar.c	59;"	d	file:
YY_ACCEPT_ACTION	parse.c	127;"	d	file:
YY_ACCEPT_ACTION	tool/lempar.c	59;"	d	file:
YY_ERROR_ACTION	lempar.c	60;"	d	file:
YY_ERROR_ACTION	parse.c	128;"	d	file:
YY_ERROR_ACTION	tool/lempar.c	60;"	d	file:
YY_NO_ACTION	lempar.c	58;"	d	file:
YY_NO_ACTION	parse.c	126;"	d	file:
YY_NO_ACTION	tool/lempar.c	58;"	d	file:
YY_REDUCE_USE_DFLT	parse.c	521;"	d	file:
YY_SHIFT_USE_DFLT	parse.c	461;"	d	file:
YY_SZ_ACTTAB	lempar.c	110;"	d	file:
YY_SZ_ACTTAB	parse.c	640;"	d	file:
YY_SZ_ACTTAB	tool/lempar.c	110;"	d	file:
_BTREE_H_	btree.h	19;"	d
_FILE_OFFSET_BITS	os_aros.h	41;"	d
_FILE_OFFSET_BITS	sqliteInt.h	42;"	d
_LARGEFILE_SOURCE	os_aros.h	43;"	d
_LARGEFILE_SOURCE	sqliteInt.h	44;"	d
_LARGE_FILE	os_aros.h	39;"	d
_LARGE_FILE	sqliteInt.h	40;"	d
_OvflCell	btree.c	/^  struct _OvflCell {   \/* Cells that will not fit on aData[] *\/$/;"	s	struct:MemPage	file:
_SQLITE3_H_	sqlite3.h	18;"	d
_SQLITEINT_H_	sqliteInt.h	23;"	d
_SQLITE_HASH_H_	hash.h	18;"	d
_SQLITE_OS_AROS_H_	os_aros.h	16;"	d
_SQLITE_OS_H_	os.h	18;"	d
_SQLITE_OS_TEST_H_	os_test.h	15;"	d
_SQLITE_VDBE_H_	vdbe.h	21;"	d
__WIN32__	tool/lemon.c	17;"	d	file:
__arossql__NULL	os_aros.c	/^const char const *__arossql__NULL = NULL;$/;"	v
_all_whitespace	shell.c	/^static BOOL _all_whitespace(CONST_STRPTR z)$/;"	f	file:
_ends_with_semicolon	shell.c	/^static int _ends_with_semicolon(CONST_STRPTR z, int N)$/;"	f	file:
_ht	hash.h	/^  struct _ht {            \/* the hash table *\/$/;"	s	struct:Hash
_is_command_terminator	shell.c	/^static BOOL _is_command_terminator(const char *zLine)$/;"	f	file:
_pageIntegrity	btree.c	/^static void _pageIntegrity(MemPage *pPage){$/;"	f	file:
_page_ref	pager.c	/^static void _page_ref(PgHdr *pPg){$/;"	f	file:
_storeTypeInfo	vdbe.c	/^static void _storeTypeInfo(Mem *pMem){$/;"	f	file:
a	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	m	struct:TrigEvent	file:
a	sqliteInt.h	/^  WhereLevel a[1];     \/* Information about each nest loop in the WHERE *\/$/;"	m	struct:WhereInfo
a	sqliteInt.h	/^  } *a;                  \/* One entry for each expression *\/$/;"	m	struct:ExprList
a	sqliteInt.h	/^  } *a;$/;"	m	struct:IdList
a	sqliteInt.h	/^  } a[1];             \/* One entry for each identifier on the list *\/$/;"	m	struct:SrcList
aAction	tool/lemon.c	/^  } *aAction,                  \/* The yy_action[] table under construction *\/$/;"	m	struct:acttab	file:
aAgg	select.c	/^  AggExpr *aAgg;$/;"	m	struct:AggregateInfo	file:
aAgg	sqliteInt.h	/^  AggExpr *aAgg;       \/* An array of aggregate expressions *\/$/;"	m	struct:Parse
aCol	sqliteInt.h	/^  Column *aCol;    \/* Information about each column *\/$/;"	m	struct:Table
aCol	sqliteInt.h	/^  } *aCol;          \/* One entry for each of nCol column s *\/$/;"	m	struct:FKey
aColName	vdbeInt.h	/^  Mem *aColName;      \/* Column names to return *\/$/;"	m	struct:Vdbe
aColl	sqliteInt.h	/^  CollSeq *aColl[1];  \/* Collating sequence for each term of the key *\/$/;"	m	struct:KeyInfo
aCollSeq	sqliteInt.h	/^  Hash aCollSeq;                \/* All collating sequences *\/$/;"	m	struct:sqlite3
aData	btree.c	/^  u8 *aData;           \/* Pointer back to the start of the page *\/$/;"	m	struct:MemPage	file:
aDb	sqliteInt.h	/^  Db *aDb;                      \/* All backends *\/$/;"	m	struct:sqlite3
aDbStatic	sqliteInt.h	/^  Db aDbStatic[2];              \/* Static space for the 2 default backends *\/$/;"	m	struct:sqlite3
aDigits	printf.c	/^static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";$/;"	v	file:
aFKey	sqliteInt.h	/^	Hash aFKey;          \/* Foreign keys indexed by to-table *\/$/;"	m	struct:Db
aFunc	sqliteInt.h	/^  Hash aFunc;                   \/* All functions that can be in SQL exprs *\/$/;"	m	struct:sqlite3
aHash	pager.c	/^  PgHdr *aHash[N_PG_HASH];    \/* Hash table to map page number to PgHdr *\/$/;"	m	struct:Pager	file:
aInJournal	pager.c	/^  u8 *aInJournal;             \/* One bit for each page in the database file *\/$/;"	m	struct:Pager	file:
aInStmt	pager.c	/^  u8 *aInStmt;                \/* One bit for each page in the database *\/$/;"	m	struct:Pager	file:
aJournalMagic	pager.c	/^static const unsigned char aJournalMagic[] = {$/;"	v	file:
aKey	vdbeInt.h	/^  i64 aKey[1];      \/* One or more keys.  Extra space allocated as needed *\/$/;"	m	struct:Keylist
aKeywordTable	tool/mkkeywordhash.c	/^static Keyword aKeywordTable[] = {$/;"	v	file:
aLabel	vdbeInt.h	/^  int *aLabel;        \/* Space to hold the labels *\/$/;"	m	struct:Vdbe
aLookahead	tool/lemon.c	/^    *aLookahead;               \/* A single new transaction set *\/$/;"	m	struct:acttab	file:
aMem	vdbeInt.h	/^  Mem *aMem;              \/* The memory locations *\/$/;"	m	struct:Vdbe
aMem	vdbeInt.h	/^  Mem aMem[1];         \/* The values for this AggElem *\/$/;"	m	struct:AggElem
aOffset	vdbeInt.h	/^  u32 *aOffset;         \/* Cached offsets to the start of each columns data *\/$/;"	m	struct:Cursor
aOp	vdbeInt.h	/^  Op *aOp;            \/* Space to hold the virtual machine's program *\/$/;"	m	struct:Vdbe
aOvfl	btree.c	/^  } aOvfl[5];$/;"	m	struct:MemPage	file:
aPending	os_aros.c	/^	int *aPending;        \/* Malloced space holding fd's awaiting a close() *\/$/;"	m	struct:openCnt	file:
aPrefix	printf.c	/^static const char aPrefix[] = "-x0\\000X0";$/;"	v	file:
aRow	vdbeInt.h	/^  u8 *aRow;             \/* Data for the current row, if all on one page *\/$/;"	m	struct:Cursor
aSortOrder	sqliteInt.h	/^  u8 *aSortOrder;     \/* If defined an aSortOrder[i] is true, sort DESC *\/$/;"	m	struct:KeyInfo
aStack	vdbeInt.h	/^  Mem *aStack;        \/* The operand stack, except string values *\/$/;"	m	struct:Vdbe
aType	vdbeInt.h	/^  u32 *aType;           \/* Type values for all entries in the record *\/$/;"	m	struct:Cursor
aVar	vdbeInt.h	/^  Mem *aVar;          \/* Values for the OP_Variable opcode. *\/$/;"	m	struct:Vdbe
abortOtherActiveVdbes	vdbeaux.c	/^static void abortOtherActiveVdbes(Vdbe *pVdbe){$/;"	f	file:
aborted	vdbeInt.h	/^  u8 aborted;             \/* True if ROLLBACK in another VM causes an abort *\/$/;"	m	struct:Vdbe
absFunc	func.c	/^static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
accept	tool/lemon.c	/^  char *accept;            \/* Code to execute when the parser excepts *\/$/;"	m	struct:lemon	file:
acceptln	tool/lemon.c	/^  int  acceptln;           \/* Line number for the start of accept code *\/$/;"	m	struct:lemon	file:
action	tool/lemon.c	/^    int action;                \/* Action to take on the given lookahead *\/$/;"	m	struct:acttab::<anonymous>	file:
action	tool/lemon.c	/^struct action {$/;"	s	file:
actioncmp	tool/lemon.c	/^static int actioncmp(ap1,ap2)$/;"	f	file:
activeVdbeCnt	sqliteInt.h	/^  int activeVdbeCnt;            \/* Number of vdbes currently executing *\/$/;"	m	struct:sqlite3
acttab	tool/lemon.c	/^struct acttab {$/;"	s	file:
acttab	tool/lemon.c	/^typedef struct acttab acttab;$/;"	t	file:
acttab_action	tool/lemon.c	/^void acttab_action(acttab *p, int lookahead, int action){$/;"	f
acttab_alloc	tool/lemon.c	/^acttab *acttab_alloc(void){$/;"	f
acttab_free	tool/lemon.c	/^void acttab_free(acttab *p){$/;"	f
acttab_insert	tool/lemon.c	/^int acttab_insert(acttab *p){$/;"	f
acttab_size	tool/lemon.c	417;"	d	file:
acttab_yyaction	tool/lemon.c	420;"	d	file:
acttab_yylookahead	tool/lemon.c	423;"	d	file:
actualWidth	shell.c	/^	int actualWidth[100];\/* Actual width of each column *\/$/;"	m	struct:callback_data	file:
addColOffset	sqliteInt.h	/^  int addColOffset;  \/* Offset in CREATE TABLE statement to add a new column *\/$/;"	m	struct:Table
addWhereTerm	select.c	/^static void addWhereTerm($/;"	f	file:
add_column_fullname	parse.y	/^add_column_fullname ::= fullname(X). {$/;"	l
add_history	shell.c	51;"	d	file:
affinity	sqliteInt.h	/^  char affinity;         \/* The affinity of the column or 0 if not a column *\/$/;"	m	struct:Expr
affinity	sqliteInt.h	/^  char affinity;   \/* One of the SQLITE_AFF_... values *\/$/;"	m	struct:Column
aiColumn	sqliteInt.h	/^  int *aiColumn;   \/* Which columns are used by this index.  1st is 0 *\/$/;"	m	struct:Index
alias	tool/lemon.c	/^  char *alias[MAXRHS];       \/* Aliases for each RHS symbol (or NULL) *\/$/;"	m	struct:pstate	file:
all_stop	test/threadtest2.c	/^volatile int all_stop = 0;$/;"	v
allocateCursor	vdbe.c	/^static Cursor *allocateCursor(Vdbe *p, int iCur){$/;"	f	file:
allocatePage	btree.c	/^static int allocatePage($/;"	f	file:
allocateSpace	btree.c	/^static int allocateSpace(MemPage *pPage, int nByte){$/;"	f	file:
allowAgg	sqliteInt.h	/^  u8 allowAgg;         \/* Aggregate functions allowed here *\/$/;"	m	struct:NameContext
allowedOp	where.c	/^static int allowedOp(int op){$/;"	f	file:
alwaysRollback	pager.c	/^  u8 alwaysRollback;             \/* Disable dont_rollback() for this page *\/$/;"	m	struct:PgHdr	file:
alwaysRollback	pager.c	/^  u8 alwaysRollback;          \/* Disable dont_rollback() for all pages *\/$/;"	m	struct:Pager	file:
anRef	btree.c	/^	int *anRef;    \/* Number of times each page is referenced *\/$/;"	m	struct:IntegrityCk	file:
analyzeAggregate	expr.c	/^static int analyzeAggregate(void *pArg, Expr *pExpr){$/;"	f	file:
and	www/lang.tcl	/^processing and the result is reused as necessary.  If the SELECT expression$/;"	p
ap	tool/lemon.c	/^  struct action *ap;       \/* Array of actions for this state *\/$/;"	m	struct:state	file:
apAgg	vdbeInt.h	/^  Agg *apAgg;             \/* Array of aggregate contexts *\/$/;"	m	struct:Vdbe
apArg	vdbeInt.h	/^  Mem **apArg;        \/* Arguments to currently executing user function *\/$/;"	m	struct:Vdbe
apAux	vdbeInt.h	/^  } apAux[1];                   \/* One slot for each function argument *\/$/;"	m	struct:VdbeFunc
apBlk	os_test.h	/^  u8 **apBlk;       \/* Array of blocks that have been written to. *\/$/;"	m	struct:OsTestFile
apCsr	vdbeInt.h	/^  Cursor **apCsr;     \/* One element of this array for each open cursor *\/$/;"	m	struct:Vdbe
apFunc	vdbeInt.h	/^  FuncDef **apFunc;    \/* Information about aggregate functions *\/$/;"	m	struct:Agg
apVarExpr	sqliteInt.h	/^  Expr **apVarExpr;    \/* Pointers to :aaa and $aaaa wildcard expressions *\/$/;"	m	struct:Parse
api	www/capi3ref.tcl	/^proc api {name prototype desc {notused x}} {$/;"	p
appendAggInfo	expr.c	/^static int appendAggInfo(Parse *pParse){$/;"	f	file:
appendText	shell.c	/^static STRPTR appendText(STRPTR zIn, CONST_STRPTR zAppend, char quote)$/;"	f	file:
append_str	tool/lemon.c	/^PRIVATE char *append_str(char *zText, int n, int p1, int p2){$/;"	f
applyAffinity	vdbe.c	/^static void applyAffinity(Mem *pRec, char affinity, u8 enc){$/;"	f	file:
are	www/lockingv3.tcl	/^processes are able to access the database from the$/;"	p
are	www/whentouse.tcl	/^processes are prevented from writing any other part of the database.$/;"	p
arg	tool/lemon.c	/^  char *arg;               \/* Declaration of the 3th argument to parser *\/$/;"	m	struct:lemon	file:
arg	tool/lemon.c	/^  char *arg;$/;"	m	struct:s_options	file:
argindex	tool/lemon.c	/^static int argindex(n)$/;"	f	file:
argv	tool/lemon.c	/^static char **argv;$/;"	v	file:
argv0	tool/lemon.c	/^  char *argv0;             \/* Name of the program *\/$/;"	m	struct:lemon	file:
arosErrLoc	os_aros.c	/^const char *arosErrLoc = NULL;$/;"	v
assemblePage	btree.c	/^static void assemblePage($/;"	f	file:
assert	tool/lemon.c	40;"	d	file:
assert	tool/lemon.c	42;"	d	file:
assoc	tool/lemon.c	/^  } assoc;                 \/* Associativity if predecence is defined *\/$/;"	m	struct:symbol	file:
atFirst	vdbeInt.h	/^  Bool atFirst;         \/* True if pointing to first entry *\/$/;"	m	struct:Cursor
auth_callback	tclsqlite.c	/^static int auth_callback($/;"	f	file:
autoCommit	sqliteInt.h	/^  u8 autoCommit;                \/* The auto-commit flag. *\/$/;"	m	struct:sqlite3
autoInc	sqliteInt.h	/^  u8 autoInc;      \/* True if the integer primary key is autoincrement *\/$/;"	m	struct:Table
autoIndex	sqliteInt.h	/^  u8 autoIndex;    \/* True if is automatically created (ex: by UNIQUE) *\/$/;"	m	struct:Index
autoVacuum	btree.c	/^  u8 autoVacuum;        \/* True if database supports auto-vacuum *\/$/;"	m	struct:Btree	file:
autoVacuumCommit	btree.c	/^static int autoVacuumCommit(Btree *pBt, Pgno *nTrunc){$/;"	f	file:
autovacuum_overhead	tool/spaceanal.tcl	/^proc autovacuum_overhead {filePages pageSize} {$/;"	p
avgFinalize	func.c	/^static void avgFinalize(sqlite3_context *context){$/;"	f	file:
axset	tool/lemon.c	/^struct axset {$/;"	s	file:
axset_compare	tool/lemon.c	/^static int axset_compare(const void *a, const void *b){$/;"	f	file:
azDefine	tool/lemon.c	/^static char **azDefine = 0;  \/* Name of the -D macros *\/$/;"	v	file:
azElem	test/threadtest1.c	/^  char **azElem;      \/* The result of the query *\/$/;"	m	struct:QueryResult	file:
azResColumn	vdbeInt.h	/^  char **azResColumn;     \/* Values for one row of result *\/ $/;"	m	struct:Vdbe
azResult	table.c	/^  char **azResult;$/;"	m	struct:TabResult	file:
azVar	vdbeInt.h	/^  char **azVar;       \/* Name of variables *\/$/;"	m	struct:Vdbe
b	parse.c	/^struct TrigEvent { int a; IdList * b; };$/;"	m	struct:TrigEvent	file:
bRev	sqliteInt.h	/^  int bRev;            \/* Do the scan in the reverse direction *\/$/;"	m	struct:WhereLevel
balance	btree.c	/^static int balance(MemPage *pPage, int insert){$/;"	f	file:
balance_deeper	btree.c	/^static int balance_deeper(MemPage *pPage){$/;"	f	file:
balance_nonroot	btree.c	/^static int balance_nonroot(MemPage *pPage){$/;"	f	file:
balance_quick	btree.c	/^static int balance_quick(MemPage *pPage, MemPage *pParent){$/;"	f	file:
balance_shallower	btree.c	/^static int balance_shallower(MemPage *pPage){$/;"	f	file:
base	printf.c	/^	etByte base;           \/* The base for radix conversion *\/$/;"	m	struct:et_info	file:
base_vprintf	printf.c	/^static char *base_vprintf($/;"	f	file:
basis	tool/lemon.c	/^static struct config *basis = 0;         \/* Top of list of basis configs *\/$/;"	v	file:
basisend	tool/lemon.c	/^static struct config **basisend = 0;     \/* End of list of basis configs *\/$/;"	v	file:
basisflag	tool/lemon.c	/^  int basisflag;           \/* Print only basis configurations *\/$/;"	m	struct:lemon	file:
because	www/capi3ref.tcl	/^ proceed because it is blocked by the first.  If both processes$/;"	p
binCollFunc	main.c	/^static int binCollFunc($/;"	f	file:
binCompare	hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binHash	hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binaryCompareCollSeq	expr.c	/^static CollSeq* binaryCompareCollSeq(Parse *pParse, Expr *pLeft, Expr *pRight){$/;"	f	file:
binaryCompareP1	expr.c	/^static int binaryCompareP1(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){$/;"	f	file:
bindText	vdbeapi.c	/^static int bindText($/;"	f	file:
bits	md5.c	/^	uint32 bits[2];$/;"	m	struct:Context	file:
bogusIncrKey	vdbeInt.h	/^  u8 bogusIncrKey;      \/* Something for pIncrKey to point to if pKeyInfo==0 *\/$/;"	m	struct:Cursor
bp	tool/lemon.c	/^  struct config *bp;       \/* The basis configurations for this state *\/$/;"	m	struct:state	file:
bp	tool/lemon.c	/^  struct config *bp;       \/* The next basis configuration *\/$/;"	m	struct:config	file:
bplp	tool/lemon.c	/^  struct plink *bplp;      \/* Follow-set backwards propagation links *\/$/;"	m	struct:config	file:
brk	sqliteInt.h	/^  int brk;             \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereLevel
btreePageDump	btree.c	/^static int btreePageDump(Btree *pBt, int pgno, int recursive, MemPage *pParent){$/;"	f	file:
buf	md5.c	/^	uint32 buf[4];$/;"	m	struct:Context	file:
buildIndexProbe	where.c	/^static void buildIndexProbe(Vdbe *v, int nColumn, int brk, Index *pIdx){$/;"	f	file:
buildshifts	tool/lemon.c	/^PRIVATE void buildshifts(lemp,stp)$/;"	f
busy	sqliteInt.h	/^    u8 busy;                    \/* TRUE if currently initializing *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
busyHandler	sqliteInt.h	/^  BusyHandler busyHandler;      \/* Busy callback *\/$/;"	m	struct:sqlite3
busyTimeout	sqliteInt.h	/^  int busyTimeout;             \/* Busy handler timeout, in msec *\/$/;"	m	struct:sqlite3
byteReverse	md5.c	/^static void byteReverse (unsigned char *buf, unsigned longs)$/;"	f	file:
cacheBlock	os_test.c	/^static int cacheBlock(OsTestFile *pFile, int blk){$/;"	f	file:
cacheValid	vdbeInt.h	/^  Bool cacheValid;      \/* True if the cache is valid *\/$/;"	m	struct:Cursor
cache_size	sqliteInt.h	/^	int cache_size;      \/* Number of pages to use in the cache *\/$/;"	m	struct:Db
callCollNeeded	callback.c	/^static void callCollNeeded(sqlite3 *db, const char *zName, int nName){$/;"	f	file:
callback	shell.c	/^static int callback(void *pArg, int nArg, char **azArg, char **azCol)$/;"	f	file:
callback_data	shell.c	/^struct callback_data {$/;"	s	file:
can	www/lockingv3.tcl	/^processes can begin reading the database again.  In the current implementation,$/;"	p
can	www/lockingv3.tcl	/^processes can continue to read the database.<\/p>$/;"	p
can	www/lockingv3.tcl	/^processes can hold SHARED locks at the same time, hence there can be$/;"	p
can	www/lockingv3.tcl	/^processes can read or write the database as their own locking states$/;"	p
canReduce	tool/lemon.c	/^  Boolean canReduce;       \/* True if this rule is ever reduced *\/$/;"	m	struct:rule	file:
carg	parse.y	/^carg ::= CONSTRAINT nm ccons.$/;"	l
carg	parse.y	/^carg ::= DEFAULT MINUS term(X).      {$/;"	l
carg	parse.y	/^carg ::= DEFAULT PLUS term(X).       {sqlite3AddDefaultValue(pParse,X);}$/;"	l
carg	parse.y	/^carg ::= DEFAULT id(X).              {$/;"	l
carg	parse.y	/^carg ::= DEFAULT term(X).            {sqlite3AddDefaultValue(pParse,X);}$/;"	l
carg	parse.y	/^carg ::= ccons.$/;"	l
carglist	parse.y	/^carglist ::= .$/;"	l
carglist	parse.y	/^carglist ::= carglist carg.$/;"	l
catchsql	test/tester.tcl	/^proc catchsql {sql {db db}} {$/;"	p
ccons	parse.y	/^ccons ::= CHECK LP expr(X) RP onconf. {sqlite3ExprDelete(X);}$/;"	l
ccons	parse.y	/^ccons ::= COLLATE id(C).  {sqlite3AddCollateType(pParse, C.z, C.n);}$/;"	l
ccons	parse.y	/^ccons ::= NOT NULL onconf(R).               {sqlite3AddNotNull(pParse, R);}$/;"	l
ccons	parse.y	/^ccons ::= NULL onconf.$/;"	l
ccons	parse.y	/^ccons ::= PRIMARY KEY sortorder onconf(R) autoinc(I).$/;"	l
ccons	parse.y	/^ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).$/;"	l
ccons	parse.y	/^ccons ::= UNIQUE onconf(R).          {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0);}$/;"	l
ccons	parse.y	/^ccons ::= defer_subclause(D).   {sqlite3DeferForeignKey(pParse,D);}$/;"	l
cdateFunc	date.c	/^static void cdateFunc($/;"	f	file:
cellOffset	btree.c	/^  u16 cellOffset;      \/* Index in aData of first cell pointer *\/$/;"	m	struct:MemPage	file:
cellSize	btree.c	/^static int cellSize(MemPage *pPage, int iCell){$/;"	f	file:
cellSizePtr	btree.c	/^static int cellSizePtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
cfp	tool/lemon.c	/^  struct config *cfp;      \/* All configurations in this set *\/$/;"	m	struct:state	file:
cfp	tool/lemon.c	/^  struct config *cfp;      \/* The configuration to which linked *\/$/;"	m	struct:plink	file:
chain	hash.h	/^    HashElem *chain;         \/* Pointer to first entry with this hash *\/$/;"	m	struct:Hash::_ht
changeCntOn	vdbeInt.h	/^  u8 changeCntOn;         \/* True to update the change-counter *\/$/;"	m	struct:Vdbe
changeTempStorage	pragma.c	/^static int changeTempStorage(Parse *pParse, const char *zStorageType){$/;"	f	file:
changes	func.c	/^static void changes($/;"	f	file:
changes	www/c_interface.tcl	/^process changes the schema, the command currently being processed will$/;"	p
charset	printf.c	/^	etByte charset;        \/* Offset into aDigits[] of the digits string *\/$/;"	m	struct:et_info	file:
checkActiveVdbeCnt	vdbeaux.c	/^static void checkActiveVdbeCnt(sqlite3 *db){$/;"	f	file:
checkActiveVdbeCnt	vdbeaux.c	1308;"	d	file:
checkAppendMsg	btree.c	/^static void checkAppendMsg($/;"	f	file:
checkColumnOverLap	trigger.c	/^static int checkColumnOverLap(IdList *pIdList, ExprList *pEList){$/;"	f	file:
checkList	btree.c	/^static void checkList($/;"	f	file:
checkPage	pager.c	/^static void checkPage(PgHdr *pPg){$/;"	f	file:
checkPtrmap	btree.c	/^static void checkPtrmap($/;"	f	file:
checkReadLocks	btree.c	/^static int checkReadLocks(Btree *pBt, Pgno pgnoRoot, BtCursor *pExclude){$/;"	f	file:
checkRef	btree.c	/^static int checkRef(IntegrityCk *pCheck, int iPage, char *zContext){$/;"	f	file:
checkSchema	sqliteInt.h	/^  u8 checkSchema;      \/* Causes schema cookie check after an error *\/$/;"	m	struct:Parse
checkTreePage	btree.c	/^static int checkTreePage($/;"	f	file:
check_callback	test/threadtest2.c	/^int check_callback(void *notUsed, int argc, char **argv, char **notUsed2){$/;"	f
childPtrSize	btree.c	/^  u8 childPtrSize;     \/* 0 if leaf==1.  4 if leaf==0 *\/$/;"	m	struct:MemPage	file:
chng	www/changes.tcl	/^proc chng {date desc} {$/;"	p
cksum	test/tester.tcl	/^proc cksum {{db db}} {$/;"	p
cksumInit	pager.c	/^  u32 cksumInit;              \/* Quasi-random value added to every checksum *\/$/;"	m	struct:Pager	file:
clearCell	btree.c	/^static int clearCell(MemPage *pPage, unsigned char *pCell){$/;"	f	file:
clearDatabasePage	btree.c	/^static int clearDatabasePage($/;"	f	file:
clearHistory	pager.c	/^static void clearHistory(PgHistory *pHist){$/;"	f	file:
clearHistory	pager.c	3025;"	d	file:
clearYMD_HMS_TZ	date.c	/^static void clearYMD_HMS_TZ(DateTime *p){$/;"	f	file:
closeAllCursors	vdbeaux.c	/^static void closeAllCursors(Vdbe *p){$/;"	f	file:
closeFile	os_test.c	/^static void closeFile(OsFile *id){$/;"	f	file:
cmd	parse.y	/^cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(Y). {$/;"	l
cmd	parse.y	/^cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {$/;"	l
cmd	parse.y	/^cmd ::= ATTACH database_kw_opt ids(F) AS nm(D) key_opt(K). {$/;"	l
cmd	parse.y	/^cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}$/;"	l
cmd	parse.y	/^cmd ::= COMMIT trans_opt.      {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= CREATE trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {$/;"	l
cmd	parse.y	/^cmd ::= CREATE(S) uniqueflag(U) INDEX nm(X) dbnm(D)$/;"	l
cmd	parse.y	/^cmd ::= CREATE(X) temp(T) VIEW nm(Y) dbnm(Z) AS select(S). {$/;"	l
cmd	parse.y	/^cmd ::= DELETE FROM fullname(X) where_opt(Y). {sqlite3DeleteFrom(pParse,X,Y);}$/;"	l
cmd	parse.y	/^cmd ::= DETACH database_kw_opt nm(D). {$/;"	l
cmd	parse.y	/^cmd ::= DROP INDEX fullname(X).   {sqlite3DropIndex(pParse, X);}$/;"	l
cmd	parse.y	/^cmd ::= DROP TABLE fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP TRIGGER fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= DROP VIEW fullname(X). {$/;"	l
cmd	parse.y	/^cmd ::= END trans_opt.         {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ ON(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). {$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ nm(Y).  {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ plus_num(Y). {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP nm(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z).             {sqlite3Pragma(pParse,&X,&Z,0,0);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}$/;"	l
cmd	parse.y	/^cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}$/;"	l
cmd	parse.y	/^cmd ::= ROLLBACK trans_opt.    {sqlite3RollbackTransaction(pParse);}$/;"	l
cmd	parse.y	/^cmd ::= UPDATE orconf(R) fullname(X) SET setlist(Y) where_opt(Z).$/;"	l
cmd	parse.y	/^cmd ::= VACUUM nm.             {sqlite3Vacuum(pParse,0);}$/;"	l
cmd	parse.y	/^cmd ::= VACUUM.                {sqlite3Vacuum(pParse,0);}$/;"	l
cmd	parse.y	/^cmd ::= create_table create_table_args.$/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) $/;"	l
cmd	parse.y	/^cmd ::= insert_cmd(R) INTO fullname(X) inscollist_opt(F) select(S).$/;"	l
cmd	parse.y	/^cmd ::= select(X).  {$/;"	l
cmdlist	parse.y	/^cmdlist ::= cmdlist ecmd.$/;"	l
cmdlist	parse.y	/^cmdlist ::= ecmd.$/;"	l
cmdx	parse.y	/^cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }$/;"	l
cnt	func.c	/^  int cnt;        \/* Number of elements summed *\/$/;"	m	struct:SumCtx	file:
cnt	func.c	/^  int cnt;        \/* Number of terms counted *\/$/;"	m	struct:StdDevCtx	file:
cnt	os_aros.c	/^	int cnt;             \/* Number of SHARED locks held *\/$/;"	m	struct:lockInfo	file:
cnt	shell.c	/^	int cnt;			\/* Number of records displayed so far *\/$/;"	m	struct:callback_data	file:
cnt	vdbe.h	/^  int cnt;            \/* Number of times this instruction was executed *\/$/;"	m	struct:VdbeOp
cnt	vdbeInt.h	/^  int cnt;          \/* Number of times that the step function has been called *\/$/;"	m	struct:sqlite3_context
code	tool/lemon.c	/^  char *code;              \/* The code executed when this rule is reduced *\/$/;"	m	struct:rule	file:
codeCompare	expr.c	/^static int codeCompare($/;"	f	file:
codeEqualityTerm	where.c	/^static void codeEqualityTerm($/;"	f	file:
codeInteger	expr.c	/^static void codeInteger(Vdbe *v, const char *z, int n){$/;"	f	file:
codeLimiter	select.c	/^static void codeLimiter($/;"	f	file:
codeTriggerProgram	trigger.c	/^static int codeTriggerProgram($/;"	f	file:
colNamesSet	sqliteInt.h	/^  u8 colNamesSet;      \/* TRUE after OP_ColumnName has been issued to pVdbe *\/$/;"	m	struct:Parse
colUsed	sqliteInt.h	/^    Bitmask colUsed;  \/* Bit N (1<<N) set if column N or pTab is used *\/$/;"	m	struct:SrcList::SrcList_item
colWidth	shell.c	/^	int colWidth[100];	\/* Requested width of each column when in column mode*\/$/;"	m	struct:callback_data	file:
colWidth	shell.c	/^	int colWidth[100];$/;"	m	struct:previous_mode_data	file:
collationMatch	build.c	/^static int collationMatch(CollSeq *pColl, Index *pIndex){$/;"	f	file:
collide	tool/lemon.c	/^  struct action *collide;  \/* Next action with the same hash *\/$/;"	m	struct:action	file:
columnIndex	select.c	/^static int columnIndex(Table *pTab, const char *zCol){$/;"	f	file:
columnMem	vdbeapi.c	/^static Mem *columnMem(sqlite3_stmt *pStmt, int i){$/;"	f	file:
columnName	vdbeapi.c	/^static const void *columnName($/;"	f	file:
columnType	select.c	/^static const char *columnType(NameContext *pNC, Expr *pExpr){$/;"	f	file:
columnlist	parse.y	/^columnlist ::= column.$/;"	l
columnlist	parse.y	/^columnlist ::= columnlist COMMA column.$/;"	l
compareFunction	hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareInfo	func.c	/^struct compareInfo {$/;"	s	file:
comparisonAffinity	expr.c	/^static char comparisonAffinity(Expr *pExpr){$/;"	f	file:
computeHMS	date.c	/^static void computeHMS(DateTime *p){$/;"	f	file:
computeJD	date.c	/^static void computeJD(DateTime *p){$/;"	f	file:
computeLimitRegisters	select.c	/^static void computeLimitRegisters(Parse *pParse, Select *p){$/;"	f	file:
computeYMD	date.c	/^static void computeYMD(DateTime *p){$/;"	f	file:
computeYMD_HMS	date.c	/^static void computeYMD_HMS(DateTime *p){$/;"	f	file:
compute_action	tool/lemon.c	/^PRIVATE int compute_action(lemp,ap)$/;"	f
config	tool/lemon.c	/^struct config {$/;"	s	file:
confighash	tool/lemon.c	/^PRIVATE int confighash(a)$/;"	f
conslist	parse.y	/^conslist ::= conslist COMMA tcons.$/;"	l
conslist	parse.y	/^conslist ::= conslist tcons.$/;"	l
conslist	parse.y	/^conslist ::= tcons.$/;"	l
cont	sqliteInt.h	/^  int cont;            \/* Jump here to continue with the next loop cycle *\/$/;"	m	struct:WhereLevel
contextStack	vdbeInt.h	/^  Context *contextStack;  \/* Stack used by opcodes ContextPush & ContextPop*\/$/;"	m	struct:Vdbe
contextStackDepth	vdbeInt.h	/^  int contextStackDepth;  \/* The size of the "context" stack *\/$/;"	m	struct:Vdbe
contextStackTop	vdbeInt.h	/^  int contextStackTop;    \/* Index of top element in the context stack *\/$/;"	m	struct:Vdbe
continuePrompt	shell.c	/^static char continuePrompt[20]; \/* Continuation prompt. default: "   ...> " *\/$/;"	v	file:
conversions	www/datatype3.tcl	/^class conversions occur before the sort.<\/P>$/;"	c
cookieGoto	sqliteInt.h	/^  int cookieGoto;      \/* Address of OP_Goto to cookie verifier subroutine *\/$/;"	m	struct:Parse
cookieMask	sqliteInt.h	/^  u32 cookieMask;      \/* Bitmask of schema verified databases *\/$/;"	m	struct:Parse
cookieValue	sqliteInt.h	/^  int cookieValue[MAX_ATTACHED+2];  \/* Values of cookies to verify *\/$/;"	m	struct:Parse
copyKey	hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:Hash
copy_file	test/tester.tcl	/^proc copy_file {from to} {$/;"	p
corruptSchema	prepare.c	/^static void corruptSchema(InitData *pData, const char *zExtra){$/;"	f	file:
count	hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:Hash::_ht
count	hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:Hash
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x1	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x2	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x3	file:
count	tool/lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x4	file:
countFinalize	func.c	/^static void countFinalize(sqlite3_context *context){$/;"	f	file:
countStep	func.c	/^static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
countWriteCursors	btree.c	/^static int countWriteCursors(Btree *pBt){$/;"	f	file:
crashRequired	os_test.c	/^static int crashRequired(char const *zPath){$/;"	f	file:
crashsql	test/tester.tcl	/^proc crashsql {crashdelay crashfile sql} {$/;"	p
createMask	where.c	/^static void createMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
createTableStmt	build.c	/^static char *createTableStmt(Table *p){$/;"	f	file:
createVarMap	vdbeapi.c	/^static void createVarMap(Vdbe *p){$/;"	f	file:
create_table	parse.y	/^create_table ::= CREATE(X) temp(T) TABLE nm(Y) dbnm(Z). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= AS select(S). {$/;"	l
create_table_args	parse.y	/^create_table_args ::= LP columnlist conslist_opt(X) RP(Y). {$/;"	l
creates	www/faq.tcl	/^  process creates a new table or index, the other processes might$/;"	p
ctimeFunc	date.c	/^static void ctimeFunc($/;"	f	file:
ctimestampFunc	date.c	/^static void ctimestampFunc($/;"	f	file:
current	tool/lemon.c	/^static struct config *current = 0;       \/* Top of list of configurations *\/$/;"	v	file:
currentTimeFunc	date.c	/^static void currentTimeFunc($/;"	f	file:
currentend	tool/lemon.c	/^static struct config **currentend = 0;   \/* Last on list of configs *\/$/;"	v	file:
cursor_info	tool/spaceanal.tcl	/^proc cursor_info {arrayvar csr {up 0}} {$/;"	p
cycles	vdbe.h	/^  long long cycles;   \/* Total time spend executing this instruction *\/$/;"	m	struct:VdbeOp
data	hash.h	/^  void *data;              \/* Data associated with this element *\/$/;"	m	struct:HashElem
data	tool/lemon.c	/^  char *data;                  \/* The data *\/$/;"	m	struct:s_x1node	file:
data	tool/lemon.c	/^  struct config *data;                  \/* The data *\/$/;"	m	struct:s_x4node	file:
data	tool/lemon.c	/^  struct state *data;                  \/* The data *\/$/;"	m	struct:s_x3node	file:
data	tool/lemon.c	/^  struct symbol *data;                  \/* The data *\/$/;"	m	struct:s_x2node	file:
data	vdbeInt.h	/^  Mem data;$/;"	m	struct:Sorter
database_kw_opt	parse.y	/^database_kw_opt ::= .$/;"	l
database_kw_opt	parse.y	/^database_kw_opt ::= DATABASE.$/;"	l
datatype	tool/lemon.c	/^  char *datatype;          \/* The data type of information held by this$/;"	m	struct:symbol	file:
dateFunc	date.c	/^static void dateFunc($/;"	f	file:
datetimeFunc	date.c	/^static void datetimeFunc($/;"	f	file:
db	shell.c	/^	sqlite3 *db;		\/* The database *\/$/;"	m	struct:callback_data	file:
db	shell.c	/^static sqlite3 *db = 0;$/;"	v	file:
db	sqliteInt.h	/^  sqlite3 *db;         \/* The main database structure *\/$/;"	m	struct:Parse
db	sqliteInt.h	/^  sqlite3 *db;        \/* The database being initialized *\/$/;"	m
db	tclsqlite.c	/^  sqlite3 *db;          \/* The "real" database structure *\/$/;"	m	struct:SqliteDb	file:
db	tool/showdb.c	/^static int db = -1;$/;"	v	file:
db	tool/showjournal.c	/^static int db = -1;$/;"	v	file:
db	vdbeInt.h	/^  sqlite3 *db;        \/* The whole database *\/$/;"	m	struct:Vdbe
db1	tool/diffdb.c	/^static int db1 = -1;$/;"	v	file:
db2	tool/diffdb.c	/^static int db2 = -1;$/;"	v	file:
dbSize	pager.c	/^  int dbSize;                 \/* Number of pages in the file *\/$/;"	m	struct:Pager	file:
dbTextToObj	tclsqlite.c	/^static Tcl_Obj *dbTextToObj(char const *zText){$/;"	f	file:
db_check	test/threadtest1.c	/^void db_check(const char *zFile, const char *zMsg, char **az, ...){$/;"	f
db_execute	test/threadtest1.c	/^void db_execute(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_is_locked	test/threadtest1.c	/^static int db_is_locked(void *NotUsed, int iCount){$/;"	f	file:
db_query	test/threadtest1.c	/^char **db_query(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_query_callback	test/threadtest1.c	/^static int db_query_callback($/;"	f	file:
db_query_free	test/threadtest1.c	/^void db_query_free(char **az){$/;"	f
deallocates	www/c_interface.tcl	/^procedure deallocates the memory and other resources that the virtual$/;"	p
declargslot	tool/lemon.c	/^  char **declargslot;        \/* Where the declaration argument should be put *\/$/;"	m	struct:pstate	file:
declassoc	tool/lemon.c	/^  enum e_assoc declassoc;    \/* Assign this association to decl arguments *\/$/;"	m	struct:pstate	file:
declkeyword	tool/lemon.c	/^  char *declkeyword;         \/* Keyword of a declaration *\/$/;"	m	struct:pstate	file:
decllnslot	tool/lemon.c	/^  int *decllnslot;           \/* Where the declaration linenumber is put *\/$/;"	m	struct:pstate	file:
decodeFlags	btree.c	/^static void decodeFlags(MemPage *pPage, int flagByte){$/;"	f	file:
deferredMoveto	vdbeInt.h	/^  Bool deferredMoveto;  \/* A call to sqlite3BtreeMoveto() is needed *\/$/;"	m	struct:Cursor
defragmentPage	btree.c	/^static int defragmentPage(MemPage *pPage){$/;"	f	file:
deleteConf	sqliteInt.h	/^  u8 deleteConf;    \/* How to resolve conflicts that occur on DELETE *\/$/;"	m	struct:FKey
deleteconfig	tool/lemon.c	/^PRIVATE void deleteconfig(old)$/;"	f
destroyRootPage	build.c	/^static void destroyRootPage(Parse *pParse, int iTable, int iDb){$/;"	f	file:
destroyTable	build.c	/^static void destroyTable(Parse *pParse, Table *pTab){$/;"	f	file:
destructor	func.c	/^static void destructor(void *p){$/;"	f	file:
destructor	tool/lemon.c	/^  char *destructor;        \/* Code which executes whenever this symbol is$/;"	m	struct:symbol	file:
destructorln	tool/lemon.c	/^  int destructorln;        \/* Line number of destructor code *\/$/;"	m	struct:symbol	file:
dev	os_aros.c	/^	dev_t dev;       \/* Device number *\/$/;"	m	struct:lockKey	file:
dfltCompare	btree.c	/^static int dfltCompare($/;"	f	file:
dirfd	os_aros.h	/^	int dirfd;                \/* File descriptor for the directory *\/$/;"	m	struct:OsFile
dirty	pager.c	/^  u8 dirty;                      \/* TRUE if we need to write back changes *\/$/;"	m	struct:PgHdr	file:
dirtyCache	pager.c	/^  u8 dirtyCache;              \/* True if cached pages have changed *\/$/;"	m	struct:Pager	file:
disableTerm	where.c	/^static void disableTerm(WhereLevel *pLevel, Expr **ppExpr){$/;"	f	file:
displayP3	vdbeaux.c	/^static char *displayP3(Op *pOp, char *zTemp, int nTemp){$/;"	f	file:
divide	tool/spaceanal.tcl	/^proc divide {num denom} {$/;"	p
do_ioerr_test	test/tester.tcl	/^proc do_ioerr_test {testname args} {$/;"	p
do_meta_command	shell.c	/^static BOOL do_meta_command(STRPTR zLine, struct callback_data *p)$/;"	f	file:
do_some_sql	test/crashtest1.c	/^static void do_some_sql(int parent){$/;"	f	file:
do_test	test/tester.tcl	/^proc do_test {name cmd expected} {$/;"	p
doc	www/docs.tcl	/^proc doc {name url desc} {$/;"	p
done	sqliteInt.h	/^    u8 done;               \/* A flag to indicate when processing is finished *\/$/;"	m	struct:ExprList::ExprList_item
dot	tool/lemon.c	/^  int dot;                 \/* The parse point *\/$/;"	m	struct:config	file:
dropCell	btree.c	/^static void dropCell(MemPage *pPage, int idx, int sz){$/;"	f	file:
dtnum	tool/lemon.c	/^  int dtnum;               \/* The data type number.  In the parser, the value$/;"	m	struct:symbol	file:
dump_callback	shell.c	/^static int dump_callback(void *pArg, int nArg, char **azArg, char **azCol)$/;"	f	file:
dyn	sqliteInt.h	/^  unsigned dyn  : 1;      \/* True for malloced memory, false for static *\/$/;"	m	struct:Token
e_action	tool/lemon.c	/^  enum e_action {$/;"	g	struct:action	file:
e_assoc	tool/lemon.c	/^  enum e_assoc {$/;"	g	struct:symbol	file:
e_state	tool/lemon.c	/^  enum e_state {$/;"	g	struct:pstate	file:
echoOn	shell.c	/^	int echoOn;			\/* True to echo input commands *\/$/;"	m	struct:callback_data	file:
ecmd	parse.y	/^ecmd ::= SEMI.$/;"	l
ecmd	parse.y	/^ecmd ::= explain cmdx SEMI.$/;"	l
elapse	os_common.h	/^static unsigned int elapse;$/;"	v
emit_code	tool/lemon.c	/^PRIVATE void emit_code(out,rp,lemp,lineno)$/;"	f
emit_destructor_code	tool/lemon.c	/^void emit_destructor_code(out,sp,lemp,lineno)$/;"	f
emsg	tool/lemon.c	/^static char emsg[] = "Command line syntax error: ";$/;"	v	file:
enc	sqliteInt.h	/^  u8 enc;                       \/* Text encoding for this database. *\/$/;"	m	struct:sqlite3
enc	sqliteInt.h	/^  u8 enc;              \/* Text encoding handled by xCmp() *\/$/;"	m	struct:CollSeq
enc	sqliteInt.h	/^  u8 enc;             \/* Text encoding - one of the TEXT_Utf* values *\/$/;"	m	struct:KeyInfo
enc	vdbeInt.h	/^  u8  enc;            \/* TEXT_Utf8, TEXT_Utf16le, or TEXT_Utf16be *\/$/;"	m	struct:Mem
errCode	sqliteInt.h	/^  int errCode;                  \/* Most recent error code (SQLITE_*) *\/$/;"	m	struct:sqlite3
errMask	pager.c	/^  u8 errMask;                 \/* One of several kinds of errors *\/$/;"	m	struct:Pager	file:
err_t	sqliteInt.h	/^typedef int err_t;$/;"	t
errline	tool/lemon.c	/^static void errline(n,k,err)$/;"	f	file:
error	tool/lemon.c	/^  char *error;             \/* Code to execute when an error is seen *\/$/;"	m	struct:lemon	file:
errorAction	vdbeInt.h	/^  int errorAction;        \/* Recovery action to do in case of an error *\/$/;"	m	struct:Vdbe
errorcnt	tool/lemon.c	/^  int errorcnt;            \/* Number of errors *\/$/;"	m	struct:lemon	file:
errorcnt	tool/lemon.c	/^  int errorcnt;         \/* Number of errors so far *\/$/;"	m	struct:pstate	file:
errorln	tool/lemon.c	/^  int  errorln;            \/* Line number for start of error code *\/$/;"	m	struct:lemon	file:
errstream	tool/lemon.c	/^static FILE *errstream;$/;"	v	file:
errsym	tool/lemon.c	/^  struct symbol *errsym;   \/* The error symbol *\/$/;"	m	struct:lemon	file:
etBUFSIZE	printf.c	172;"	d	file:
etByte	printf.c	/^typedef unsigned char etByte;$/;"	t	file:
etCHARLIT	printf.c	76;"	d	file:
etCHARX	printf.c	73;"	d	file:
etDYNSTRING	printf.c	71;"	d	file:
etERROR	printf.c	74;"	d	file:
etEXP	printf.c	67;"	d	file:
etFLOAT	printf.c	66;"	d	file:
etGENERIC	printf.c	68;"	d	file:
etNINFO	printf.c	140;"	d	file:
etPERCENT	printf.c	72;"	d	file:
etPOINTER	printf.c	82;"	d	file:
etRADIX	printf.c	65;"	d	file:
etSIZE	printf.c	69;"	d	file:
etSPACESIZE	printf.c	233;"	d	file:
etSQLESCAPE	printf.c	77;"	d	file:
etSQLESCAPE2	printf.c	78;"	d	file:
etSRCLIST	printf.c	81;"	d	file:
etSTRING	printf.c	70;"	d	file:
etTOKEN	printf.c	80;"	d	file:
et_getdigit	printf.c	/^static int et_getdigit(LONGDOUBLE_TYPE *val, int *cnt)$/;"	f	file:
et_info	printf.c	/^typedef struct et_info {   \/* Information about each format field *\/$/;"	s	file:
et_info	printf.c	/^} et_info;$/;"	t	file:
execExecSql	vacuum.c	/^static int execExecSql(sqlite3 *db, const char *zSql){$/;"	f	file:
execSql	vacuum.c	/^static int execSql(sqlite3 *db, const char *zSql){$/;"	f	file:
execsql	test/tester.tcl	/^proc execsql {sql {db db}} {$/;"	p
execsql2	test/tester.tcl	/^proc execsql2 {sql} {$/;"	p
expired	vdbeInt.h	/^  u8 expired;             \/* True if the VM needs to be recompiled *\/$/;"	m	struct:Vdbe
explain	parse.y	/^explain ::= .           { sqlite3BeginParse(pParse, 0); }$/;"	l
explain	parse.y	/^explain ::= EXPLAIN.    { sqlite3BeginParse(pParse, 1); }$/;"	l
explain	sqliteInt.h	/^  u8 explain;          \/* True if the EXPLAIN flag is found on the query *\/$/;"	m	struct:Parse
explain	test/tester.tcl	/^proc explain {sql {db db}} {$/;"	p
explain	vdbeInt.h	/^  u8 explain;             \/* True if EXPLAIN present on SQL command *\/$/;"	m	struct:Vdbe
explainPrev	shell.c	/^	struct previous_mode_data explainPrev;$/;"	m	struct:callback_data	file:
exprAnalyze	where.c	/^static void exprAnalyze(SrcList *pSrc, ExprMaskSet *pMaskSet, ExprInfo *pInfo){$/;"	f	file:
exprListTableUsage	where.c	/^static Bitmask exprListTableUsage(ExprMaskSet *pMaskSet, ExprList *pList){$/;"	f	file:
exprNodeIsConstant	expr.c	/^static int exprNodeIsConstant(void *pArg, Expr *pExpr){$/;"	f	file:
exprSplit	where.c	/^static int exprSplit(int nSlot, ExprInfo *aSlot, Expr *pExpr){$/;"	f	file:
exprTableUsage	where.c	/^static Bitmask exprTableUsage(ExprMaskSet *pMaskSet, Expr *p){$/;"	f	file:
extracode	tool/lemon.c	/^  char *extracode;         \/* Code appended to the generated file *\/$/;"	m	struct:lemon	file:
extracodeln	tool/lemon.c	/^  int  extracodeln;        \/* Line number for the start of the extra code *\/$/;"	m	struct:lemon	file:
failure	tool/lemon.c	/^  char *failure;           \/* Code to execute on parser failure *\/$/;"	m	struct:lemon	file:
failureln	tool/lemon.c	/^  int  failureln;          \/* Line number for start of failure code *\/$/;"	m	struct:lemon	file:
fallback	tool/lemon.c	/^  struct symbol *fallback;   \/* The fallback token *\/$/;"	m	struct:pstate	file:
fallback	tool/lemon.c	/^  struct symbol *fallback; \/* fallback token in case this token doesn't parse *\/$/;"	m	struct:symbol	file:
faq	www/faq.tcl	/^proc faq {question answer} {$/;"	p
fd	os_test.h	/^  OsRealFile fd;$/;"	m	struct:OsTestFile
fd	pager.c	/^  OsFile fd, jfd;             \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
feature	www/different.tcl	/^proc feature {tag name text} {$/;"	p
feature	www/omitted.tcl	/^proc feature {name desc} {$/;"	p
fetchPayload	btree.c	/^static const unsigned char *fetchPayload($/;"	f	file:
file_format	sqliteInt.h	/^  u8 file_format;               \/* What file format version is this database? *\/$/;"	m	struct:sqlite3
file_makename	tool/lemon.c	/^PRIVATE char *file_makename(lemp,suffix)$/;"	f
file_open	tool/lemon.c	/^PRIVATE FILE *file_open(lemp,suffix,mode)$/;"	f
filename	tool/lemon.c	/^  char *filename;          \/* Name of the input file *\/$/;"	m	struct:lemon	file:
filename	tool/lemon.c	/^  char *filename;       \/* Name of the input file *\/$/;"	m	struct:pstate	file:
fillAgg	sqliteInt.h	/^  u8 fillAgg;          \/* If true, ignore the Expr.iAgg field. Normally false *\/$/;"	m	struct:Parse
fillInCell	btree.c	/^static int fillInCell($/;"	f	file:
finalize	tool/mkopts.tcl	/^proc finalize {} {$/;"	p
finalize_testing	test/tester.tcl	/^proc finalize_testing {} {$/;"	p
findById	tool/mkkeywordhash.c	/^static Keyword *findById(int id){$/;"	f	file:
findCell	btree.c	/^static u8 *findCell(MemPage *pPage, int iCell){$/;"	f	file:
findCollSeqEntry	callback.c	/^static CollSeq * findCollSeqEntry($/;"	f	file:
findDb	build.c	/^static int findDb(sqlite3 *db, Token *pName){$/;"	f	file:
findElementGivenHash	hash.c	/^static HashElem *findElementGivenHash($/;"	f	file:
findLockInfo	os_aros.c	/^static int findLockInfo($/;"	f	file:
findOverflowCell	btree.c	/^static u8 *findOverflowCell(MemPage *pPage, int iCell){$/;"	f	file:
find_home_dir	shell.c	/^static STRPTR find_home_dir(void)$/;"	f	file:
findbreak	tool/lemon.c	/^static int findbreak(msg,min,max)$/;"	f	file:
finish_test	test/tester.tcl	/^proc finish_test {} {$/;"	p
first	hash.h	/^  HashElem *first;        \/* The first element of the array *\/$/;"	m	struct:Hash
firstrule	tool/lemon.c	/^  struct rule *firstrule;    \/* Pointer to first rule in the grammar *\/$/;"	m	struct:pstate	file:
firstset	tool/lemon.c	/^  char *firstset;          \/* First-set for all rules of this symbol *\/$/;"	m	struct:symbol	file:
flagPragma	pragma.c	/^static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){$/;"	f	file:
flags	printf.c	/^	etByte flags;          \/* One or more of FLAG_ constants below *\/$/;"	m	struct:et_info	file:
flags	sqliteInt.h	/^	u16 flags;           \/* Flags associated with this database *\/$/;"	m	struct:Db
flags	sqliteInt.h	/^  int flags;                    \/* Miscellanous flags. See below *\/$/;"	m	struct:sqlite3
flags	sqliteInt.h	/^  u8 flags;              \/* Various flags.  See below *\/$/;"	m	struct:Expr
flags	vdbeInt.h	/^  u16 flags;          \/* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. *\/$/;"	m	struct:Mem
flattenSubquery	select.c	/^static int flattenSubquery($/;"	f	file:
flushStmtCache	tclsqlite.c	/^static void flushStmtCache( SqliteDb *pDb ){$/;"	f	file:
fmtinfo	printf.c	/^static const et_info fmtinfo[] = {$/;"	v	file:
fmttype	printf.c	/^	char fmttype;          \/* The format field code letter *\/$/;"	m	struct:et_info	file:
footer	common.tcl	/^proc footer {{rcsid {}}} {$/;"	p
footer	www/common.tcl	/^proc footer {{rcsid {}}} {$/;"	p
footer	www/lang.tcl	/^      proc footer {id} {$/;"	p
forcedelete	test/tester.tcl	/^proc forcedelete {filename} {$/;"	p
foreach	sqliteInt.h	/^  int foreach;            \/* One of TK_ROW or TK_STATEMENT *\/$/;"	m	struct:Trigger
fplp	tool/lemon.c	/^  struct plink *fplp;      \/* Follow-set forward propagation links *\/$/;"	m	struct:config	file:
freeAggElem	vdbeaux.c	/^static void freeAggElem(AggElem *pElem, Agg *pAgg){$/;"	f	file:
freeIndex	build.c	/^static void freeIndex(Index *p){$/;"	f	file:
freeMaskSet	where.c	180;"	d	file:
freePage	btree.c	/^static int freePage(MemPage *pPage){$/;"	f	file:
freeSpace	btree.c	/^static void freeSpace(MemPage *pPage, int start, int size){$/;"	f	file:
free_test_auxdata	func.c	/^static void free_test_auxdata(void *p) {sqliteFree(p);}$/;"	f	file:
freelist	tool/lemon.c	/^static struct config *freelist = 0;      \/* List of free configurations *\/$/;"	v	file:
from	tool/lemon.c	/^  struct s_x1node **from;  \/* Previous link *\/$/;"	m	struct:s_x1node	file:
from	tool/lemon.c	/^  struct s_x2node **from;  \/* Previous link *\/$/;"	m	struct:s_x2node	file:
from	tool/lemon.c	/^  struct s_x3node **from;  \/* Previous link *\/$/;"	m	struct:s_x3node	file:
from	tool/lemon.c	/^  struct s_x4node **from;  \/* Previous link *\/$/;"	m	struct:s_x4node	file:
fullSync	os_aros.h	/^	BOOL fullSync;            \/* Use F_FULLSYNC if available *\/$/;"	m	struct:OsFile
fullSync	pager.c	/^  u8 fullSync;                \/* Do extra syncs of the journal for robustness *\/$/;"	m	struct:Pager	file:
full_fsync	os_aros.c	/^static int full_fsync(int fd, int fullSync)$/;"	f	file:
fws	tool/lemon.c	/^  char *fws;               \/* Follow-set for this configuration only *\/$/;"	m	struct:config	file:
g_start	os_common.h	/^static unsigned long long int g_start;$/;"	v
generateColumnNames	select.c	/^static void generateColumnNames($/;"	f	file:
generateColumnTypes	select.c	/^static void generateColumnTypes($/;"	f	file:
generateSortTail	select.c	/^static void generateSortTail($/;"	f	file:
get2byte	btree.c	/^static u32 get2byte(unsigned char *p){$/;"	f	file:
get4byte	btree.c	/^static u32 get4byte(unsigned char *p){$/;"	f	file:
getAndInitPage	btree.c	/^static int getAndInitPage($/;"	f	file:
getBoolean	pragma.c	/^static int getBoolean(const u8 *z){$/;"	f	file:
getCellInfo	btree.c	/^static void getCellInfo(BtCursor *pCur){$/;"	f	file:
getDigits	date.c	/^static int getDigits(const char *zDate, ...){$/;"	f	file:
getMask	where.c	/^static Bitmask getMask(ExprMaskSet *pMaskSet, int iCursor){$/;"	f	file:
getPage	btree.c	/^static int getPage(Btree *pBt, Pgno pgno, MemPage **ppPage){$/;"	f	file:
getPayload	btree.c	/^static int getPayload($/;"	f	file:
getSafetyLevel	pragma.c	/^static int getSafetyLevel(const u8 *z){$/;"	f	file:
getTempCursor	btree.c	/^static void getTempCursor(BtCursor *pCur, BtCursor *pTempCur){$/;"	f	file:
getTempStore	pragma.c	/^static int getTempStore(const char *z){$/;"	f	file:
getToken	tokenize.c	/^static int getToken(const unsigned char *z, int *tokenType){$/;"	f	file:
getValue	date.c	/^static int getValue(const char *z, double *pR){$/;"	f	file:
getVarint	btree.c	404;"	d	file:
getVarint32	btree.c	405;"	d	file:
getstate	tool/lemon.c	/^PRIVATE struct state *getstate(lemp)$/;"	f
globFunc	func.c	/^static void globFunc(sqlite3_context *context, int arg, sqlite3_value **argv){$/;"	f	file:
globInfo	func.c	/^static const struct compareInfo globInfo = { '*', '?', '[', 0 };$/;"	v	file:
gp	tool/lemon.c	/^  struct lemon *gp;     \/* Global state vector *\/$/;"	m	struct:pstate	file:
h	date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
h	os_aros.h	/^	int h;                    \/* The file descriptor *\/$/;"	m	struct:OsFile
handle_D_option	tool/lemon.c	/^static void handle_D_option(char *z){$/;"	f	file:
handleflags	tool/lemon.c	/^static int handleflags(i,err)$/;"	f	file:
handleswitch	tool/lemon.c	/^static int handleswitch(i,err)$/;"	f	file:
hasAgg	sqliteInt.h	/^  u8 hasAgg;$/;"	m	struct:NameContext
hasData	btree.c	/^  u8 hasData;          \/* True if this page stores data *\/$/;"	m	struct:MemPage	file:
hasHotJournal	pager.c	/^static int hasHotJournal(Pager *pPager){$/;"	f	file:
hasPrimKey	sqliteInt.h	/^  u8 hasPrimKey;   \/* True if there exists a primary key *\/$/;"	m	struct:Table
has_destructor	tool/lemon.c	/^int has_destructor(sp, lemp)$/;"	f
has_fallback	tool/lemon.c	/^  int has_fallback;        \/* True if any %fallback is seen in the grammer *\/$/;"	m	struct:lemon	file:
hash	tool/mkkeywordhash.c	/^  int hash;            \/* Hash on the keyword *\/$/;"	m	struct:Keyword	file:
hash	vdbeInt.h	/^  Hash hash;             \/* A set is just a hash table *\/$/;"	m	struct:Set
hashFunction	hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hdrOffset	btree.c	/^  u8 hdrOffset;        \/* 100 for page 1.  0 otherwise *\/$/;"	m	struct:MemPage	file:
header	common.tcl	/^proc header {txt} {$/;"	p
header	www/common.tcl	/^proc header {txt} {$/;"	p
hexToInt	util.c	/^static int hexToInt(int h)$/;"	f	file:
ht	hash.h	/^  } *ht;$/;"	m	struct:Hash
ht	tool/lemon.c	/^  struct s_x1node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x1	file:
ht	tool/lemon.c	/^  struct s_x2node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x2	file:
ht	tool/lemon.c	/^  struct s_x3node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x3	file:
ht	tool/lemon.c	/^  struct s_x4node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x4	file:
htsize	hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:Hash
hwtime	os_common.h	/^__inline__ unsigned long long int hwtime(void)$/;"	f
hwtime	vdbe.c	/^__inline__ unsigned long long int hwtime(void){$/;"	f
i	vdbeInt.h	/^  i64 i;              \/* Integer value *\/$/;"	m	struct:Mem
i16	sqliteInt.h	/^typedef INT16_TYPE i16;            \/* 2-byte signed integer *\/$/;"	t
i64	sqliteInt.h	/^typedef sqlite_int64 i64;          \/* 8-byte signed integer *\/$/;"	t
i8	sqliteInt.h	/^typedef UINT8_TYPE i8;             \/* 1-byte signed integer *\/$/;"	t
iAgg	sqliteInt.h	/^  int iAgg;              \/* When op==TK_COLUMN and pParse->fillAgg==FALSE, pull$/;"	m	struct:Expr
iAggCtx	sqliteInt.h	/^  int iAggCtx;           \/* The value to pass as P1 of OP_AggGet. *\/$/;"	m	struct:Expr
iBreak	sqliteInt.h	/^  int iBreak;          \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereInfo
iColumn	sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iContinue	sqliteInt.h	/^  int iContinue;       \/* Jump here to continue with next record *\/$/;"	m	struct:WhereInfo
iCrashDelay	os_test.c	/^static int iCrashDelay = 0;$/;"	v	file:
iCursor	sqliteInt.h	/^    int iCursor;      \/* The VDBE cursor number used to access this table *\/$/;"	m	struct:SrcList::SrcList_item
iDb	sqliteInt.h	/^    int iDb;                    \/* When back is being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
iDb	sqliteInt.h	/^  u8 iDb;                 \/* Database containing this trigger               *\/$/;"	m	struct:Trigger
iDb	sqliteInt.h	/^  u8 iDb;                \/* Database referenced by this expression *\/$/;"	m	struct:Expr
iDb	sqliteInt.h	/^  u8 iDb;          \/* Index in sqlite.aDb[] of where this index is stored *\/$/;"	m	struct:Index
iDb	sqliteInt.h	/^  u8 iDb;          \/* Index into sqlite.aDb[] of the backend for this table *\/$/;"	m	struct:Table
iDflt	tool/lemon.c	/^  int iDflt;               \/* Default action *\/$/;"	m	struct:state	file:
iFrom	sqliteInt.h	/^    int iFrom;         \/* Index of column in pFrom *\/$/;"	m	struct:FKey::sColMap
iIdxCur	sqliteInt.h	/^  int iIdxCur;         \/* The VDBE cursor used to acesss pIdx *\/$/;"	m	struct:WhereLevel
iKey	vdbeInt.h	/^  i64 iKey;             \/* Key for the NEW or OLD pseudo-table row *\/$/;"	m	struct:Cursor
iLeftJoin	sqliteInt.h	/^  int iLeftJoin;       \/* Memory cell used to implement LEFT OUTER JOIN *\/$/;"	m	struct:WhereLevel
iLimit	sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iMem	sqliteInt.h	/^  int iMem;            \/* Memory cell used by this level *\/$/;"	m	struct:WhereLevel
iNext	tool/mkkeywordhash.c	/^  int iNext;           \/* Index in aKeywordTable[] of next with same hash *\/$/;"	m	struct:Keyword	file:
iNtOfst	tool/lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iOffset	sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iOverflow	btree.c	/^  u16 iOverflow; \/* Offset to overflow page number.  Zero if no overflow *\/$/;"	m	struct:CellInfo	file:
iPKey	sqliteInt.h	/^  int iPKey;       \/* If not less then 0, use aCol[iPKey] as the primary key *\/$/;"	m	struct:Table
iPrefEnc	sqliteInt.h	/^  u8 iPrefEnc;         \/* Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) *\/$/;"	m	struct:FuncDef
iTabCur	sqliteInt.h	/^  int iTabCur;         \/* The VDBE cursor used to access the table *\/$/;"	m	struct:WhereLevel
iTabDb	sqliteInt.h	/^  u8 iTabDb;              \/* Database containing Trigger.table              *\/$/;"	m	struct:Trigger
iTable	sqliteInt.h	/^  int iTable, iColumn;   \/* When op==TK_COLUMN, then this expr node means the$/;"	m	struct:Expr
iTknOfst	tool/lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iTop	sqliteInt.h	/^  int iTop;            \/* The very beginning of the WHERE loop *\/$/;"	m	struct:WhereInfo
id	tool/mkkeywordhash.c	/^  int id;              \/* Unique ID for this record *\/$/;"	m	struct:Keyword	file:
identLength	build.c	/^static int identLength(const char *z){$/;"	f	file:
identPut	build.c	/^static void identPut(char *z, int *pIdx, char *zSignedIdent){$/;"	f	file:
idx	btree.c	/^    u16 idx;             \/* Insert this cell before idx-th non-overflow cell *\/$/;"	m	struct:MemPage::_OvflCell	file:
idx	btree.c	/^  int idx;                  \/* Index of the entry in pPage->aCell[] *\/$/;"	m	struct:BtCursor	file:
idx	sqliteInt.h	/^    int idx;          \/* Index in some Table.aCol[] of a column named zName *\/$/;"	m	struct:IdList::IdList_item
idxHash	sqliteInt.h	/^	Hash idxHash;        \/* All (named) indices indexed by name *\/$/;"	m	struct:Db
idxLeft	where.c	/^  short int idxLeft;      \/* p->pLeft is a column in this table number. -1 if$/;"	m	struct:ExprInfo	file:
idxParent	btree.c	/^  u16 idxParent;       \/* Index in parent of this node *\/$/;"	m	struct:MemPage	file:
idxRight	where.c	/^  short int idxRight;     \/* p->pRight is a column in this table number. -1 if$/;"	m	struct:ExprInfo	file:
idxShift	btree.c	/^  u8 idxShift;         \/* True if Cell indices have changed *\/$/;"	m	struct:MemPage	file:
ifcapable	test/tester.tcl	/^proc ifcapable {expr code {else ""} {elsecode ""}} {$/;"	p
ifnullFunc	func.c	/^static void ifnullFunc($/;"	f	file:
ignoreJump	sqliteInt.h	/^  int ignoreJump;      \/* where to jump to for a RAISE(IGNORE) *\/$/;"	m	struct:TriggerStack
in	md5.c	/^	unsigned char in[64];$/;"	m	struct:Context	file:
inJournal	pager.c	/^  u8 inJournal;                  \/* TRUE if has been written to journal *\/$/;"	m	struct:PgHdr	file:
inMutex	os_aros.c	/^static BOOL inMutex = FALSE;$/;"	v	file:
inOp	sqliteInt.h	/^  int inOp, inP1, inP2;\/* Opcode used to implement an IN operator *\/$/;"	m	struct:WhereLevel
inP1	sqliteInt.h	/^  int inOp, inP1, inP2;\/* Opcode used to implement an IN operator *\/$/;"	m	struct:WhereLevel
inP2	sqliteInt.h	/^  int inOp, inP1, inP2;\/* Opcode used to implement an IN operator *\/$/;"	m	struct:WhereLevel
inStmt	btree.c	/^  u8 inStmt;            \/* True if we are in a statement subtransaction *\/$/;"	m	struct:Btree	file:
inStmt	pager.c	/^  u8 inStmt;                     \/* TRUE if in the statement subjournal *\/$/;"	m	struct:PgHdr	file:
inTempTrans	vdbeInt.h	/^  int inTempTrans;        \/* True if temp database is transactioned *\/$/;"	m	struct:Vdbe
inTrans	btree.c	/^  u8 inTrans;           \/* True if a transaction is in progress *\/$/;"	m	struct:Btree	file:
inTrans	sqliteInt.h	/^	u8 inTrans;          \/* 0: not writable.  1: Transaction.  2: Checkpoint *\/$/;"	m	struct:Db
include	tool/lemon.c	/^  char *include;           \/* Code to put at the start of the C file *\/$/;"	m	struct:lemon	file:
includeln	tool/lemon.c	/^  int  includeln;          \/* Line number for start of include code *\/$/;"	m	struct:lemon	file:
incrKey	sqliteInt.h	/^  u8 incrKey;         \/* Increase 2nd key by epsilon before comparison *\/$/;"	m	struct:KeyInfo
index	tool/lemon.c	/^  int index;               \/* An index number for this rule *\/$/;"	m	struct:rule	file:
index	tool/lemon.c	/^  int index;               \/* Index number for this symbol *\/$/;"	m	struct:symbol	file:
index	tool/lemon.c	/^  int index;               \/* Sequencial number for this state *\/$/;"	m	struct:state	file:
indexable	where.c	/^  u8 indexable;           \/* True if this subexprssion is usable by an index *\/$/;"	m	struct:ExprInfo	file:
info	btree.c	/^  CellInfo info;            \/* A parse of the cell we are pointing at *\/$/;"	m	struct:BtCursor	file:
init	sqliteInt.h	/^  } init;$/;"	m	struct:sqlite3
initFile	os_test.c	/^static void initFile(OsFile *id, char const *zName){$/;"	f	file:
initMaskSet	where.c	152;"	d	file:
initPage	btree.c	/^static int initPage($/;"	f	file:
ino	os_aros.c	/^	ino_t ino;       \/* Inode number *\/$/;"	m	struct:lockKey	file:
input	parse.y	/^input ::= cmdlist.$/;"	l
insertCell	btree.c	/^static int insertCell($/;"	f	file:
insertConf	sqliteInt.h	/^  u8 insertConf;    \/* How to resolve conflicts that occur on INSERT *\/$/;"	m	struct:FKey
insertElement	hash.c	/^static void insertElement($/;"	f	file:
intKey	btree.c	/^  u8 intKey;           \/* True if intkey flag is set *\/$/;"	m	struct:MemPage	file:
intToKey	vdbeInt.h	24;"	d
integerify	tool/spaceanal.tcl	/^proc integerify {real} {$/;"	p
integrity_check	test/tester.tcl	/^proc integrity_check {name} {$/;"	p
integrity_check	test/threadtest2.c	/^int integrity_check(sqlite *db){$/;"	f
interp	tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlCollate	file:
interp	tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlFunc	file:
interp	tclsqlite.c	/^  Tcl_Interp *interp;   \/* The interpreter used for this database *\/$/;"	m	struct:SqliteDb	file:
interrupt_handler	shell.c	/^static void interrupt_handler(int NotUsed)$/;"	f	file:
invalidateTempStorage	pragma.c	/^static int invalidateTempStorage(Parse *pParse){$/;"	f	file:
is	www/capi3ref.tcl	/^ procedure is responsible for deleting this compiled SQL statement$/;"	p
isAgg	sqliteInt.h	/^    u8 isAgg;              \/* True if this is an aggregate like count(*) *\/$/;"	m	struct:ExprList::ExprList_item
isAgg	sqliteInt.h	/^  int isAgg;        \/* if TRUE contains an aggregate function *\/$/;"	m	struct:AggExpr
isAgg	sqliteInt.h	/^  u8 isAgg;              \/* True if this is an aggregate query *\/$/;"	m	struct:Select
isDate	date.c	/^static int isDate(int argc, sqlite3_value **argv, DateTime *p){$/;"	f	file:
isDeferred	sqliteInt.h	/^  u8 isDeferred;    \/* True if constraint checking is deferred till COMMIT *\/$/;"	m	struct:FKey
isDistinct	sqliteInt.h	/^  u8 isDistinct;         \/* True if the DISTINCT keyword is present *\/$/;"	m	struct:Select
isError	vdbeInt.h	/^  u8 isError;       \/* Set to true for an error *\/$/;"	m	struct:sqlite3_context
isIdChar	tokenize.c	/^static const char isIdChar[] = {$/;"	v	file:
isIndex	vdbeInt.h	/^  Bool isIndex;         \/* True if an index containing keys only - no data *\/$/;"	m	struct:Cursor
isInit	btree.c	/^  u8 isInit;           \/* True if previously initialized. MUST BE FIRST! *\/$/;"	m	struct:MemPage	file:
isNumber	shell.c	/^static BOOL isNumber(const unsigned char *z, int *realnum)$/;"	f	file:
isOpen	os_aros.h	/^	BOOL isOpen;              \/* True if needs to be closed *\/$/;"	m	struct:OsFile
isPrimKey	sqliteInt.h	/^  u8 isPrimKey;    \/* True if this column is part of the PRIMARY KEY *\/$/;"	m	struct:Column
isResolved	sqliteInt.h	/^  u8 isResolved;         \/* True once sqlite3SelectResolve() has run. *\/$/;"	m	struct:Select
isRootPage	btree.c	/^static int isRootPage(MemPage *pPage){$/;"	f	file:
isSortingIndex	where.c	/^static int isSortingIndex($/;"	f	file:
isTable	vdbeInt.h	/^  Bool isTable;         \/* True if a table requiring integer keys *\/$/;"	m	struct:Cursor
isTkn	tool/lemon.c	/^  int isTkn;           \/* True to use tokens.  False for non-terminals *\/$/;"	m	struct:axset	file:
isTransient	sqliteInt.h	/^  u8 isTransient;  \/* True if automatically deleted when VDBE finishes *\/$/;"	m	struct:Table
isValid	btree.c	/^  u8 isValid;               \/* TRUE if points to a valid entry *\/$/;"	m	struct:BtCursor	file:
isView	delete.c	127;"	d	file:
isView	delete.c	130;"	d	file:
isView	delete.c	131;"	d	file:
isView	insert.c	252;"	d	file:
isView	insert.c	255;"	d	file:
isView	insert.c	256;"	d	file:
isView	update.c	115;"	d	file:
isView	update.c	118;"	d	file:
isView	update.c	119;"	d	file:
ix	where.c	/^  int ix[sizeof(Bitmask)*8];    \/* Cursor assigned to each bit *\/$/;"	m	struct:ExprMaskSet	file:
jfd	pager.c	/^  OsFile fd, jfd;             \/* File descriptors for database and journal *\/$/;"	m	struct:Pager	file:
jointype	sqliteInt.h	/^    int jointype;     \/* Type of join between this table and the next *\/$/;"	m	struct:SrcList::SrcList_item
journalHdr	pager.c	/^  i64 journalHdr;             \/* Byte offset to previous journal header *\/$/;"	m	struct:Pager	file:
journalOff	pager.c	/^  i64 journalOff;             \/* Current byte offset in the journal file *\/$/;"	m	struct:Pager	file:
journalOpen	pager.c	/^  u8 journalOpen;             \/* True if journal file descriptors is valid *\/$/;"	m	struct:Pager	file:
journalStarted	pager.c	/^  u8 journalStarted;          \/* True if header of journal is synced *\/$/;"	m	struct:Pager	file:
juliandayFunc	date.c	/^static void juliandayFunc($/;"	f	file:
key	os_aros.c	/^	struct lockKey key;  \/* The lookup key *\/$/;"	m	struct:lockInfo	file:
key	os_aros.c	/^	struct openKey key;   \/* The lookup key *\/$/;"	m	struct:openCnt	file:
key	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	m	struct:AttachKey	file:
key	tool/lemon.c	/^  char *key;                   \/* The key *\/$/;"	m	struct:s_x2node	file:
key	tool/lemon.c	/^  struct config *key;                   \/* The key *\/$/;"	m	struct:s_x3node	file:
keyClass	hash.h	/^  char keyClass;          \/* SQLITE_HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:Hash
keyConf	sqliteInt.h	/^  u8 keyConf;      \/* What to do in case of uniqueness conflict on iPKey *\/$/;"	m	struct:Table
keyInfo	sqliteInt.h	/^  KeyInfo keyInfo; \/* Info on how to order keys.  MUST BE LAST *\/$/;"	m	struct:Index
keyToInt	vdbeInt.h	23;"	d
keywordCode	keywordhash.h	/^static int keywordCode(const char *z, int n){$/;"	f
keywordCompare1	tool/mkkeywordhash.c	/^static int keywordCompare1(const void *a, const void *b){$/;"	f	file:
keywordCompare2	tool/mkkeywordhash.c	/^static int keywordCompare2(const void *a, const void *b){$/;"	f	file:
keywordCompare3	tool/mkkeywordhash.c	/^static int keywordCompare3(const void *a, const void *b){$/;"	f	file:
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= .$/;"	l
kwcolumn_opt	parse.y	/^kwcolumn_opt ::= COLUMNKW.$/;"	l
label	tool/lemon.c	/^  char *label;$/;"	m	struct:s_options	file:
lambda	tool/lemon.c	/^  Boolean lambda;          \/* True if NT and can generate an empty string *\/$/;"	m	struct:symbol	file:
lastRowid	sqliteInt.h	/^  i64 lastRowid;                \/* ROWID of most recent insert (see above) *\/$/;"	m	struct:sqlite3
lastRowid	vdbeInt.h	/^  i64 lastRowid;        \/* Last rowid from a Next or NextIdx operation *\/$/;"	m	struct:Cursor
lastRowid	vdbeInt.h	/^  int lastRowid;    \/* Last insert rowid (sqlite3.lastRowid) *\/$/;"	m	struct:Context
last_insert_rowid	func.c	/^static void last_insert_rowid($/;"	f	file:
last_page	os_common.h	/^static int last_page = 0;$/;"	v
lastrule	tool/lemon.c	/^  struct rule *lastrule;     \/* Pointer to the most recently parsed rule *\/$/;"	m	struct:pstate	file:
leaf	btree.c	/^  u8 leaf;             \/* True if leaf flag is set *\/$/;"	m	struct:MemPage	file:
leafData	btree.c	/^  u8 leafData;         \/* True if tables stores data on leaves only *\/$/;"	m	struct:MemPage	file:
lemon	tool/lemon.c	/^struct lemon {$/;"	s	file:
len	tool/mkkeywordhash.c	/^  int len;             \/* Length of this keyword, not counting final \\000 *\/$/;"	m	struct:Keyword	file:
lengthFunc	func.c	/^static void lengthFunc($/;"	f	file:
lhs	lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	file:
lhs	parse.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	file:
lhs	tool/lemon.c	/^  struct symbol *lhs;        \/* Left-hand side of current rule *\/$/;"	m	struct:pstate	file:
lhs	tool/lemon.c	/^  struct symbol *lhs;      \/* Left-hand side of the rule *\/$/;"	m	struct:rule	file:
lhs	tool/lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	file:
lhsalias	tool/lemon.c	/^  char *lhsalias;            \/* Alias for the LHS *\/$/;"	m	struct:pstate	file:
lhsalias	tool/lemon.c	/^  char *lhsalias;          \/* Alias for the LHS (NULL if none) *\/$/;"	m	struct:rule	file:
likeFunc	func.c	/^static void likeFunc($/;"	f	file:
likeInfo	func.c	/^static const struct compareInfo likeInfo = { '%', '_',   0, 1 };$/;"	v	file:
line	tool/lemon.c	/^  int line;                \/* Line number at which code begins *\/$/;"	m	struct:rule	file:
local_getline	shell.c	/^static STRPTR local_getline(CONST_STRPTR zPrompt, FILE *in)$/;"	f	file:
local_getline	tclsqlite.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_ioerr	os_common.h	/^static void local_ioerr()$/;"	f
localtimeOffset	date.c	/^static double localtimeOffset(DateTime *p){$/;"	f	file:
lock	test/threadtest1.c	/^pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
lockBtree	btree.c	/^static int lockBtree(Btree *pBt){$/;"	f	file:
lockBtreeWithRetry	btree.c	/^static int lockBtreeWithRetry(Btree *pBt){$/;"	f	file:
lockHash	os_aros.c	/^static Hash lockHash = { SQLITE_HASH_BINARY, 0, 0, 0, 0, 0 };$/;"	v	file:
lockInfo	os_aros.c	/^struct lockInfo {$/;"	s	file:
lockKey	os_aros.c	/^struct lockKey {$/;"	s	file:
locktype	os_aros.c	/^	int locktype;        \/* One of SHARED_LOCK, RESERVED_LOCK etc. *\/$/;"	m	struct:lockInfo	file:
locktype	os_aros.h	/^	unsigned char locktype;   \/* The type of lock held on this fd *\/$/;"	m	struct:OsFile
locktypeName	os_aros.c	/^static const char * locktypeName(int locktype)$/;"	f	file:
lookahead	tool/lemon.c	/^    int lookahead;             \/* Value of the lookahead token *\/$/;"	m	struct:acttab::<anonymous>	file:
lookupName	expr.c	/^static int lookupName($/;"	f	file:
lowerFunc	func.c	/^static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
m	date.c	/^  int h, m;        \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
magic	sqliteInt.h	/^  int magic;                    \/* Magic number for detect library misuse *\/$/;"	m	struct:sqlite3
magic	vdbeInt.h	/^  int magic;              \/* Magic number for sanity checking *\/$/;"	m	struct:Vdbe
main	shell.c	/^int main(int argc, char **argv)$/;"	f
main	test/crashtest1.c	/^int main(int argc, char **argv){$/;"	f
main	test/threadtest1.c	/^int main(int argc, char **argv){$/;"	f
main	test/threadtest2.c	/^int main(int argc, char **argv){$/;"	f
main	tool/diffdb.c	/^int main(int argc, char **argv){$/;"	f
main	tool/lemon.c	/^int main(argc,argv)$/;"	f
main	tool/mkkeywordhash.c	/^int main(int argc, char **argv){$/;"	f
main	tool/showdb.c	/^int main(int argc, char **argv){$/;"	f
main	tool/showjournal.c	/^int main(int argc, char **argv){$/;"	f
mainPrompt	shell.c	/^static char mainPrompt[20];     \/* First line prompt. default: "sqlite> "*\/$/;"	v	file:
main_init	shell.c	/^void main_init(struct callback_data *data)$/;"	f
major	lempar.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
major	parse.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
major	tool/lempar.c	/^  int major;         \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
mask	parse.c	/^  struct {int value; int mask;} yy47;$/;"	m	file:
mask	tool/mkkeywordhash.c	/^  int mask;            \/* Code this keyword if non-zero *\/$/;"	m	struct:Keyword	file:
matchAll	func.c	/^  u8 matchAll;$/;"	m	struct:compareInfo	file:
matchOne	func.c	/^  u8 matchOne;$/;"	m	struct:compareInfo	file:
matchOrderbyToColumn	select.c	/^static int matchOrderbyToColumn($/;"	f	file:
matchSet	func.c	/^  u8 matchSet;$/;"	m	struct:compareInfo	file:
maxEmbedFrac	btree.c	/^  u8 maxEmbedFrac;      \/* Maximum payload as % of total page size *\/$/;"	m	struct:Btree	file:
maxLeaf	btree.c	/^  int maxLeaf;          \/* Maximum local payload in a LEAFDATA table *\/$/;"	m	struct:Btree	file:
maxLocal	btree.c	/^  int maxLocal;         \/* Maximum local payload in non-LEAFDATA tables *\/$/;"	m	struct:Btree	file:
maxLocal	btree.c	/^  u16 maxLocal;        \/* Copy of Btree.maxLocal or Btree.maxLeaf *\/$/;"	m	struct:MemPage	file:
maxStmt	tclsqlite.c	/^  int maxStmt;               \/* The next maximum number of stmtList *\/$/;"	m	struct:SqliteDb	file:
md5_cmd	md5.c	/^static int md5_cmd(void*cd, Tcl_Interp *interp, int argc, const char **argv)$/;"	f	file:
md5file_cmd	md5.c	/^static int md5file_cmd(void*cd, Tcl_Interp*interp, int argc, const char **argv)$/;"	f	file:
md5finalize	md5.c	/^static void md5finalize(sqlite3_context *context)$/;"	f	file:
md5step	md5.c	/^static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv)$/;"	f	file:
memDb	pager.c	/^  u8 memDb;                   \/* True to inhibit all file I\/O *\/$/;"	m	struct:Pager	file:
memcnt	util.c	/^static int memcnt = 0;$/;"	v	file:
memleak_check	test/tester.tcl	/^proc memleak_check {} {$/;"	p
memoryTruncate	pager.c	/^static void memoryTruncate(Pager *pPager){$/;"	f	file:
memoryTruncate	pager.c	1864;"	d	file:
memory_error	tool/lemon.c	/^void memory_error(){$/;"	f
merge	tool/lemon.c	/^static char *merge(a,b,cmp,offset)$/;"	f	file:
message	tool/lemon.c	/^  char *message;$/;"	m	struct:s_options	file:
might	www/faq.tcl	/^  processes might try to access the file at the same time.  On Windows,$/;"	p
might	www/lockingv3.tcl	/^process might result in the journal file being dropped from the directory and$/;"	p
minEmbedFrac	btree.c	/^  u8 minEmbedFrac;      \/* Minimum payload as % of total page size *\/$/;"	m	struct:Btree	file:
minLeaf	btree.c	/^  int minLeaf;          \/* Minimum local payload in a LEAFDATA table *\/$/;"	m	struct:Btree	file:
minLeafFrac	btree.c	/^  u8 minLeafFrac;       \/* Minimum leaf payload as % of total page size *\/$/;"	m	struct:Btree	file:
minLocal	btree.c	/^  int minLocal;         \/* Minimum local payload in non-LEAFDATA tables *\/$/;"	m	struct:Btree	file:
minLocal	btree.c	/^  u16 minLocal;        \/* Copy of Btree.minLocal or Btree.minLeaf *\/$/;"	m	struct:MemPage	file:
minMaxFinalize	func.c	/^static void minMaxFinalize(sqlite3_context *context){$/;"	f	file:
minimum_size_type	tool/lemon.c	/^static const char *minimum_size_type(int lwr, int upr){$/;"	f	file:
minmaxFunc	func.c	/^static void minmaxFunc($/;"	f	file:
minmaxStep	func.c	/^static void minmaxStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
minor	lempar.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
minor	parse.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
minor	tool/lempar.c	/^  YYMINORTYPE minor; \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
mnAction	tool/lemon.c	/^  int mnAction;                \/* Action associated with mnLookahead *\/$/;"	m	struct:acttab	file:
mnLookahead	tool/lemon.c	/^  int mnLookahead;             \/* Minimum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mode	shell.c	/^	int mode;			\/* An output mode setting *\/$/;"	m	struct:callback_data	file:
mode	shell.c	/^	int mode;$/;"	m	struct:previous_mode_data	file:
modeDescr	shell.c	/^char *modeDescr[MODE_NUM_OF] = {$/;"	v
modifyPagePointer	btree.c	/^static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){$/;"	f	file:
mout	printf.c	/^static void mout(void *arg, const char *zNewText, int nNewChar)$/;"	f	file:
moveToChild	btree.c	/^static int moveToChild(BtCursor *pCur, u32 newPgno){$/;"	f	file:
moveToLeftmost	btree.c	/^static int moveToLeftmost(BtCursor *pCur){$/;"	f	file:
moveToParent	btree.c	/^static void moveToParent(BtCursor *pCur){$/;"	f	file:
moveToRightmost	btree.c	/^static int moveToRightmost(BtCursor *pCur){$/;"	f	file:
moveToRoot	btree.c	/^static int moveToRoot(BtCursor *pCur){$/;"	f	file:
movetoTarget	vdbeInt.h	/^  i64 movetoTarget;     \/* Argument to the deferred sqlite3BtreeMoveto() *\/$/;"	m	struct:Cursor
msort	tool/lemon.c	/^char *msort(list,next,cmp)$/;"	f
multiSelect	select.c	/^static int multiSelect($/;"	f	file:
multiSelectCollSeq	select.c	/^static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){$/;"	f	file:
multiSelectOpenTempAddr	select.c	/^static int multiSelectOpenTempAddr(Select *p, int addr){$/;"	f	file:
mxLookahead	tool/lemon.c	/^  int mxLookahead;             \/* Maximum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mxPage	pager.c	/^  int mxPage;                 \/* Maximum number of pages to hold in cache *\/$/;"	m	struct:Pager	file:
mxPage	tool/showdb.c	/^static int mxPage = 0;$/;"	v	file:
mxPage	tool/showjournal.c	/^static int mxPage = 0;$/;"	v	file:
myassert	tool/lemon.c	/^void myassert(file,line)$/;"	f
n	func.c	/^  int n;$/;"	m	struct:CountCtx	file:
n	sqliteInt.h	/^  unsigned n    : 31;     \/* Number of characters in this token *\/$/;"	m	struct:Token
n	vdbeInt.h	/^  int n;              \/* Number of characters in string value, including '\\0' *\/$/;"	m	struct:Mem
n	where.c	/^  int n;                        \/* Number of assigned cursor values *\/$/;"	m	struct:ExprMaskSet	file:
nAction	tool/lemon.c	/^  int nAction;                 \/* Number of used slots in aAction[] *\/$/;"	m	struct:acttab	file:
nAction	tool/lemon.c	/^  int nAction;         \/* Number of actions *\/$/;"	m	struct:axset	file:
nActionAlloc	tool/lemon.c	/^  int nActionAlloc;            \/* Slots allocated for aAction[] *\/$/;"	m	struct:acttab	file:
nAgg	select.c	/^  int nAgg;$/;"	m	struct:AggregateInfo	file:
nAgg	sqliteInt.h	/^  int nAgg;            \/* Number of aggregate expressions *\/$/;"	m	struct:Parse
nAgg	vdbeInt.h	/^  int nAgg;               \/* Number of elements in apAgg *\/$/;"	m	struct:Vdbe
nAlloc	printf.c	/^	int  nAlloc;     \/* Amount of space allocated in zText *\/$/;"	m	struct:sgMprintf	file:
nAlloc	sqliteInt.h	/^  i16 nAlloc;      \/* Number of entries allocated in a[] below *\/$/;"	m	struct:SrcList
nAlloc	sqliteInt.h	/^  int nAlloc;            \/* Number of entries allocated below *\/$/;"	m	struct:ExprList
nAlloc	sqliteInt.h	/^  int nAlloc;      \/* Number of entries allocated for a[] below *\/$/;"	m	struct:IdList
nAlloc	table.c	/^  int nAlloc;$/;"	m	struct:TabResult	file:
nAlloc	test/threadtest1.c	/^  int nAlloc;         \/* Number of slots allocated for azElem[] *\/$/;"	m	struct:QueryResult	file:
nArg	sqliteInt.h	/^  int nArg;            \/* Number of arguments.  -1 means unlimited *\/$/;"	m	struct:FuncDef
nAux	vdbeInt.h	/^  int nAux;                     \/* Number of entries allocated for apAux[] *\/$/;"	m	struct:VdbeFunc
nBlk	os_test.h	/^  int nBlk;         \/* Size of apBlock. *\/$/;"	m	struct:OsTestFile
nCallback	vdbeInt.h	/^  int nCallback;          \/* Number of callbacks invoked so far *\/$/;"	m	struct:Vdbe
nCell	btree.c	/^  u16 nCell;           \/* Number of cells on this page, local and ovfl *\/$/;"	m	struct:MemPage	file:
nChange	sqliteInt.h	/^  int nChange;                  \/* Value returned by sqlite3_changes() *\/$/;"	m	struct:sqlite3
nChange	vdbeInt.h	/^  int nChange;            \/* Number of db changes made since last reset *\/$/;"	m	struct:Vdbe
nChange	vdbeInt.h	/^  int nChange;      \/* Statement changes (Vdbe.nChanges)     *\/$/;"	m	struct:Context
nChar	printf.c	/^	int  nChar;      \/* Length of the string so far *\/$/;"	m	struct:sgMprintf	file:
nCol	sqliteInt.h	/^  int nCol;         \/* Number of columns in this key *\/$/;"	m	struct:FKey
nCol	sqliteInt.h	/^  int nCol;        \/* Number of columns in this table *\/$/;"	m	struct:Table
nColumn	sqliteInt.h	/^  int nColumn;     \/* Number of columns in the table used by this index *\/$/;"	m	struct:Index
nColumn	table.c	/^  int nColumn;$/;"	m	struct:TabResult	file:
nCursor	vdbeInt.h	/^  int nCursor;        \/* Number of slots in apCsr[] *\/$/;"	m	struct:Vdbe
nData	btree.c	/^  u32 nData;     \/* Number of bytes of data *\/$/;"	m	struct:CellInfo	file:
nData	table.c	/^  int nData;$/;"	m	struct:TabResult	file:
nData	vdbeInt.h	/^  int nData;            \/* Number of bytes in pData *\/$/;"	m	struct:Cursor
nDb	sqliteInt.h	/^  int nDb;                      \/* Number of backends currently in use *\/$/;"	m	struct:sqlite3
nDefine	tool/lemon.c	/^static int nDefine = 0;      \/* Number of -D options on the command line *\/$/;"	v	file:
nDepth	sqliteInt.h	/^  int nDepth;          \/* Depth of subquery recursion. 1 for no recursion *\/$/;"	m	struct:NameContext
nElem	test/threadtest1.c	/^  int nElem;          \/* Number of used entries in azElem[] *\/$/;"	m	struct:QueryResult	file:
nErr	sqliteInt.h	/^  int nErr;            \/* Number of errors encountered while resolving names *\/$/;"	m	struct:NameContext
nErr	sqliteInt.h	/^  int nErr;            \/* Number of errors seen *\/$/;"	m	struct:Parse
nExpr	sqliteInt.h	/^  int nExpr;             \/* Number of expressions on the list *\/$/;"	m	struct:ExprList
nExtra	pager.c	/^  int nExtra;                 \/* Add this many bytes to each in-memory page *\/$/;"	m	struct:Pager	file:
nField	sqliteInt.h	/^  int nField;         \/* Number of entries in aColl[] *\/$/;"	m	struct:KeyInfo
nField	vdbeInt.h	/^  int nField;           \/* Number of fields in the header *\/$/;"	m	struct:Cursor
nFree	btree.c	/^  u16 nFree;           \/* Number of free bytes on the page *\/$/;"	m	struct:MemPage	file:
nHeader	btree.c	/^  u16 nHeader;   \/* Size of the cell content header in bytes *\/$/;"	m	struct:CellInfo	file:
nHit	pager.c	/^  int nHit, nMiss, nOvfl;     \/* Cache hits, missing, and LRU overflows *\/$/;"	m	struct:Pager	file:
nId	sqliteInt.h	/^  int nId;         \/* Number of identifiers on the list *\/$/;"	m	struct:IdList
nKey	btree.c	/^  i64 nKey;      \/* The key for INTKEY tables, or number of bytes in key *\/$/;"	m	struct:CellInfo	file:
nKey	hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
nKey	vdbeInt.h	/^  int nKey;            \/* Number of bytes in the key, including '\\0' at end *\/$/;"	m	struct:AggElem
nKey	vdbeInt.h	/^  int nKey;           \/* Number of bytes in the key *\/$/;"	m	struct:Sorter
nKey	vdbeInt.h	/^  int nKey;         \/* Number of slots in aKey[] *\/$/;"	m	struct:Keylist
nLabel	vdbeInt.h	/^  int nLabel;         \/* Number of labels used *\/$/;"	m	struct:Vdbe
nLabelAlloc	vdbeInt.h	/^  int nLabelAlloc;    \/* Number of slots allocated in aLabel[] *\/$/;"	m	struct:Vdbe
nLevel	sqliteInt.h	/^  int nLevel;          \/* Number of nested loop *\/$/;"	m	struct:WhereInfo
nLocal	btree.c	/^  u16 nLocal;    \/* Amount of payload held locally *\/$/;"	m	struct:CellInfo	file:
nLock	os_aros.c	/^	int nLock;            \/* Number of outstanding locks *\/$/;"	m	struct:openCnt	file:
nLookahead	tool/lemon.c	/^  int nLookahead;              \/* Used slots in aLookahead[] *\/$/;"	m	struct:acttab	file:
nLookaheadAlloc	tool/lemon.c	/^  int nLookaheadAlloc;         \/* Slots allocated in aLookahead[] *\/$/;"	m	struct:acttab	file:
nMaxDepth	sqliteInt.h	/^  int nMaxDepth;       \/* Maximum depth of subquery recursion *\/$/;"	m	struct:Parse
nMaxPage	pager.c	/^  int nMaxPage;               \/* High water mark of nPage *\/$/;"	m	struct:Pager	file:
nMaxWrite	os_test.h	/^  int nMaxWrite;    \/* Largest offset written to. *\/$/;"	m	struct:OsTestFile
nMem	sqliteInt.h	/^  int nMem;            \/* Number of memory cells used so far *\/$/;"	m	struct:Parse
nMem	vdbeInt.h	/^  int nMem;               \/* Number of memory locations currently allocated *\/$/;"	m	struct:Vdbe
nMem	vdbeInt.h	/^  int nMem;            \/* Number of values stored in each AggElem *\/$/;"	m	struct:Agg
nMiss	pager.c	/^  int nHit, nMiss, nOvfl;     \/* Cache hits, missing, and LRU overflows *\/$/;"	m	struct:Pager	file:
nNtAct	tool/lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nOp	vdbeInt.h	/^  int nOp;            \/* Number of instructions in the program *\/$/;"	m	struct:Vdbe
nOpAlloc	vdbeInt.h	/^  int nOpAlloc;       \/* Number of slots allocated for aOp[] *\/$/;"	m	struct:Vdbe
nOverflow	btree.c	/^  u8 nOverflow;        \/* Number of overflow cell bodies in aCell[] *\/$/;"	m	struct:MemPage	file:
nOvfl	pager.c	/^  int nHit, nMiss, nOvfl;     \/* Cache hits, missing, and LRU overflows *\/$/;"	m	struct:Pager	file:
nPage	btree.c	/^	int nPage;     \/* Number of pages in the database *\/$/;"	m	struct:IntegrityCk	file:
nPage	pager.c	/^  int nPage;                  \/* Total number of in-memory pages *\/$/;"	m	struct:Pager	file:
nPending	os_aros.c	/^	int nPending;         \/* Number of pending close() operations *\/$/;"	m	struct:openCnt	file:
nProgressOps	sqliteInt.h	/^  int nProgressOps;             \/* Number of opcodes for progress callback *\/$/;"	m	struct:sqlite3
nRead	pager.c	/^  int nRead,nWrite;           \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
nRead	vdbeInt.h	/^  int nRead;        \/* Next unread slot in aKey[] *\/$/;"	m	struct:Keylist
nRec	pager.c	/^  int nRec;                   \/* Number of pages written to the journal *\/$/;"	m	struct:Pager	file:
nRef	os_aros.c	/^	int nRef;             \/* Number of pointers to this structure *\/$/;"	m	struct:openCnt	file:
nRef	os_aros.c	/^	int nRef;            \/* Number of pointers to this structure *\/$/;"	m	struct:lockInfo	file:
nRef	pager.c	/^  int nRef;                   \/* Number of in-memory pages with PgHdr.nRef>0 *\/$/;"	m	struct:Pager	file:
nRef	pager.c	/^  short int nRef;                \/* Number of users of this page *\/$/;"	m	struct:PgHdr	file:
nRef	sqliteInt.h	/^  int nRef;            \/* Number of names resolved by this context *\/$/;"	m	struct:NameContext
nRef	sqliteInt.h	/^  int nRef;          \/* Number of pointers to this Table *\/$/;"	m	struct:Table
nResColumn	vdbeInt.h	/^  int nResColumn;         \/* Number of columns in one row of the result set *\/$/;"	m	struct:Vdbe
nResult	table.c	/^  int nResult;$/;"	m	struct:TabResult	file:
nRow	table.c	/^  int nRow;$/;"	m	struct:TabResult	file:
nSet	sqliteInt.h	/^  int nSet;            \/* Number of sets used so far *\/$/;"	m	struct:Parse
nSize	btree.c	/^  u16 nSize;     \/* Size of the cell content on the main b-tree page *\/$/;"	m	struct:CellInfo	file:
nSql	tclsqlite.c	/^  int nSql;                \/* chars in zSql[] *\/$/;"	m	struct:SqlPreparedStmt	file:
nSrc	sqliteInt.h	/^  i16 nSrc;        \/* Number of tables or subqueries in the FROM clause *\/$/;"	m	struct:SrcList
nStmt	tclsqlite.c	/^  int nStmt;                 \/* Number of statements in stmtList *\/$/;"	m	struct:SqliteDb	file:
nTab	sqliteInt.h	/^  int nTab;            \/* Number of previously allocated VDBE cursors *\/$/;"	m	struct:Parse
nTab	vdbeInt.h	/^  int nTab;            \/* Root page of the table in pBtree *\/$/;"	m	struct:Agg
nTable	sqliteInt.h	/^  int nTable;                   \/* Number of tables in the database *\/$/;"	m	struct:sqlite3
nTknAct	tool/lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nTotal	printf.c	/^	int  nTotal;     \/* Output size if unconstrained *\/$/;"	m	struct:sgMprintf	file:
nTotalChange	sqliteInt.h	/^  int nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/$/;"	m	struct:sqlite3
nUsed	vdbeInt.h	/^  int nUsed;        \/* Next unwritten slot in aKey[] *\/$/;"	m	struct:Keylist
nVar	sqliteInt.h	/^  int nVar;            \/* Number of '?' variables seen in the SQL so far *\/$/;"	m	struct:Parse
nVar	vdbeInt.h	/^  int nVar;           \/* Number of entries in aVar[] *\/$/;"	m	struct:Vdbe
nVarExpr	sqliteInt.h	/^  int nVarExpr;        \/* Number of used slots in apVarExpr[] *\/$/;"	m	struct:Parse
nVarExprAlloc	sqliteInt.h	/^  int nVarExprAlloc;   \/* Number of allocated slots in apVarExpr[] *\/$/;"	m	struct:Parse
nWrite	pager.c	/^  int nRead,nWrite;           \/* Database pages read\/written *\/$/;"	m	struct:Pager	file:
name	sqliteInt.h	/^  char *name;             \/* The name of the trigger                        *\/$/;"	m	struct:Trigger
name	tool/lemon.c	/^  char *name;              \/* Name of the generated parser *\/$/;"	m	struct:lemon	file:
name	tool/lemon.c	/^  char *name;              \/* Name of the symbol *\/$/;"	m	struct:symbol	file:
nameClash	sqliteInt.h	/^  u8 nameClash;        \/* A permanent table name clashes with temp table name *\/$/;"	m	struct:Parse
nameResolverStep	expr.c	/^static int nameResolverStep(void *pArg, Expr *pExpr){$/;"	f	file:
nameToken	sqliteInt.h	/^  Token nameToken;        \/* Token containing zName. Use during parsing only *\/$/;"	m	struct:Trigger
nconflict	tool/lemon.c	/^  int nconflict;           \/* Number of parsing conflicts *\/$/;"	m	struct:lemon	file:
needCollSeq	sqliteInt.h	/^  u8 needCollSeq;      \/* True if sqlite3GetFuncCollSeq() might be called *\/$/;"	m	struct:FuncDef
needSync	pager.c	/^  u8 needSync;                   \/* Sync journal before writing this page *\/$/;"	m	struct:PgHdr	file:
needSync	pager.c	/^  u8 needSync;                \/* True if an fsync() is needed on the journal *\/$/;"	m	struct:Pager	file:
nested	sqliteInt.h	/^  u8 nested;           \/* Number of nested calls to the parser\/code generator *\/$/;"	m	struct:Parse
newDatabase	btree.c	/^static int newDatabase(Btree *pBt){$/;"	f	file:
newIdx	sqliteInt.h	/^  int newIdx;          \/* Index of vdbe cursor to "new" temp table *\/$/;"	m	struct:TriggerStack
newTnum	sqliteInt.h	/^    int newTnum;                \/* Rootpage of table being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
newconfig	tool/lemon.c	/^PRIVATE struct config *newconfig(){$/;"	f
newsitem	www/index.tcl	/^proc newsitem {date title text} {$/;"	p
newsitem	www/oldnews.tcl	/^proc newsitem {date title text} {$/;"	p
next	hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
next	tool/lemon.c	/^  struct action *next;     \/* Next action for this state *\/$/;"	m	struct:action	file:
next	tool/lemon.c	/^  struct config *next;     \/* Next configuration in the state *\/$/;"	m	struct:config	file:
next	tool/lemon.c	/^  struct plink *next;      \/* The next propagate link *\/$/;"	m	struct:plink	file:
next	tool/lemon.c	/^  struct rule *next;       \/* Next rule in the global list *\/$/;"	m	struct:rule	file:
next	tool/lemon.c	/^  struct s_x1node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x1node	file:
next	tool/lemon.c	/^  struct s_x2node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x2node	file:
next	tool/lemon.c	/^  struct s_x3node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x3node	file:
next	tool/lemon.c	/^  struct s_x4node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x4node	file:
nextRowid	vdbeInt.h	/^  i64 nextRowid;        \/* Next rowid returned by OP_NewRowid *\/$/;"	m	struct:Cursor
nextRowidValid	vdbeInt.h	/^  Bool nextRowidValid;  \/* True if the nextRowid field is valid *\/$/;"	m	struct:Cursor
nextlhs	tool/lemon.c	/^  struct rule *nextlhs;    \/* Next rule with the same LHS *\/$/;"	m	struct:rule	file:
noCase	func.c	/^  u8 noCase;$/;"	m	struct:compareInfo	file:
noReadlock	pager.c	/^  u8 noReadlock;              \/* Do not bother to obtain readlocks *\/$/;"	m	struct:Pager	file:
noSync	pager.c	/^  u8 noSync;                  \/* Do not sync the journal if true *\/$/;"	m	struct:Pager	file:
nocaseCollatingFunc	main.c	/^static int nocaseCollatingFunc($/;"	f	file:
nocase_compare	www/tclsqlite.tcl	/^proc nocase_compare {a b} {<br>$/;"	p
not	parse.c	/^  int not;         \/* True if the NOT keyword is present *\/$/;"	m	struct:LikeOp	file:
notNull	sqliteInt.h	/^  u8 notNull;      \/* True if there is a NOT NULL constraint *\/$/;"	m	struct:Column
nrhs	lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	file:
nrhs	parse.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	file:
nrhs	tool/lemon.c	/^  int nrhs;                  \/* Number of right-hand side symbols seen *\/$/;"	m	struct:pstate	file:
nrhs	tool/lemon.c	/^  int nrhs;                \/* Number of RHS symbols *\/$/;"	m	struct:rule	file:
nrhs	tool/lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	file:
nrule	tool/lemon.c	/^  int nrule;               \/* Number of rules *\/$/;"	m	struct:lemon	file:
nstate	tool/lemon.c	/^  int nstate;              \/* Number of states *\/$/;"	m	struct:lemon	file:
nsymbol	tool/lemon.c	/^  int nsymbol;             \/* Number of terminal and nonterminal symbols *\/$/;"	m	struct:lemon	file:
nterminal	tool/lemon.c	/^  int nterminal;           \/* Number of terminal symbols *\/$/;"	m	struct:lemon	file:
nullRow	vdbeInt.h	/^  Bool nullRow;         \/* True if pointing to a row with no data *\/$/;"	m	struct:Cursor
nullifFunc	func.c	/^static void nullifFunc($/;"	f	file:
nullvalue	shell.c	/^	char nullvalue[20];	\/* The text to print when a NULL comes back from$/;"	m	struct:callback_data	file:
number_name	tool/speedtest.tcl	/^proc number_name {n} {$/;"	p
number_name	tool/speedtest2.tcl	/^proc number_name {n} {$/;"	p
offset	tool/mkkeywordhash.c	/^  int offset;          \/* Offset to start of name string *\/$/;"	m	struct:Keyword	file:
offsetof	sqliteInt.h	152;"	d
okVar	vdbeInt.h	/^  int okVar;          \/* True if azVar[] has been initialized *\/$/;"	m	struct:Vdbe
oldIdx	sqliteInt.h	/^  int oldIdx;          \/* Index of vdbe cursor to "old" temp table *\/$/;"	m	struct:TriggerStack
on	www/lang.tcl	/^process on an attached database file.<\/p>$/;"	p
onError	sqliteInt.h	/^  u8 onError;      \/* OE_Abort, OE_Ignore, OE_Replace, or OE_None *\/$/;"	m	struct:Index
one_input_line	shell.c	/^static STRPTR one_input_line(CONST_STRPTR zPrior, FILE *in)$/;"	f	file:
op	sqliteInt.h	/^  int op, p1, p2;      \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
op	sqliteInt.h	/^  int op;              \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT *\/$/;"	m	struct:TriggerStep
op	sqliteInt.h	/^  u8 op;                  \/* One of TK_DELETE, TK_UPDATE, TK_INSERT         *\/$/;"	m	struct:Trigger
op	sqliteInt.h	/^  u8 op;                 \/* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT *\/$/;"	m	struct:Select
op	sqliteInt.h	/^  u8 op;                 \/* Operation performed by this node *\/$/;"	m	struct:Expr
op	tool/lemon.c	/^static struct s_options *op;$/;"	v	file:
opcode	vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOp
opcode	vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOpList
opcodeNoPush	vdbeaux.c	/^static int opcodeNoPush(u8 op){$/;"	f	file:
openCnt	os_aros.c	/^struct openCnt {$/;"	s	file:
openDatabase	main.c	/^static int openDatabase($/;"	f	file:
openHash	os_aros.c	/^static Hash openHash = { SQLITE_HASH_BINARY, 0, 0, 0, 0, 0 };$/;"	v	file:
openKey	os_aros.c	66;"	d	file:
openTempIndex	select.c	/^static int openTempIndex(Parse *pParse, Select *p, int iTab){$/;"	f	file:
open_db	shell.c	/^static void open_db(struct callback_data *p)$/;"	f	file:
operator	parse.c	/^  Token operator;  \/* "like" or "glob" or "regexp" *\/$/;"	m	struct:LikeOp	file:
orconf	sqliteInt.h	/^  int orconf;          \/* Current orconf policy *\/$/;"	m	struct:TriggerStack
orconf	sqliteInt.h	/^  int orconf;          \/* OE_Rollback etc. *\/$/;"	m	struct:TriggerStep
origDbSize	pager.c	/^  int origDbSize;             \/* dbSize before the current change *\/$/;"	m	struct:Pager	file:
osTell	os_test.c	/^static i64 osTell(OsTestFile *pFile){$/;"	f	file:
out	shell.c	/^	FILE *out;			\/* Write results here *\/$/;"	m	struct:callback_data	file:
out_of_memory	tool/showdb.c	/^static void out_of_memory(void){$/;"	f	file:
out_of_memory	tool/showjournal.c	/^static void out_of_memory(void){$/;"	f	file:
outfile	shell.c	/^	char outfile[FILENAME_MAX]; \/* Filename for *out *\/$/;"	m	struct:callback_data	file:
outname	tool/lemon.c	/^  char *outname;           \/* Name of the current output file *\/$/;"	m	struct:lemon	file:
output_c_string	shell.c	/^static void output_c_string(FILE *out, const char *z)$/;"	f	file:
output_csv	shell.c	/^static void output_csv(struct callback_data *p, const char *z, int bSep)$/;"	f	file:
output_html_string	shell.c	/^static void output_html_string(FILE *out, const char *z)$/;"	f	file:
output_quoted_string	shell.c	/^static void output_quoted_string(FILE *out, const char *z)$/;"	f	file:
overflow	tool/lemon.c	/^  char *overflow;          \/* Code to execute on a stack overflow *\/$/;"	m	struct:lemon	file:
overflowln	tool/lemon.c	/^  int  overflowln;         \/* Line number for start of overflow code *\/$/;"	m	struct:lemon	file:
p	where.c	/^  Expr *p;                \/* Pointer to the subexpression *\/$/;"	m	struct:ExprInfo	file:
p1	sqliteInt.h	/^  int op, p1, p2;      \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p1	vdbe.h	/^  int p1;             \/* First operand *\/$/;"	m	struct:VdbeOp
p1	vdbe.h	/^  signed char p1;     \/* First operand *\/$/;"	m	struct:VdbeOpList
p2	sqliteInt.h	/^  int op, p1, p2;      \/* Opcode used to terminate the loop *\/$/;"	m	struct:WhereLevel
p2	vdbe.h	/^  int p2;             \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOp
p2	vdbe.h	/^  short int p2;       \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOpList
p3	vdbe.h	/^  char *p3;           \/* Third parameter *\/$/;"	m	struct:VdbeOp
p3	vdbe.h	/^  char *p3;           \/* Third parameter *\/$/;"	m	struct:VdbeOpList
p3type	vdbe.h	/^  int p3type;         \/* One of the P3_xxx constants defined below *\/$/;"	m	struct:VdbeOp
pAgg	vdbeInt.h	/^  Agg *pAgg;              \/* Current aggregate context *\/$/;"	m	struct:Vdbe
pAgg	vdbeInt.h	/^  void *pAgg;       \/* Aggregate context *\/$/;"	m	struct:sqlite3_context
pAll	pager.c	/^  PgHdr *pAll;                \/* List of all pages *\/$/;"	m	struct:Pager	file:
pAllFiles	os_test.c	/^static OsTestFile *pAllFiles = 0;$/;"	v	file:
pArg	btree.c	/^  void *pArg;               \/* First arg to xCompare() *\/$/;"	m	struct:BtCursor	file:
pArg	sqliteInt.h	/^  void *pArg;                \/* First arg to busy callback *\/$/;"	m	struct:BusyHandler
pAuthArg	sqliteInt.h	/^  void *pAuthArg;               \/* 1st argument to the access auth function *\/$/;"	m	struct:sqlite3
pAux	sqliteInt.h	/^	void *pAux;               \/* Auxiliary data.  Usually NULL *\/$/;"	m	struct:Db
pAux	vdbeInt.h	/^    void *pAux;                   \/* Aux data for the i-th argument *\/$/;"	m	struct:VdbeFunc::AuxData
pBt	btree.c	/^	Btree *pBt;    \/* The tree being checked out *\/$/;"	m	struct:IntegrityCk	file:
pBt	btree.c	/^  Btree *pBt;               \/* The Btree to which this cursor belongs *\/$/;"	m	struct:BtCursor	file:
pBt	btree.c	/^  struct Btree *pBt;   \/* Pointer back to BTree structure *\/$/;"	m	struct:MemPage	file:
pBt	sqliteInt.h	/^	Btree *pBt;          \/* The B*Tree structure for this database file *\/$/;"	m	struct:Db
pBt	vdbeInt.h	/^  Btree *pBt;           \/* Separate file holding temporary table *\/$/;"	m	struct:Cursor
pBtree	vdbeInt.h	/^  Btree *pBtree;       \/* The tmp. btree used to group elements, if required. *\/$/;"	m	struct:Agg
pBusyHandler	btree.c	/^  BusyHandler *pBusyHandler;   \/* Callback for when there is lock contention *\/$/;"	m	struct:Btree	file:
pBusyHandler	pager.c	/^  BusyHandler *pBusyHandler;  \/* Pointer to sqlite.busyHandler *\/$/;"	m	struct:Pager	file:
pCell	btree.c	/^    u8 *pCell;           \/* Pointers to the body of the overflow cell *\/$/;"	m	struct:MemPage::_OvflCell	file:
pCell	btree.c	/^  u8 *pCell;     \/* Pointer to the start of cell content *\/$/;"	m	struct:CellInfo	file:
pCodecArg	pager.c	/^  void *pCodecArg;            \/* First argument to xCodec() *\/$/;"	m	struct:Pager	file:
pColl	sqliteInt.h	/^  CollSeq *pColl;        \/* The collation type of the column or 0 *\/$/;"	m	struct:Expr
pColl	sqliteInt.h	/^  CollSeq *pColl;  \/* Collating sequence.  If NULL, use the default *\/$/;"	m	struct:Column
pColl	vdbeInt.h	/^  CollSeq *pColl;$/;"	m	struct:sqlite3_context
pCollNeededArg	sqliteInt.h	/^  void *pCollNeededArg;$/;"	m	struct:sqlite3
pCollate	tclsqlite.c	/^  SqlCollate *pCollate; \/* List of SQL collation functions *\/$/;"	m	struct:SqliteDb	file:
pCollateNeeded	tclsqlite.c	/^  Tcl_Obj *pCollateNeeded;  \/* Collation needed script *\/$/;"	m	struct:SqliteDb	file:
pColumns	sqliteInt.h	/^  IdList *pColumns;       \/* If this is an UPDATE OF <column-list> trigger,$/;"	m	struct:Trigger
pCommitArg	sqliteInt.h	/^  void *pCommitArg;             \/* Argument to xCommitCallback() *\/   $/;"	m	struct:sqlite3
pCsr	vdbeInt.h	/^  BtCursor *pCsr;      \/* Read\/write cursor to the table in pBtree *\/$/;"	m	struct:Agg
pCurrent	vdbeInt.h	/^  AggElem *pCurrent;   \/* The AggElem currently in focus *\/$/;"	m	struct:Agg
pCursor	btree.c	/^  BtCursor *pCursor;    \/* A list of all open cursors *\/$/;"	m	struct:Btree	file:
pCursor	vdbeInt.h	/^  BtCursor *pCursor;    \/* The cursor structure of the backend *\/$/;"	m	struct:Cursor
pData	vdbeInt.h	/^  char *pData;          \/* Data for a NEW or OLD pseudo-table *\/$/;"	m	struct:Cursor
pDbList	main.c	/^static sqlite3 *pDbList = 0;$/;"	v	file:
pDflt	sqliteInt.h	/^  Expr *pDflt;     \/* Default value of this column *\/$/;"	m	struct:Column
pDfltColl	sqliteInt.h	/^  CollSeq *pDfltColl;           \/* The default collating sequence (BINARY) *\/$/;"	m	struct:sqlite3
pDirty	pager.c	/^  PgHdr *pDirty;                 \/* Dirty pages sorted by PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pEList	sqliteInt.h	/^  ExprList *pEList;      \/* The fields of the result *\/$/;"	m	struct:Select
pEList	sqliteInt.h	/^  ExprList *pEList;    \/* Optional list of named expressions *\/$/;"	m	struct:NameContext
pErr	sqliteInt.h	/^  sqlite3_value *pErr;          \/* Most recent error message *\/$/;"	m	struct:sqlite3
pExpr	sqliteInt.h	/^    Expr *pExpr;           \/* The list of expressions *\/$/;"	m	struct:ExprList::ExprList_item
pExpr	sqliteInt.h	/^  Expr *pExpr;      \/* The expression *\/$/;"	m	struct:AggExpr
pExprList	sqliteInt.h	/^  ExprList *pExprList; \/* Valid for UPDATE statements and sometimes $/;"	m	struct:TriggerStep
pFKey	sqliteInt.h	/^  FKey *pFKey;       \/* Linked list of all foreign keys in this table *\/$/;"	m	struct:Table
pFetch	sqliteInt.h	/^  sqlite3_stmt *pFetch;         \/* Used by SSE to fetch stored statements *\/$/;"	m	struct:sqlite3
pFirst	pager.c	/^  PgHdr *pFirst, *pLast;      \/* List of free pages *\/$/;"	m	struct:Pager	file:
pFirstSynced	pager.c	/^  PgHdr *pFirstSynced;        \/* First free page with PgHdr.needSync==0 *\/$/;"	m	struct:Pager	file:
pFrom	sqliteInt.h	/^  Table *pFrom;     \/* The table that constains the REFERENCES clause *\/$/;"	m	struct:FKey
pFunc	sqliteInt.h	/^  FuncDef *pFunc;   \/* Information about the aggregate function *\/$/;"	m	struct:AggExpr
pFunc	tclsqlite.c	/^  SqlFunc *pFunc;       \/* List of SQL functions *\/$/;"	m	struct:SqliteDb	file:
pFunc	vdbeInt.h	/^  FuncDef *pFunc;               \/* The definition of the function *\/$/;"	m	struct:VdbeFunc
pFunc	vdbeInt.h	/^  FuncDef *pFunc;   \/* Pointer to function information.  MUST BE FIRST *\/$/;"	m	struct:sqlite3_context
pGroupBy	sqliteInt.h	/^  ExprList *pGroupBy;    \/* The GROUP BY clause *\/$/;"	m	struct:Select
pHaving	sqliteInt.h	/^  Expr *pHaving;         \/* The HAVING clause *\/$/;"	m	struct:Select
pIdList	sqliteInt.h	/^  IdList *pIdList;     \/* Valid for INSERT statements only *\/$/;"	m	struct:TriggerStep
pIdx	sqliteInt.h	/^  Index *pIdx;         \/* Index used.  NULL if no index *\/$/;"	m	struct:WhereLevel
pIncrKey	vdbeInt.h	/^  u8 *pIncrKey;         \/* Pointer to pKeyInfo->incrKey *\/$/;"	m	struct:Cursor
pIndex	sqliteInt.h	/^  Index *pIndex;   \/* List of SQL indexes on this table. *\/$/;"	m	struct:Table
pKey	hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
pKeyInfo	vdbeInt.h	/^  KeyInfo *pKeyInfo;    \/* Info about index keys needed by index cursors *\/$/;"	m	struct:Cursor
pLast	pager.c	/^  PgHdr *pFirst, *pLast;      \/* List of free pages *\/$/;"	m	struct:Pager	file:
pLeft	sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pLimit	parse.c	/^  Expr *pLimit;    \/* The LIMIT expression.  NULL if there is no limit *\/$/;"	m	struct:LimitVal	file:
pLimit	sqliteInt.h	/^  Expr *pLimit;          \/* LIMIT expression. NULL means not used. *\/$/;"	m	struct:Select
pList	sqliteInt.h	/^  ExprList *pList;       \/* A list of expressions used as function arguments$/;"	m	struct:Expr
pList	vdbeInt.h	/^  Keylist *pList;         \/* A list of ROWIDs *\/$/;"	m	struct:Vdbe
pList	vdbeInt.h	/^  Keylist *pList;   \/* Records that will participate in a DELETE or UPDATE *\/$/;"	m	struct:Context
pLock	os_aros.h	/^	struct lockInfo *pLock;   \/* Info about locks on this inode *\/$/;"	m	struct:OsFile
pNC	expr.c	/^  NameContext *pNC;    \/* Namespace of first enclosing query *\/$/;"	m	struct:QueryCoder	file:
pName	sqliteInt.h	/^  const Token *pName; \/* Name of the container - used for error messages *\/$/;"	m	struct:DbFixer
pNewTable	sqliteInt.h	/^  Table *pNewTable;    \/* A table being constructed by CREATE TABLE *\/$/;"	m	struct:Parse
pNewTrigger	sqliteInt.h	/^  Trigger *pNewTrigger;     \/* Trigger under construct by a CREATE TRIGGER *\/$/;"	m	struct:Parse
pNext	btree.c	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor	file:
pNext	os_test.h	/^  OsTestFile *pNext;$/;"	m	struct:OsTestFile
pNext	sqliteInt.h	/^  FuncDef *pNext;      \/* Next function with same name *\/$/;"	m	struct:FuncDef
pNext	sqliteInt.h	/^  Index *pNext;    \/* The next index associated with the same table *\/$/;"	m	struct:Index
pNext	sqliteInt.h	/^  NameContext *pNext;  \/* Next outer name context.  NULL for outermost *\/$/;"	m	struct:NameContext
pNext	sqliteInt.h	/^  Trigger *pNext;         \/* Next trigger associated with the table *\/$/;"	m	struct:Trigger
pNext	sqliteInt.h	/^  TriggerStack *pNext; \/* Next trigger down on the trigger stack *\/$/;"	m	struct:TriggerStack
pNext	sqliteInt.h	/^  TriggerStep * pNext; \/* Next in the link-list *\/$/;"	m	struct:TriggerStep
pNext	sqliteInt.h	/^  sqlite3 *pNext;               \/* Linked list of open db handles. *\/$/;"	m	struct:sqlite3
pNext	tclsqlite.c	/^  SqlCollate *pNext;       \/* Next function on the list of them all *\/$/;"	m	struct:SqlCollate	file:
pNext	tclsqlite.c	/^  SqlFunc *pNext;       \/* Next function on the list of them all *\/$/;"	m	struct:SqlFunc	file:
pNext	tclsqlite.c	/^  SqlPreparedStmt *pNext;  \/* Next in linked list *\/$/;"	m	struct:SqlPreparedStmt	file:
pNext	vdbeInt.h	/^  Keylist *pNext;   \/* Next block of keys *\/$/;"	m	struct:Keylist
pNext	vdbeInt.h	/^  Sorter *pNext;      \/* Next in the list *\/$/;"	m	struct:Sorter
pNext	vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pNextAll	pager.c	/^  PgHdr *pNextAll;               \/* A list of all pages *\/$/;"	m	struct:PgHdr	file:
pNextFree	pager.c	/^  PgHdr *pNextFree, *pPrevFree;  \/* Freelist of pages where nRef==0 *\/$/;"	m	struct:PgHdr	file:
pNextFrom	sqliteInt.h	/^  FKey *pNextFrom;  \/* Next foreign key in pFrom *\/$/;"	m	struct:FKey
pNextHash	pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pNextStmt	pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHdr	file:
pNextTo	sqliteInt.h	/^  FKey *pNextTo;    \/* Next foreign key that points to zTo *\/$/;"	m	struct:FKey
pOffset	parse.c	/^  Expr *pOffset;   \/* The OFFSET expression.  NULL if there is none *\/$/;"	m	struct:LimitVal	file:
pOffset	sqliteInt.h	/^  Expr *pOffset;         \/* OFFSET expression. NULL means not used. *\/$/;"	m	struct:Select
pOn	sqliteInt.h	/^    Expr *pOn;        \/* The ON clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pOpen	os_aros.h	/^	struct openCnt *pOpen;    \/* Info about all open fd's on this inode *\/$/;"	m	struct:OsFile
pOrderBy	sqliteInt.h	/^  ExprList *pOrderBy;    \/* The ORDER BY clause *\/$/;"	m	struct:Select
pOrig	pager.c	/^  u8 *pOrig;     \/* Original page text.  Restore to this on a full rollback *\/$/;"	m	struct:PgHistory	file:
pPage	btree.c	/^  MemPage *pPage;           \/* Page that contains the entry *\/$/;"	m	struct:BtCursor	file:
pPage1	btree.c	/^  MemPage *pPage1;      \/* First page of the database *\/$/;"	m	struct:Btree	file:
pPager	btree.c	/^	Pager *pPager; \/* The associated pager.  Also accessible by pBt->pPager *\/$/;"	m	struct:IntegrityCk	file:
pPager	btree.c	/^  Pager *pPager;        \/* The page cache *\/$/;"	m	struct:Btree	file:
pPager	os_aros.h	/^	struct Pager *pPager;     \/* The pager that owns this OsFile. Might be 0 *\/$/;"	m	struct:OsFile
pPager	pager.c	/^  Pager *pPager;                 \/* The pager to which this page belongs *\/$/;"	m	struct:PgHdr	file:
pParent	btree.c	/^  MemPage *pParent;    \/* The parent of this page.  NULL for root *\/$/;"	m	struct:MemPage	file:
pParse	expr.c	/^  Parse *pParse;       \/* The parsing context *\/$/;"	m	struct:QueryCoder	file:
pParse	sqliteInt.h	/^  Parse *pParse;              \/* The Parse structure *\/$/;"	m	struct:AuthContext
pParse	sqliteInt.h	/^  Parse *pParse;       \/* The parser *\/$/;"	m	struct:NameContext
pParse	sqliteInt.h	/^  Parse *pParse;      \/* The parsing context.  Error messages written here *\/$/;"	m	struct:DbFixer
pParse	sqliteInt.h	/^  Parse *pParse;$/;"	m	struct:WhereInfo
pPrev	btree.c	/^  BtCursor *pNext, *pPrev;  \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor	file:
pPrev	tclsqlite.c	/^  SqlPreparedStmt *pPrev;  \/* Previous on the list *\/$/;"	m	struct:SqlPreparedStmt	file:
pPrev	vdbeInt.h	/^  Vdbe *pPrev,*pNext; \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pPrevFree	pager.c	/^  PgHdr *pNextFree, *pPrevFree;  \/* Freelist of pages where nRef==0 *\/$/;"	m	struct:PgHdr	file:
pPrevHash	pager.c	/^  PgHdr *pNextHash, *pPrevHash;  \/* Hash collision chain for PgHdr.pgno *\/$/;"	m	struct:PgHdr	file:
pPrevStmt	pager.c	/^  PgHdr *pNextStmt, *pPrevStmt;  \/* List of pages in the statement journal *\/$/;"	m	struct:PgHdr	file:
pPrior	sqliteInt.h	/^  Select *pPrior;        \/* Prior select in a compound select statement *\/$/;"	m	struct:Select
pProgressArg	sqliteInt.h	/^  void *pProgressArg;           \/* Argument to the progress callback *\/$/;"	m	struct:sqlite3
pRight	sqliteInt.h	/^  Expr *pLeft, *pRight;  \/* Left and right subnodes *\/$/;"	m	struct:Expr
pSelect	sqliteInt.h	/^    Select *pSelect;  \/* A SELECT statement used in place of a table name *\/$/;"	m	struct:SrcList::SrcList_item
pSelect	sqliteInt.h	/^  Select *pSelect;       \/* When the expression is a sub-select.  Also the$/;"	m	struct:Expr
pSelect	sqliteInt.h	/^  Select *pSelect;     \/* Valid for SELECT and sometimes $/;"	m	struct:TriggerStep
pSelect	sqliteInt.h	/^  Select *pSelect; \/* NULL for tables.  Points to definition if a view. *\/$/;"	m	struct:Table
pSeqTab	sqliteInt.h	/^	Table *pSeqTab;      \/* The sqlite_sequence table used by AUTOINCREMENT *\/$/;"	m	struct:Db
pSort	vdbeInt.h	/^  Sorter *pSort;      \/* A linked list of objects to be sorted *\/$/;"	m	struct:Vdbe
pSortTail	vdbeInt.h	/^  Sorter *pSortTail;  \/* Last element on the pSort list *\/$/;"	m	struct:Vdbe
pSrc	sqliteInt.h	/^  SrcList *pSrc;         \/* The FROM clause *\/$/;"	m	struct:Select
pSrcList	sqliteInt.h	/^  SrcList *pSrcList;   \/* One or more tables used to resolve names *\/$/;"	m	struct:NameContext
pStmt	pager.c	/^  PgHdr *pStmt;               \/* List of pages in the statement subjournal *\/$/;"	m	struct:Pager	file:
pStmt	pager.c	/^  u8 *pStmt;     \/* Text as it was at the beginning of the current statement *\/$/;"	m	struct:PgHistory	file:
pStmt	tclsqlite.c	/^  sqlite3_stmt *pStmt;     \/* The prepared statement *\/$/;"	m	struct:SqlPreparedStmt	file:
pTab	sqliteInt.h	/^    Table *pTab;      \/* An SQL table corresponding to zName *\/$/;"	m	struct:SrcList::SrcList_item
pTab	sqliteInt.h	/^  Table *pTab;           \/* Table for OP_Column expressions. *\/$/;"	m	struct:Expr
pTab	sqliteInt.h	/^  Table *pTab;         \/* Table that triggers are currently being coded on *\/$/;"	m	struct:TriggerStack
pTabList	sqliteInt.h	/^  SrcList *pTabList;   \/* List of tables in the join *\/$/;"	m	struct:WhereInfo
pTable	sqliteInt.h	/^  Table *pTable;   \/* The SQL table being indexed *\/$/;"	m	struct:Index
pTos	vdbeInt.h	/^  Mem *pTos;          \/* Top entry in the operand stack *\/$/;"	m	struct:Vdbe
pTraceArg	sqliteInt.h	/^  void *pTraceArg;                       \/* Argument to the trace function *\/$/;"	m	struct:sqlite3
pTrig	sqliteInt.h	/^  Trigger *pTrig;      \/* The trigger that this step is a part of *\/$/;"	m	struct:TriggerStep
pTrigger	sqliteInt.h	/^  Trigger *pTrigger;   \/* The trigger currently being coded *\/$/;"	m	struct:TriggerStack
pTrigger	sqliteInt.h	/^  Trigger *pTrigger; \/* List of SQL triggers on this table *\/$/;"	m	struct:Table
pUser	sqliteInt.h	/^  void *pUser;         \/* First argument to xCmp() *\/$/;"	m	struct:CollSeq
pUserData	sqliteInt.h	/^  void *pUserData;     \/* User data parameter *\/$/;"	m	struct:FuncDef
pUsing	sqliteInt.h	/^    IdList *pUsing;   \/* The USING clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pValue	sqliteInt.h	/^  sqlite3_value *pValue;        \/* Value used for transient conversions *\/$/;"	m	struct:sqlite3
pVdbe	sqliteInt.h	/^  Vdbe *pVdbe;         \/* An engine for executing database bytecode *\/$/;"	m	struct:Parse
pVdbe	sqliteInt.h	/^  struct Vdbe *pVdbe;           \/* List of active virtual machines *\/$/;"	m	struct:sqlite3
pVdbeFunc	vdbeInt.h	/^  VdbeFunc *pVdbeFunc;  \/* Auxilary data, if created. *\/$/;"	m	struct:sqlite3_context
pWhen	sqliteInt.h	/^  Expr *pWhen;            \/* The WHEN clause of the expresion (may be NULL) *\/$/;"	m	struct:Trigger
pWhere	sqliteInt.h	/^  Expr *pWhere;          \/* The WHERE clause *\/$/;"	m	struct:Select
pWhere	sqliteInt.h	/^  Expr *pWhere;        \/* Valid for DELETE, UPDATE steps *\/$/;"	m	struct:TriggerStep
pageDestructor	btree.c	/^static void pageDestructor(void *pData, int pageSize){$/;"	f	file:
pageHash	pager.c	/^  u32 pageHash;$/;"	m	struct:PgHdr	file:
pageIntegrity	btree.c	777;"	d	file:
pageIntegrity	btree.c	779;"	d	file:
pageReinit	btree.c	/^static void pageReinit(void *pData, int pageSize){$/;"	f	file:
pageSize	btree.c	/^  u16 pageSize;         \/* Total number of bytes on a page *\/$/;"	m	struct:Btree	file:
pageSize	pager.c	/^  int pageSize;               \/* Number of bytes in a page *\/$/;"	m	struct:Pager	file:
pageSizeFixed	btree.c	/^  u8 pageSizeFixed;     \/* True if the page size can no longer be changed *\/$/;"	m	struct:Btree	file:
page_add_to_stmt_list	pager.c	/^static void page_add_to_stmt_list(PgHdr *pPg){$/;"	f	file:
page_ref	pager.c	/^  static void page_ref(PgHdr *pPg){$/;"	f	file:
page_ref	pager.c	2061;"	d	file:
page_remove_from_stmt_list	pager.c	/^static void page_remove_from_stmt_list(PgHdr *pPg){$/;"	f	file:
pager3_refinfo_enable	pager.c	/^  int pager3_refinfo_enable = 0;$/;"	v
pager3_refinfo_enable	pager.h	/^int pager3_refinfo_enable;$/;"	v
pager_cksum	pager.c	/^static u32 pager_cksum(Pager *pPager, Pgno pgno, const char *aData){$/;"	f	file:
pager_delmaster	pager.c	/^static int pager_delmaster(const char *zMaster){$/;"	f	file:
pager_errcode	pager.c	/^static int pager_errcode(Pager *pPager){$/;"	f	file:
pager_get_all_dirty_pages	pager.c	/^static PgHdr *pager_get_all_dirty_pages(Pager *pPager){$/;"	f	file:
pager_hash	pager.c	231;"	d	file:
pager_incr_changecounter	pager.c	/^static int pager_incr_changecounter(Pager *pPager){$/;"	f	file:
pager_lookup	pager.c	/^static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){$/;"	f	file:
pager_open_journal	pager.c	/^static int pager_open_journal(Pager *pPager){$/;"	f	file:
pager_pagehash	pager.c	/^static u32 pager_pagehash(PgHdr *pPage){$/;"	f	file:
pager_playback	pager.c	/^static int pager_playback(Pager *pPager){$/;"	f	file:
pager_playback_one_page	pager.c	/^static int pager_playback_one_page(Pager *pPager, OsFile *jfd, int useCksum){$/;"	f	file:
pager_refinfo	pager.c	/^  static void pager_refinfo(PgHdr *p){$/;"	f	file:
pager_reload_cache	pager.c	/^static int pager_reload_cache(Pager *pPager){$/;"	f	file:
pager_reset	pager.c	/^static void pager_reset(Pager *pPager){$/;"	f	file:
pager_stmt_playback	pager.c	/^static int pager_stmt_playback(Pager *pPager){$/;"	f	file:
pager_truncate	pager.c	/^static int pager_truncate(Pager *pPager, int nPage){$/;"	f	file:
pager_unwritelock	pager.c	/^static int pager_unwritelock(Pager *pPager){$/;"	f	file:
pager_wait_on_lock	pager.c	/^static int pager_wait_on_lock(Pager *pPager, int locktype){$/;"	f	file:
pager_write_pagelist	pager.c	/^static int pager_write_pagelist(PgHdr *pList){$/;"	f	file:
pagesize	tool/showdb.c	/^static int pagesize = 1024;$/;"	v	file:
pagesize	tool/showjournal.c	/^static int pagesize = 1024;$/;"	v	file:
parseCell	btree.c	/^static void parseCell($/;"	f	file:
parseCellPtr	btree.c	/^static void parseCellPtr($/;"	f	file:
parseDateOrTime	date.c	/^static int parseDateOrTime(const char *zDate, DateTime *p){$/;"	f	file:
parseHhMmSs	date.c	/^static int parseHhMmSs(const char *zDate, DateTime *p){$/;"	f	file:
parseModifier	date.c	/^static int parseModifier(const char *zMod, DateTime *p){$/;"	f	file:
parseTimezone	date.c	/^static int parseTimezone(const char *zDate, DateTime *p){$/;"	f	file:
parseYyyyMmDd	date.c	/^static int parseYyyyMmDd(const char *zDate, DateTime *p){$/;"	f	file:
parseonetoken	tool/lemon.c	/^static void parseonetoken(psp)$/;"	f	file:
pathsearch	tool/lemon.c	/^PRIVATE char *pathsearch(argv0,name,modemask)$/;"	f
patternCompare	func.c	/^static int patternCompare($/;"	f	file:
payloadSize	vdbeInt.h	/^  int payloadSize;      \/* Total number of bytes in the record *\/$/;"	m	struct:Cursor
pc	vdbeInt.h	/^  int pc;                 \/* The program counter *\/$/;"	m	struct:Vdbe
percent	tool/spaceanal.tcl	/^proc percent {num denom {of {}}} {$/;"	p
pgno	btree.c	/^  Pgno pgno;           \/* Page number for this page *\/$/;"	m	struct:MemPage	file:
pgno	pager.c	/^  Pgno pgno;                     \/* The page number for this page *\/$/;"	m	struct:PgHdr	file:
pgnoRoot	btree.c	/^  Pgno pgnoRoot;            \/* The root page of this tree *\/$/;"	m	struct:BtCursor	file:
plink	tool/lemon.c	/^struct plink {$/;"	s	file:
plink_freelist	tool/lemon.c	/^static struct plink *plink_freelist = 0;$/;"	v	file:
plus_opt	parse.y	/^plus_opt ::= .$/;"	l
plus_opt	parse.y	/^plus_opt ::= PLUS.$/;"	l
popStack	vdbe.c	/^static void popStack(Mem **ppTos, int N){$/;"	f	file:
popStack	vdbeInt.h	/^  int popStack;           \/* Pop the stack this much on entry to VdbeExec() *\/$/;"	m	struct:Vdbe
ppOpenTemp	sqliteInt.h	/^  IdList **ppOpenTemp;   \/* OP_OpenTemp addresses used by multi-selects *\/$/;"	m	struct:Select
prec	tool/lemon.c	/^  int prec;                \/* Precedence if defined (-1 otherwise) *\/$/;"	m	struct:symbol	file:
preccounter	tool/lemon.c	/^  int preccounter;           \/* Assign this precedence to decl arguments *\/$/;"	m	struct:pstate	file:
precsym	tool/lemon.c	/^  struct symbol *precsym;  \/* Precedence symbol for this rule *\/$/;"	m	struct:rule	file:
prefix	printf.c	/^	etByte prefix;         \/* Offset into aPrefix[] of the prefix string *\/$/;"	m	struct:et_info	file:
prefix	tool/mkkeywordhash.c	/^  int prefix;          \/* Number of characters in prefix *\/$/;"	m	struct:Keyword	file:
prepSelectStmt	select.c	/^static int prepSelectStmt(Parse *pParse, Select *p){$/;"	f	file:
preprocess_input	tool/lemon.c	/^static void preprocess_input(char *z){$/;"	f	file:
prereqAll	where.c	/^  Bitmask prereqAll;      \/* Bitmask of tables referenced by p *\/$/;"	m	struct:ExprInfo	file:
prereqLeft	where.c	/^  Bitmask prereqLeft;     \/* Bitmask of tables referenced by p->pLeft *\/$/;"	m	struct:ExprInfo	file:
prereqRight	where.c	/^  Bitmask prereqRight;    \/* Bitmask of tables referenced by p->pRight *\/$/;"	m	struct:ExprInfo	file:
prev	hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
prev	vdbeInt.h	/^  HashElem *prev;        \/* Previously accessed hash elemen *\/$/;"	m	struct:Set
previous_mode_data	shell.c	/^struct previous_mode_data {$/;"	s	file:
prevrule	tool/lemon.c	/^  struct rule *prevrule;     \/* Previous rule parsed *\/$/;"	m	struct:pstate	file:
print_page	tool/showdb.c	/^static print_page(int iPg){$/;"	f	file:
print_page	tool/showjournal.c	/^static print_page(int iPg){$/;"	f	file:
print_stack_trace	util.c	/^void print_stack_trace()$/;"	f
print_stack_trace	util.c	42;"	d	file:
print_stack_union	tool/lemon.c	/^void print_stack_union(out,lemp,plineno,mhflag)$/;"	f
printf_realloc	printf.c	/^static void *printf_realloc(void *old, int size)$/;"	f	file:
printstack	tool/memleak3.tcl	/^proc printstack {stack} {$/;"	p
priorNewRowid	sqliteInt.h	/^  i64 priorNewRowid;            \/* Last randomly generated ROWID *\/$/;"	m	struct:sqlite3
processOrderGroupBy	select.c	/^static int processOrderGroupBy($/;"	f	file:
process_input	shell.c	/^static void process_input(struct callback_data *p, FILE *in)$/;"	f	file:
process_input	tool/memleak3.tcl	/^proc process_input {input_file array_name} {$/;"	p
process_sqliterc	shell.c	/^static void process_sqliterc($/;"	f	file:
pseudoTable	vdbeInt.h	/^  Bool pseudoTable;     \/* This is a NEW or OLD pseudo-tables of a trigger *\/$/;"	m	struct:Cursor
pstate	tool/lemon.c	/^struct pstate {$/;"	s	file:
ptrmapGet	btree.c	/^static int ptrmapGet(Btree *pBt, Pgno key, u8 *pEType, Pgno *pPgno){$/;"	f	file:
ptrmapPut	btree.c	/^static int ptrmapPut(Btree *pBt, Pgno key, u8 eType, Pgno parent){$/;"	f	file:
ptrmapPutOvfl	btree.c	/^static int ptrmapPutOvfl(MemPage *pPage, int iCell){$/;"	f	file:
ptrmapPutOvflPtr	btree.c	/^static int ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
pushOntoSorter	select.c	/^static void pushOntoSorter(Parse *pParse, Vdbe *v, ExprList *pOrderBy){$/;"	f	file:
put2byte	btree.c	/^static void put2byte(unsigned char *p, u32 v){$/;"	f	file:
put4byte	btree.c	/^static void put4byte(unsigned char *p, u32 v){$/;"	f	file:
putVarint	btree.c	406;"	d	file:
put_item	tool/mkopts.tcl	/^proc put_item x {$/;"	p
puts	www/lang.tcl	/^      proc puts {str} {$/;"	p
pzErrMsg	sqliteInt.h	/^  char **pzErrMsg;    \/* Error message stored here *\/$/;"	m
quote	tool/spaceanal.tcl	/^proc quote {txt} {$/;"	p
quoteFunc	func.c	/^static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
r	vdbeInt.h	/^  double r;           \/* Real value *\/$/;"	m	struct:Mem
rJD	date.c	/^  double rJD;      \/* The julian day number *\/$/;"	m	struct:DateTime	file:
randStr	func.c	/^static void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
randomByte	random.c	/^static int randomByte(){$/;"	f	file:
randomFunc	func.c	/^static void randomFunc($/;"	f	file:
randomName	vacuum.c	/^static void randomName(unsigned char *zBuf){$/;"	f	file:
rc	sqliteInt.h	/^  int rc;              \/* Return code from execution *\/$/;"	m	struct:Parse
rc	table.c	/^  int rc;$/;"	m	struct:TabResult	file:
rc	tclsqlite.c	/^  int rc;               \/* Return code of most recent sqlite3_exec() *\/$/;"	m	struct:SqliteDb	file:
rc	vdbeInt.h	/^  int rc;                 \/* Value to return *\/$/;"	m	struct:Vdbe
rcsid3	main.c	/^const char rcsid3[] = "@(#) \\044Id: SQLite version " SQLITE_VERSION " $";$/;"	v
read32bits	pager.c	/^static int read32bits(OsFile *fd, u32 *pRes){$/;"	f	file:
readJournalHdr	pager.c	/^static int readJournalHdr($/;"	f	file:
readMasterJournal	pager.c	/^static int readMasterJournal(OsFile *pJrnl, char **pzMaster){$/;"	f	file:
readOnly	btree.c	/^  u8 readOnly;          \/* True if the underlying file is readonly *\/$/;"	m	struct:Btree	file:
readOnly	pager.c	/^  u8 readOnly;                \/* True for a read-only database *\/$/;"	m	struct:Pager	file:
readOnly	sqliteInt.h	/^  u8 readOnly;     \/* True if this table should not be written by the user *\/$/;"	m	struct:Table
read_history	shell.c	52;"	d	file:
readline	shell.c	50;"	d	file:
rehash	hash.c	/^static void rehash(Hash *pH, int new_size){$/;"	f	file:
reindexDatabases	build.c	/^void reindexDatabases(Parse *pParse, CollSeq *pColl){$/;"	f
reindexTable	build.c	/^void reindexTable(Parse *pParse, Table *pTab, CollSeq *pColl){$/;"	f
releaseLockInfo	os_aros.c	/^static void releaseLockInfo(struct lockInfo *pLock)$/;"	f	file:
releaseMemArray	vdbeaux.c	/^static void releaseMemArray(Mem *p, int N){$/;"	f	file:
releaseOpenCnt	os_aros.c	/^static void releaseOpenCnt(struct openCnt *pOpen)$/;"	f	file:
releasePage	btree.c	/^static void releasePage(MemPage *pPage){$/;"	f	file:
releaseTempCursor	btree.c	/^static void releaseTempCursor(BtCursor *pCur){$/;"	f	file:
reloadTableSchema	alter.c	/^static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName)$/;"	f	file:
relocatePage	btree.c	/^static int relocatePage($/;"	f	file:
removeElementGivenHash	hash.c	/^static void removeElementGivenHash($/;"	f	file:
renameTableFunc	alter.c	/^static void renameTableFunc($/;"	f	file:
renameTriggerFunc	alter.c	/^static void renameTriggerFunc($/;"	f	file:
reparentChildPages	btree.c	/^static int reparentChildPages(MemPage *pPage){$/;"	f	file:
reparentPage	btree.c	/^static int reparentPage(Btree *pBt, Pgno pgno, MemPage *pNewParent, int idx){$/;"	f	file:
report	tool/memleak3.tcl	/^proc report {} {$/;"	p
resOnStack	vdbeInt.h	/^  u8 resOnStack;          \/* True if there are result values on the stack *\/$/;"	m	struct:Vdbe
resizeOpArray	vdbeaux.c	/^static void resizeOpArray(Vdbe *p, int N){$/;"	f	file:
resolveP2Values	vdbeaux.c	/^static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs, int *pMaxStack){$/;"	f	file:
resolve_backslashes	shell.c	/^static void resolve_backslashes(STRPTR z)$/;"	f	file:
resolve_conflict	tool/lemon.c	/^static int resolve_conflict(apx,apy,errsym)$/;"	f	file:
resolve_name	www/capi3ref.tcl	/^proc resolve_name {ignore_list name} {$/;"	p
restoreAggregateInfo	select.c	/^static void restoreAggregateInfo(Parse *pParse, AggregateInfo *pInfo){$/;"	f	file:
retrieve32bits	pager.c	/^static u32 retrieve32bits(PgHdr *p, int offset){$/;"	f	file:
returnDepth	vdbeInt.h	/^  int returnDepth;        \/* Next unused element in returnStack[] *\/$/;"	m	struct:Vdbe
returnSingleInt	pragma.c	/^static void returnSingleInt(Parse *pParse, const char *zLabel, int value){$/;"	f	file:
returnStack	vdbeInt.h	/^  int returnStack[100];   \/* Return address stack for OP_Gosub & OP_Return *\/$/;"	m	struct:Vdbe
rhs	tool/lemon.c	/^  struct symbol **rhs;     \/* The RHS symbols *\/$/;"	m	struct:rule	file:
rhs	tool/lemon.c	/^  struct symbol *rhs[MAXRHS];  \/* RHS symbols *\/$/;"	m	struct:pstate	file:
rhsalias	tool/lemon.c	/^  char **rhsalias;         \/* An alias for each RHS symbol (NULL if none) *\/$/;"	m	struct:rule	file:
roundFunc	func.c	/^static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
rowidIsValid	vdbeInt.h	/^  Bool rowidIsValid;    \/* True if lastRowid is valid *\/$/;"	m	struct:Cursor
rp	tool/lemon.c	/^    struct rule *rp;       \/* The rule, if a reduce *\/$/;"	m	union:action::<anonymous>	file:
rp	tool/lemon.c	/^  struct rule *rp;         \/* The rule upon which the configuration is based *\/$/;"	m	struct:config	file:
rule	tool/lemon.c	/^  struct rule *rule;       \/* Linked list of rules of this (if an NT) *\/$/;"	m	struct:symbol	file:
rule	tool/lemon.c	/^  struct rule *rule;       \/* List of all rules *\/$/;"	m	struct:lemon	file:
rule	tool/lemon.c	/^struct rule {$/;"	s	file:
ruleline	tool/lemon.c	/^  int ruleline;            \/* Line number for the rule *\/$/;"	m	struct:rule	file:
run_schema_dump_query	shell.c	/^static int run_schema_dump_query($/;"	f	file:
run_table_dump_query	shell.c	/^static int run_table_dump_query(FILE *out, sqlite3 *db, const char *zSelect)$/;"	f	file:
runtest	tool/speedtest.tcl	/^proc runtest {title} {$/;"	p
runtest	tool/speedtest2.tcl	/^proc runtest {title} {$/;"	p
s	date.c	/^  double s;        \/* Seconds *\/$/;"	m	struct:DateTime	file:
s	vdbeInt.h	/^  Mem s;            \/* The return value is stored here *\/$/;"	m	struct:sqlite3_context
sColMap	sqliteInt.h	/^  struct sColMap {  \/* Mapping of columns in pFrom to columns in zTo *\/$/;"	s	struct:FKey
sErrToken	sqliteInt.h	/^  Token sErrToken;     \/* The token at which the error occurred *\/$/;"	m	struct:Parse
sLastToken	sqliteInt.h	/^  Token sLastToken;    \/* The last token parsed *\/$/;"	m	struct:Parse
sNameToken	sqliteInt.h	/^  Token sNameToken;    \/* Token with unqualified schema object name *\/$/;"	m	struct:Parse
s_options	tool/lemon.c	/^struct s_options {$/;"	s	file:
s_x1	tool/lemon.c	/^struct s_x1 {$/;"	s	file:
s_x1node	tool/lemon.c	/^typedef struct s_x1node {$/;"	s	file:
s_x2	tool/lemon.c	/^struct s_x2 {$/;"	s	file:
s_x2node	tool/lemon.c	/^typedef struct s_x2node {$/;"	s	file:
s_x3	tool/lemon.c	/^struct s_x3 {$/;"	s	file:
s_x3node	tool/lemon.c	/^typedef struct s_x3node {$/;"	s	file:
s_x4	tool/lemon.c	/^struct s_x4 {$/;"	s	file:
s_x4node	tool/lemon.c	/^typedef struct s_x4node {$/;"	s	file:
safety_level	sqliteInt.h	/^	u8 safety_level;     \/* How aggressive at synching data to disk *\/$/;"	m	struct:Db
saveAggregateInfo	select.c	/^static void saveAggregateInfo(Parse *pParse, AggregateInfo *pInfo){$/;"	f	file:
schemaIsValid	prepare.c	/^static int schemaIsValid(sqlite3 *db){$/;"	f	file:
schema_cookie	sqliteInt.h	/^	int schema_cookie;   \/* Database schema version number for this file *\/$/;"	m	struct:Db
score	sqliteInt.h	/^  int score;           \/* How well this index scored *\/$/;"	m	struct:WhereLevel
searching	vdbeInt.h	/^  u8 searching;        \/* True between the first AggNext and AggReset *\/$/;"	m	struct:Agg
section	www/optimizing.tcl	/^proc section {level tag name} {$/;"	p
sectorSize	pager.c	/^  int sectorSize;             \/* Assumed sector size during rollback *\/$/;"	m	struct:Pager	file:
seekJournalHdr	pager.c	/^static int seekJournalHdr(Pager *pPager){$/;"	f	file:
seenInterrupt	shell.c	/^static BOOL seenInterrupt = FALSE;$/;"	v	file:
selectInnerLoop	select.c	/^static int selectInnerLoop($/;"	f	file:
selectOpName	select.c	/^static const char *selectOpName(int id){$/;"	f	file:
selectReadsTable	insert.c	/^static int selectReadsTable(Select *p, int iDb, int iTab){$/;"	f	file:
separator	shell.c	/^	char separator[20];	\/* Separator character for MODE_List *\/$/;"	m	struct:callback_data	file:
setChildPtrmaps	btree.c	/^static int setChildPtrmaps(MemPage *pPage){$/;"	f	file:
setJoinExpr	select.c	/^static void setJoinExpr(Expr *p){$/;"	f	file:
setMaster	pager.c	/^  u8 setMaster;               \/* True if a m-j name has been written to jrnl *\/$/;"	m	struct:Pager	file:
setToken	select.c	/^static void setToken(Token *p, const char *z){$/;"	f	file:
set_table_name	shell.c	/^static void set_table_name(struct callback_data *p, CONST_STRPTR zName)$/;"	f	file:
sgMprintf	printf.c	/^struct sgMprintf {$/;"	s	file:
shellstaticFunc	shell.c	/^static void shellstaticFunc($/;"	f	file:
shift	tool/memleak3.tcl	/^proc shift {listvar} {$/;"	p
showHeader	shell.c	/^	BOOL showHeader;	\/* True to show column names in List or Column mode *\/$/;"	m	struct:callback_data	file:
showHeader	shell.c	/^	int showHeader;$/;"	m	struct:previous_mode_data	file:
sig	test/threadtest1.c	/^pthread_cond_t sig = PTHREAD_COND_INITIALIZER;$/;"	v
simpleMinMaxQuery	select.c	/^static int simpleMinMaxQuery(Parse *pParse, Select *p, int eDest, int iParm){$/;"	f	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x1	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x2	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x3	file:
size	tool/lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x4	file:
size	tool/lemon.c	/^static int size = 0;$/;"	v	file:
slink	www/lang.tcl	/^proc slink {label} {$/;"	p
sortOrder	sqliteInt.h	/^    u8 sortOrder;          \/* 1 for DESC or 0 for ASC *\/$/;"	m	struct:ExprList::ExprList_item
sortableByRowid	where.c	/^static int sortableByRowid($/;"	f	file:
sorted	tool/lemon.c	/^  struct state **sorted;   \/* Table of states sorted by state number *\/$/;"	m	struct:lemon	file:
soundexFunc	func.c	/^static void soundexFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
sp	tool/lemon.c	/^  struct symbol *sp;       \/* The look-ahead symbol *\/$/;"	m	struct:action	file:
span	sqliteInt.h	/^  Token span;            \/* Complete text of the expression *\/$/;"	m	struct:Expr
sqlite3	sqlite3.h	/^typedef struct sqlite3 sqlite3;$/;"	t
sqlite3	sqliteInt.h	/^struct sqlite3 {$/;"	s
sqlite3	test/tester.tcl	/^  proc sqlite3 {args} {$/;"	p
sqlite3AddCollateType	build.c	/^void sqlite3AddCollateType(Parse *pParse, const char *zType, int nType){$/;"	f
sqlite3AddColumn	build.c	/^void sqlite3AddColumn(Parse *pParse, Token *pName){$/;"	f
sqlite3AddColumnType	build.c	/^void sqlite3AddColumnType(Parse *pParse, Token *pFirst, Token *pLast){$/;"	f
sqlite3AddDefaultValue	build.c	/^void sqlite3AddDefaultValue(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3AddNotNull	build.c	/^void sqlite3AddNotNull(Parse *pParse, int onError){$/;"	f
sqlite3AddPrimaryKey	build.c	/^void sqlite3AddPrimaryKey($/;"	f
sqlite3AffinityType	build.c	/^static char sqlite3AffinityType(const char *zType, int nType){$/;"	f	file:
sqlite3AlterBeginAddColumn	alter.c	/^void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc)$/;"	f
sqlite3AlterFinishAddColumn	alter.c	/^void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef)$/;"	f
sqlite3AlterFunctions	alter.c	/^void sqlite3AlterFunctions(sqlite3 *db)$/;"	f
sqlite3AlterRenameTable	alter.c	/^void sqlite3AlterRenameTable($/;"	f
sqlite3AtoF	util.c	/^double sqlite3AtoF(const char *z, const char **pzEnd)$/;"	f
sqlite3Attach	attach.c	/^void sqlite3Attach($/;"	f
sqlite3AuthCheck	auth.c	/^int sqlite3AuthCheck($/;"	f
sqlite3AuthCheck	sqliteInt.h	1527;"	d
sqlite3AuthContextPop	auth.c	/^void sqlite3AuthContextPop(AuthContext *pContext){$/;"	f
sqlite3AuthContextPop	sqliteInt.h	1529;"	d
sqlite3AuthContextPush	auth.c	/^void sqlite3AuthContextPush($/;"	f
sqlite3AuthContextPush	sqliteInt.h	1528;"	d
sqlite3AuthRead	auth.c	/^void sqlite3AuthRead($/;"	f
sqlite3AuthRead	sqliteInt.h	1526;"	d
sqlite3BeginParse	build.c	/^void sqlite3BeginParse(Parse *pParse, int explainFlag){$/;"	f
sqlite3BeginTransaction	build.c	/^void sqlite3BeginTransaction(Parse *pParse, int type){$/;"	f
sqlite3BeginTrigger	trigger.c	/^void sqlite3BeginTrigger($/;"	f
sqlite3BeginWriteOperation	build.c	/^void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){$/;"	f
sqlite3BtreeBeginStmt	btree.c	/^int sqlite3BtreeBeginStmt(Btree *pBt){$/;"	f
sqlite3BtreeBeginTrans	btree.c	/^int sqlite3BtreeBeginTrans(Btree *pBt, int wrflag){$/;"	f
sqlite3BtreeClearTable	btree.c	/^int sqlite3BtreeClearTable(Btree *pBt, int iTable){$/;"	f
sqlite3BtreeClose	btree.c	/^int sqlite3BtreeClose(Btree *pBt){$/;"	f
sqlite3BtreeCloseCursor	btree.c	/^int sqlite3BtreeCloseCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeCommit	btree.c	/^int sqlite3BtreeCommit(Btree *pBt){$/;"	f
sqlite3BtreeCommitStmt	btree.c	/^int sqlite3BtreeCommitStmt(Btree *pBt){$/;"	f
sqlite3BtreeCopyFile	btree.c	/^int sqlite3BtreeCopyFile(Btree *pBtTo, Btree *pBtFrom){$/;"	f
sqlite3BtreeCreateTable	btree.c	/^int sqlite3BtreeCreateTable(Btree *pBt, int *piTable, int flags){$/;"	f
sqlite3BtreeCursor	btree.c	/^int sqlite3BtreeCursor($/;"	f
sqlite3BtreeCursorInfo	btree.c	/^int sqlite3BtreeCursorInfo(BtCursor *pCur, int *aResult, int upCnt){$/;"	f
sqlite3BtreeCursorList	btree.c	/^void sqlite3BtreeCursorList(Btree *pBt){$/;"	f
sqlite3BtreeData	btree.c	/^int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeDataFetch	btree.c	/^const void *sqlite3BtreeDataFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeDataSize	btree.c	/^int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){$/;"	f
sqlite3BtreeDelete	btree.c	/^int sqlite3BtreeDelete(BtCursor *pCur){$/;"	f
sqlite3BtreeDropTable	btree.c	/^int sqlite3BtreeDropTable(Btree *pBt, int iTable, int *piMoved){$/;"	f
sqlite3BtreeEof	btree.c	/^int sqlite3BtreeEof(BtCursor *pCur){$/;"	f
sqlite3BtreeFactory	main.c	/^int sqlite3BtreeFactory($/;"	f
sqlite3BtreeFirst	btree.c	/^int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeFlags	btree.c	/^int sqlite3BtreeFlags(BtCursor *pCur){$/;"	f
sqlite3BtreeGetAutoVacuum	btree.c	/^int sqlite3BtreeGetAutoVacuum(Btree *pBt){$/;"	f
sqlite3BtreeGetDirname	btree.c	/^const char *sqlite3BtreeGetDirname(Btree *pBt){$/;"	f
sqlite3BtreeGetFilename	btree.c	/^const char *sqlite3BtreeGetFilename(Btree *pBt){$/;"	f
sqlite3BtreeGetJournalname	btree.c	/^const char *sqlite3BtreeGetJournalname(Btree *pBt){$/;"	f
sqlite3BtreeGetMeta	btree.c	/^int sqlite3BtreeGetMeta(Btree *pBt, int idx, u32 *pMeta){$/;"	f
sqlite3BtreeGetPageSize	btree.c	/^int sqlite3BtreeGetPageSize(Btree *pBt){$/;"	f
sqlite3BtreeGetReserve	btree.c	/^int sqlite3BtreeGetReserve(Btree *pBt){$/;"	f
sqlite3BtreeInsert	btree.c	/^int sqlite3BtreeInsert($/;"	f
sqlite3BtreeIntegrityCheck	btree.c	/^char *sqlite3BtreeIntegrityCheck(Btree *pBt, int *aRoot, int nRoot){$/;"	f
sqlite3BtreeIsInStmt	btree.c	/^int sqlite3BtreeIsInStmt(Btree *pBt){$/;"	f
sqlite3BtreeIsInTrans	btree.c	/^int sqlite3BtreeIsInTrans(Btree *pBt){$/;"	f
sqlite3BtreeKey	btree.c	/^int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeKeyFetch	btree.c	/^const void *sqlite3BtreeKeyFetch(BtCursor *pCur, int *pAmt){$/;"	f
sqlite3BtreeKeySize	btree.c	/^int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){$/;"	f
sqlite3BtreeLast	btree.c	/^int sqlite3BtreeLast(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeMoveto	btree.c	/^int sqlite3BtreeMoveto(BtCursor *pCur, const void *pKey, i64 nKey, int *pRes){$/;"	f
sqlite3BtreeNext	btree.c	/^int sqlite3BtreeNext(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeOpen	btree.c	/^int sqlite3BtreeOpen($/;"	f
sqlite3BtreePageDump	btree.c	/^int sqlite3BtreePageDump(Btree *pBt, int pgno, int recursive){$/;"	f
sqlite3BtreePageDump	btree.h	140;"	d
sqlite3BtreePager	btree.c	/^Pager *sqlite3BtreePager(Btree *pBt){$/;"	f
sqlite3BtreePrevious	btree.c	/^int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeReset	btree.c	/^int sqlite3BtreeReset(Btree *pBt){$/;"	f
sqlite3BtreeRollback	btree.c	/^int sqlite3BtreeRollback(Btree *pBt){$/;"	f
sqlite3BtreeRollbackStmt	btree.c	/^int sqlite3BtreeRollbackStmt(Btree *pBt){$/;"	f
sqlite3BtreeSetAutoVacuum	btree.c	/^int sqlite3BtreeSetAutoVacuum(Btree *pBt, int autoVacuum){$/;"	f
sqlite3BtreeSetBusyHandler	btree.c	/^int sqlite3BtreeSetBusyHandler(Btree *pBt, BusyHandler *pHandler){$/;"	f
sqlite3BtreeSetCacheSize	btree.c	/^int sqlite3BtreeSetCacheSize(Btree *pBt, int mxPage){$/;"	f
sqlite3BtreeSetPageSize	btree.c	/^int sqlite3BtreeSetPageSize(Btree *pBt, int pageSize, int nReserve){$/;"	f
sqlite3BtreeSetSafetyLevel	btree.c	/^int sqlite3BtreeSetSafetyLevel(Btree *pBt, int level){$/;"	f
sqlite3BtreeSync	btree.c	/^int sqlite3BtreeSync(Btree *pBt, const char *zMaster){$/;"	f
sqlite3BtreeUpdateMeta	btree.c	/^int sqlite3BtreeUpdateMeta(Btree *pBt, int idx, u32 iMeta){$/;"	f
sqlite3ChangeCookie	build.c	/^void sqlite3ChangeCookie(sqlite3 *db, Vdbe *v, int iDb){$/;"	f
sqlite3CheckCollSeq	callback.c	/^int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){$/;"	f
sqlite3CheckIndexCollSeq	build.c	/^int sqlite3CheckIndexCollSeq(Parse *pParse, Index *pIdx){$/;"	f
sqlite3CheckMemory	sqliteInt.h	1364;"	d
sqlite3CheckMemory	util.c	/^void sqlite3CheckMemory(void *p, int N)$/;"	f
sqlite3CheckObjectName	build.c	/^int sqlite3CheckObjectName(Parse *pParse, const char *zName){$/;"	f
sqlite3CodeRowTrigger	sqliteInt.h	1514;"	d
sqlite3CodeRowTrigger	trigger.c	/^int sqlite3CodeRowTrigger($/;"	f
sqlite3CodeSubselect	expr.c	/^void sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3CodeVerifySchema	build.c	/^void sqlite3CodeVerifySchema(Parse *pParse, int iDb){$/;"	f
sqlite3ColumnDefault	update.c	/^void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i){$/;"	f
sqlite3CommitInternalChanges	build.c	/^void sqlite3CommitInternalChanges(sqlite3 *db){$/;"	f
sqlite3CommitTransaction	build.c	/^void sqlite3CommitTransaction(Parse *pParse){$/;"	f
sqlite3CompareAffinity	expr.c	/^char sqlite3CompareAffinity(Expr *pExpr, char aff2){$/;"	f
sqlite3CompleteInsertion	insert.c	/^void sqlite3CompleteInsertion($/;"	f
sqlite3CreateForeignKey	build.c	/^void sqlite3CreateForeignKey($/;"	f
sqlite3CreateIndex	build.c	/^void sqlite3CreateIndex($/;"	f
sqlite3CreateView	build.c	/^void sqlite3CreateView($/;"	f
sqlite3DebugPrintf	printf.c	/^void sqlite3DebugPrintf(const char *zFormat, ...){$/;"	f
sqlite3DeferForeignKey	build.c	/^void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){$/;"	f
sqlite3DeleteFrom	delete.c	/^void sqlite3DeleteFrom($/;"	f
sqlite3DeleteTable	build.c	/^void sqlite3DeleteTable(sqlite3 *db, Table *pTable){$/;"	f
sqlite3DeleteTrigger	sqliteInt.h	1511;"	d
sqlite3DeleteTrigger	trigger.c	/^void sqlite3DeleteTrigger(Trigger *pTrigger){$/;"	f
sqlite3DeleteTriggerStep	trigger.c	/^void sqlite3DeleteTriggerStep(TriggerStep *pTriggerStep){$/;"	f
sqlite3Dequote	util.c	/^void sqlite3Dequote(char *z)$/;"	f
sqlite3Detach	attach.c	/^void sqlite3Detach(Parse *pParse, Token *pDbname){$/;"	f
sqlite3DropIndex	build.c	/^void sqlite3DropIndex(Parse *pParse, SrcList *pName)$/;"	f
sqlite3DropTable	build.c	/^void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView){$/;"	f
sqlite3DropTrigger	trigger.c	/^void sqlite3DropTrigger(Parse *pParse, SrcList *pName){$/;"	f
sqlite3DropTriggerPtr	sqliteInt.h	1512;"	d
sqlite3DropTriggerPtr	trigger.c	/^void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger, int nested){$/;"	f
sqlite3EndTable	build.c	/^void sqlite3EndTable($/;"	f
sqlite3ErrStr	main.c	/^CONST_STRPTR sqlite3ErrStr(int rc)$/;"	f
sqlite3Error	util.c	/^void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...)$/;"	f
sqlite3ErrorMsg	util.c	/^void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...)$/;"	f
sqlite3ExpirePreparedStatements	vdbeaux.c	/^void sqlite3ExpirePreparedStatements(sqlite3 *db){$/;"	f
sqlite3Expr	expr.c	/^Expr *sqlite3Expr(int op, Expr *pLeft, Expr *pRight, const Token *pToken){$/;"	f
sqlite3ExprAffinity	expr.c	/^char sqlite3ExprAffinity(Expr *pExpr){$/;"	f
sqlite3ExprAnalyzeAggregates	expr.c	/^int sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){$/;"	f
sqlite3ExprAnd	expr.c	/^Expr *sqlite3ExprAnd(Expr *pLeft, Expr *pRight){$/;"	f
sqlite3ExprAssignVarNumber	expr.c	/^void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCode	expr.c	/^void sqlite3ExprCode(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCodeAndCache	expr.c	/^void sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCodeExprList	expr.c	/^int sqlite3ExprCodeExprList($/;"	f
sqlite3ExprCollSeq	expr.c	/^CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCompare	expr.c	/^int sqlite3ExprCompare(Expr *pA, Expr *pB){$/;"	f
sqlite3ExprDelete	expr.c	/^void sqlite3ExprDelete(Expr *p){$/;"	f
sqlite3ExprDup	expr.c	/^Expr *sqlite3ExprDup(Expr *p){$/;"	f
sqlite3ExprFunction	expr.c	/^Expr *sqlite3ExprFunction(ExprList *pList, Token *pToken){$/;"	f
sqlite3ExprIfFalse	expr.c	/^void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIfTrue	expr.c	/^void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIsConstant	expr.c	/^int sqlite3ExprIsConstant(Expr *p){$/;"	f
sqlite3ExprIsInteger	expr.c	/^int sqlite3ExprIsInteger(Expr *p, int *pValue){$/;"	f
sqlite3ExprListAppend	expr.c	/^ExprList *sqlite3ExprListAppend(ExprList *pList, Expr *pExpr, Token *pName){$/;"	f
sqlite3ExprListDelete	expr.c	/^void sqlite3ExprListDelete(ExprList *pList){$/;"	f
sqlite3ExprListDup	expr.c	/^ExprList *sqlite3ExprListDup(ExprList *p){$/;"	f
sqlite3ExprResolveNames	expr.c	/^int sqlite3ExprResolveNames($/;"	f
sqlite3ExprSpan	expr.c	/^void sqlite3ExprSpan(Expr *pExpr, Token *pLeft, Token *pRight){$/;"	f
sqlite3FindCollSeq	callback.c	/^CollSeq *sqlite3FindCollSeq($/;"	f
sqlite3FindFunction	callback.c	/^FuncDef *sqlite3FindFunction($/;"	f
sqlite3FindIndex	build.c	/^Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){$/;"	f
sqlite3FindTable	build.c	/^Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){$/;"	f
sqlite3FinishCoding	build.c	/^void sqlite3FinishCoding(Parse *pParse){$/;"	f
sqlite3FinishTrigger	trigger.c	/^void sqlite3FinishTrigger($/;"	f
sqlite3FitsIn32Bits	util.c	/^static BOOL sqlite3FitsIn32Bits(const char *zNum)$/;"	f	file:
sqlite3FitsIn64Bits	util.c	/^BOOL sqlite3FitsIn64Bits(const char *zNum)$/;"	f
sqlite3FixExpr	attach.c	/^int sqlite3FixExpr($/;"	f
sqlite3FixExprList	attach.c	/^int sqlite3FixExprList($/;"	f
sqlite3FixInit	attach.c	/^int sqlite3FixInit($/;"	f
sqlite3FixSelect	attach.c	/^int sqlite3FixSelect($/;"	f
sqlite3FixSrcList	attach.c	/^int sqlite3FixSrcList($/;"	f
sqlite3FixTriggerStep	attach.c	/^int sqlite3FixTriggerStep($/;"	f
sqlite3FreeX	util.c	/^void sqlite3FreeX(void *p)$/;"	f
sqlite3Free_	util.c	/^void sqlite3Free_(void *p, char *zFile, int line)$/;"	f
sqlite3GenerateConstraintChecks	insert.c	/^void sqlite3GenerateConstraintChecks($/;"	f
sqlite3GenerateIndexKey	delete.c	/^void sqlite3GenerateIndexKey($/;"	f
sqlite3GenerateRowDelete	delete.c	/^void sqlite3GenerateRowDelete($/;"	f
sqlite3GenerateRowIndexDelete	delete.c	/^void sqlite3GenerateRowIndexDelete($/;"	f
sqlite3GetCollSeq	callback.c	/^CollSeq *sqlite3GetCollSeq($/;"	f
sqlite3GetFuncCollSeq	func.c	/^static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){$/;"	f	file:
sqlite3GetInt32	util.c	/^BOOL sqlite3GetInt32(const char *zNum, int *pValue)$/;"	f
sqlite3GetToken	tokenize.c	/^int sqlite3GetToken(const unsigned char *z, int *tokenType){$/;"	f
sqlite3GetTransientValue	main.c	/^sqlite3_value *sqlite3GetTransientValue(sqlite3 *db)$/;"	f
sqlite3GetVarint	util.c	/^int sqlite3GetVarint(const unsigned char *p, u64 *v)$/;"	f
sqlite3GetVarint32	util.c	/^int sqlite3GetVarint32(const unsigned char *p, u32 *v)$/;"	f
sqlite3GetVdbe	select.c	/^Vdbe *sqlite3GetVdbe(Parse *pParse){$/;"	f
sqlite3HashClear	hash.c	/^void sqlite3HashClear(Hash *pH){$/;"	f
sqlite3HashFind	hash.c	/^void *sqlite3HashFind(const Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3HashInit	hash.c	/^void sqlite3HashInit(Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3HashInsert	hash.c	/^void *sqlite3HashInsert(Hash *pH, const void *pKey, int nKey, void *data){$/;"	f
sqlite3HexToBlob	util.c	/^void *sqlite3HexToBlob(const char *z)$/;"	f
sqlite3IdListAppend	build.c	/^IdList *sqlite3IdListAppend(IdList *pList, Token *pToken){$/;"	f
sqlite3IdListDelete	build.c	/^void sqlite3IdListDelete(IdList *pList){$/;"	f
sqlite3IdListDup	expr.c	/^IdList *sqlite3IdListDup(IdList *p){$/;"	f
sqlite3IdListIndex	build.c	/^int sqlite3IdListIndex(IdList *pList, const char *zName){$/;"	f
sqlite3IndexAffinityOk	expr.c	/^int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){$/;"	f
sqlite3IndexAffinityStr	insert.c	/^void sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){$/;"	f
sqlite3Init	prepare.c	/^int sqlite3Init(sqlite3 *db, char **pzErrMsg){$/;"	f
sqlite3InitCallback	prepare.c	/^int sqlite3InitCallback(void *pInit, int argc, char **argv, char **azColName){$/;"	f
sqlite3InitInfo	sqliteInt.h	/^  struct sqlite3InitInfo {      \/* Information used during initialization *\/$/;"	s	struct:sqlite3
sqlite3InitOne	prepare.c	/^static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){$/;"	f	file:
sqlite3Insert	insert.c	/^void sqlite3Insert($/;"	f
sqlite3IsNumber	util.c	/^int sqlite3IsNumber(const char *z, int *realnum, u8 enc)$/;"	f
sqlite3IsReadOnly	delete.c	/^int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){$/;"	f
sqlite3IsRowid	expr.c	/^int sqlite3IsRowid(const char *z){$/;"	f
sqlite3JoinType	select.c	/^int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){$/;"	f
sqlite3KeywordCode	keywordhash.h	/^int sqlite3KeywordCode(const char *z, int n){$/;"	f
sqlite3LocateCollSeq	build.c	/^CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName, int nName){$/;"	f
sqlite3LocateTable	build.c	/^Table *sqlite3LocateTable(Parse *pParse, const char *zName, const char *zDbase){$/;"	f
sqlite3MPrintf	printf.c	/^char *sqlite3MPrintf(const char *zFormat, ...)$/;"	f
sqlite3Malloc	util.c	/^void *sqlite3Malloc(int n)$/;"	f
sqlite3MallocRaw	util.c	/^void *sqlite3MallocRaw(int n)$/;"	f
sqlite3MallocX	sqliteInt.h	1365;"	d
sqlite3MallocX	util.c	/^void *sqlite3MallocX(int n)$/;"	f
sqlite3Malloc_	util.c	/^void *sqlite3Malloc_(int n, int bZero, char *zFile, int line)$/;"	f
sqlite3MemCompare	vdbemem.c	/^int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){$/;"	f
sqlite3NameFromToken	build.c	/^char *sqlite3NameFromToken(Token *pName){$/;"	f
sqlite3NestedParse	build.c	/^void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3OpcodeNames	opcodes.c	/^const char *const sqlite3OpcodeNames[] = { "?",$/;"	v
sqlite3OpenMasterTable	build.c	/^void sqlite3OpenMasterTable(Vdbe *v, int iDb){$/;"	f
sqlite3OpenTableAndIndices	insert.c	/^void sqlite3OpenTableAndIndices($/;"	f
sqlite3OpenTableForReading	delete.c	/^void sqlite3OpenTableForReading($/;"	f
sqlite3OpenTempDatabase	build.c	/^static int sqlite3OpenTempDatabase(Parse *pParse){$/;"	f	file:
sqlite3OsCheckReservedLock	os_aros.c	/^BOOL sqlite3OsCheckReservedLock(OsFile *id)$/;"	f
sqlite3OsCheckReservedLock	os_test.c	/^int sqlite3OsCheckReservedLock(OsFile *id){$/;"	f
sqlite3OsCheckReservedLock	os_test.c	33;"	d	file:
sqlite3OsCheckReservedLock	os_test.c	54;"	d	file:
sqlite3OsClose	os_aros.c	/^err_t sqlite3OsClose(OsFile *id)$/;"	f
sqlite3OsClose	os_test.c	/^int sqlite3OsClose(OsFile *id){$/;"	f
sqlite3OsClose	os_test.c	24;"	d	file:
sqlite3OsClose	os_test.c	45;"	d	file:
sqlite3OsCurrentTime	os_aros.c	/^BOOL sqlite3OsCurrentTime(double *prNow)$/;"	f
sqlite3OsDelete	os_aros.c	/^err_t sqlite3OsDelete( CONST_STRPTR zFilename )$/;"	f
sqlite3OsEnterMutex	os_aros.c	/^void sqlite3OsEnterMutex()$/;"	f
sqlite3OsFileExists	os_aros.c	/^BOOL sqlite3OsFileExists( CONST_STRPTR zFilename )$/;"	f
sqlite3OsFileSize	os_aros.c	/^err_t sqlite3OsFileSize(OsFile *id, i64 *pSize)$/;"	f
sqlite3OsFileSize	os_test.c	/^int sqlite3OsFileSize(OsFile *id, i64 *pSize){$/;"	f
sqlite3OsFileSize	os_test.c	30;"	d	file:
sqlite3OsFileSize	os_test.c	51;"	d	file:
sqlite3OsFullPathname	os_aros.c	/^char *sqlite3OsFullPathname(CONST_STRPTR zRelative)$/;"	f
sqlite3OsIsDirWritable	os_aros.c	/^BOOL sqlite3OsIsDirWritable( CONST_STRPTR zBuf )$/;"	f
sqlite3OsLeaveMutex	os_aros.c	/^void sqlite3OsLeaveMutex()$/;"	f
sqlite3OsLock	os_aros.c	/^err_t sqlite3OsLock(OsFile *id, int locktype)$/;"	f
sqlite3OsLock	os_test.c	/^int sqlite3OsLock(OsFile *id, int locktype){$/;"	f
sqlite3OsLock	os_test.c	31;"	d	file:
sqlite3OsLock	os_test.c	52;"	d	file:
sqlite3OsOpenDirectory	os_aros.c	/^err_t sqlite3OsOpenDirectory( CONST_STRPTR zDirname, OsFile *id )$/;"	f
sqlite3OsOpenDirectory	os_test.c	/^int sqlite3OsOpenDirectory(const char *zDirname, OsFile *id){$/;"	f
sqlite3OsOpenDirectory	os_test.c	23;"	d	file:
sqlite3OsOpenDirectory	os_test.c	44;"	d	file:
sqlite3OsOpenExclusive	os_aros.c	/^err_t sqlite3OsOpenExclusive(CONST_STRPTR zFilename, OsFile *id, BOOL delFlag)$/;"	f
sqlite3OsOpenExclusive	os_test.c	/^int sqlite3OsOpenExclusive(const char *zFilename, OsFile *id, int delFlag){$/;"	f
sqlite3OsOpenExclusive	os_test.c	21;"	d	file:
sqlite3OsOpenExclusive	os_test.c	42;"	d	file:
sqlite3OsOpenReadOnly	os_aros.c	/^err_t sqlite3OsOpenReadOnly( CONST_STRPTR zFilename, OsFile *id )$/;"	f
sqlite3OsOpenReadOnly	os_test.c	/^int sqlite3OsOpenReadOnly(const char *zFilename, OsFile *id){$/;"	f
sqlite3OsOpenReadOnly	os_test.c	22;"	d	file:
sqlite3OsOpenReadOnly	os_test.c	43;"	d	file:
sqlite3OsOpenReadWrite	os_aros.c	/^err_t sqlite3OsOpenReadWrite($/;"	f
sqlite3OsOpenReadWrite	os_test.c	/^int sqlite3OsOpenReadWrite(const char *zFilename, OsFile *id, int *pReadonly){$/;"	f
sqlite3OsOpenReadWrite	os_test.c	20;"	d	file:
sqlite3OsOpenReadWrite	os_test.c	41;"	d	file:
sqlite3OsRandomSeed	os_aros.c	/^int sqlite3OsRandomSeed(char *zBuf)$/;"	f
sqlite3OsRead	os_aros.c	/^err_t sqlite3OsRead(OsFile *id, void *pBuf, int amt)$/;"	f
sqlite3OsRead	os_test.c	/^int sqlite3OsRead(OsFile *id, void *pBuf, int amt){$/;"	f
sqlite3OsRead	os_test.c	25;"	d	file:
sqlite3OsRead	os_test.c	46;"	d	file:
sqlite3OsSeek	os_aros.c	/^err_t sqlite3OsSeek(OsFile *id, i64 offset)$/;"	f
sqlite3OsSeek	os_test.c	/^int sqlite3OsSeek(OsFile *id, i64 offset){$/;"	f
sqlite3OsSeek	os_test.c	27;"	d	file:
sqlite3OsSeek	os_test.c	48;"	d	file:
sqlite3OsSleep	os_aros.c	/^int sqlite3OsSleep(int ms)$/;"	f
sqlite3OsSync	os_aros.c	/^err_t sqlite3OsSync(OsFile *id)$/;"	f
sqlite3OsSync	os_test.c	/^int sqlite3OsSync(OsFile *id){$/;"	f
sqlite3OsSync	os_test.c	28;"	d	file:
sqlite3OsSync	os_test.c	49;"	d	file:
sqlite3OsSyncDirectory	os_aros.c	/^err_t sqlite3OsSyncDirectory( CONST_STRPTR zDirname )$/;"	f
sqlite3OsTempFileName	os_aros.c	/^err_t sqlite3OsTempFileName(char *zBuf)$/;"	f
sqlite3OsTruncate	os_aros.c	/^err_t sqlite3OsTruncate(OsFile *id, i64 nByte)$/;"	f
sqlite3OsTruncate	os_test.c	/^int sqlite3OsTruncate(OsFile *id, i64 nByte){$/;"	f
sqlite3OsTruncate	os_test.c	29;"	d	file:
sqlite3OsTruncate	os_test.c	50;"	d	file:
sqlite3OsUnlock	os_aros.c	/^err_t sqlite3OsUnlock(OsFile *id, int locktype)$/;"	f
sqlite3OsUnlock	os_test.c	/^int sqlite3OsUnlock(OsFile *id, int locktype){$/;"	f
sqlite3OsUnlock	os_test.c	32;"	d	file:
sqlite3OsUnlock	os_test.c	53;"	d	file:
sqlite3OsWrite	os_aros.c	/^err_t sqlite3OsWrite(OsFile *id, const void *pBuf, int amt)$/;"	f
sqlite3OsWrite	os_test.c	/^int sqlite3OsWrite(OsFile *id, const void *pBuf, int amt){$/;"	f
sqlite3OsWrite	os_test.c	26;"	d	file:
sqlite3OsWrite	os_test.c	47;"	d	file:
sqlite3Parser	parse.c	/^void sqlite3Parser($/;"	f
sqlite3ParserARG_FETCH	parse.c	119;"	d	file:
sqlite3ParserARG_PDECL	parse.c	118;"	d	file:
sqlite3ParserARG_SDECL	parse.c	117;"	d	file:
sqlite3ParserARG_STORE	parse.c	120;"	d	file:
sqlite3ParserAlloc	parse.c	/^void *sqlite3ParserAlloc(void *(*mallocProc)(size_t)){$/;"	f
sqlite3ParserFree	parse.c	/^void sqlite3ParserFree($/;"	f
sqlite3ParserTOKENTYPE	parse.c	98;"	d	file:
sqlite3ParserTokenName	parse.c	/^const char *sqlite3ParserTokenName(int tokenType){$/;"	f
sqlite3ParserTrace	parse.c	/^void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
sqlite3Pragma	pragma.c	/^void sqlite3Pragma($/;"	f
sqlite3PutVarint	util.c	/^int sqlite3PutVarint(unsigned char *p, u64 v)$/;"	f
sqlite3Randomness	random.c	/^void sqlite3Randomness(int N, void *pBuf){$/;"	f
sqlite3ReadSchema	prepare.c	/^int sqlite3ReadSchema(Parse *pParse){$/;"	f
sqlite3ReadUtf8	utf.c	/^int sqlite3ReadUtf8(const unsigned char *z){$/;"	f
sqlite3Realloc	util.c	/^void *sqlite3Realloc(void *p, int n)$/;"	f
sqlite3Realloc_	util.c	/^void *sqlite3Realloc_(void *oldP, int n, char *zFile, int line)$/;"	f
sqlite3RefillIndex	build.c	/^static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){$/;"	f	file:
sqlite3RegisterBuiltinFunctions	func.c	/^void sqlite3RegisterBuiltinFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterDateTimeFunctions	date.c	/^void sqlite3RegisterDateTimeFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterExpr	expr.c	/^Expr *sqlite3RegisterExpr(Parse *pParse, Token *pToken){$/;"	f
sqlite3Reindex	build.c	/^void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ResetInternalSchema	build.c	/^void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){$/;"	f
sqlite3ResultSetOfSelect	select.c	/^Table *sqlite3ResultSetOfSelect(Parse *pParse, char *zTabName, Select *pSelect){$/;"	f
sqlite3RollbackAll	main.c	/^void sqlite3RollbackAll(sqlite3 *db)$/;"	f
sqlite3RollbackInternalChanges	build.c	/^void sqlite3RollbackInternalChanges(sqlite3 *db){$/;"	f
sqlite3RollbackTransaction	build.c	/^void sqlite3RollbackTransaction(Parse *pParse){$/;"	f
sqlite3RootPageMoved	build.c	/^void sqlite3RootPageMoved(Db *pDb, int iFrom, int iTo){$/;"	f
sqlite3RunParser	tokenize.c	/^int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){$/;"	f
sqlite3RunVacuum	vacuum.c	/^int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){$/;"	f
sqlite3SafetyCheck	util.c	/^BOOL sqlite3SafetyCheck(sqlite3 *db)$/;"	f
sqlite3SafetyOff	util.c	/^BOOL sqlite3SafetyOff(sqlite3 *db)$/;"	f
sqlite3SafetyOn	util.c	/^BOOL sqlite3SafetyOn(sqlite3 *db)$/;"	f
sqlite3Select	select.c	/^int sqlite3Select($/;"	f
sqlite3SelectDelete	select.c	/^void sqlite3SelectDelete(Select *p){$/;"	f
sqlite3SelectDup	expr.c	/^Select *sqlite3SelectDup(Select *p){$/;"	f
sqlite3SelectNew	select.c	/^Select *sqlite3SelectNew($/;"	f
sqlite3SelectResolve	select.c	/^int sqlite3SelectResolve($/;"	f
sqlite3SetCrashParams	os_test.c	/^void sqlite3SetCrashParams(int iDelay, char const *zFile){$/;"	f
sqlite3SetString	util.c	/^void sqlite3SetString(STRPTR *pz, ...)$/;"	f
sqlite3SrcListAddAlias	build.c	/^void sqlite3SrcListAddAlias(SrcList *pList, Token *pToken){$/;"	f
sqlite3SrcListAppend	build.c	/^SrcList *sqlite3SrcListAppend(SrcList *pList, Token *pTable, Token *pDatabase){$/;"	f
sqlite3SrcListAssignCursors	build.c	/^void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){$/;"	f
sqlite3SrcListDelete	build.c	/^void sqlite3SrcListDelete(SrcList *pList){$/;"	f
sqlite3SrcListDup	expr.c	/^SrcList *sqlite3SrcListDup(SrcList *p){$/;"	f
sqlite3SrcListLookup	delete.c	/^Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3StartTable	build.c	/^void sqlite3StartTable($/;"	f
sqlite3StrDup	util.c	/^char *sqlite3StrDup(const char *z)$/;"	f
sqlite3StrDup_	util.c	/^char *sqlite3StrDup_(const char *z, char *zFile, int line)$/;"	f
sqlite3StrICmp	util.c	/^int sqlite3StrICmp(const char *zLeft, const char *zRight)$/;"	f
sqlite3StrNDup	util.c	/^char *sqlite3StrNDup(const char *z, int n)$/;"	f
sqlite3StrNDup_	util.c	/^char *sqlite3StrNDup_(const char *z, int n, char *zFile, int line)$/;"	f
sqlite3StrNICmp	util.c	/^int sqlite3StrNICmp(const char *zLeft, const char *zRight, int N)$/;"	f
sqlite3TableAffinityStr	insert.c	/^void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){$/;"	f
sqlite3TextToPtr	util.c	/^void *sqlite3TextToPtr(const char *z)$/;"	f
sqlite3TokenCopy	expr.c	/^void sqlite3TokenCopy(Token *pTo, Token *pFrom){$/;"	f
sqlite3TriggerDeleteStep	trigger.c	/^TriggerStep *sqlite3TriggerDeleteStep(Token *pTableName, Expr *pWhere){$/;"	f
sqlite3TriggerInsertStep	trigger.c	/^TriggerStep *sqlite3TriggerInsertStep($/;"	f
sqlite3TriggerSelectStep	trigger.c	/^TriggerStep *sqlite3TriggerSelectStep(Select *pSelect){$/;"	f
sqlite3TriggerUpdateStep	trigger.c	/^TriggerStep *sqlite3TriggerUpdateStep($/;"	f
sqlite3TriggersExist	sqliteInt.h	1510;"	d
sqlite3TriggersExist	trigger.c	/^int sqlite3TriggersExist($/;"	f
sqlite3TwoPartName	build.c	/^int sqlite3TwoPartName($/;"	f
sqlite3UnlinkAndDeleteIndex	build.c	/^void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){$/;"	f
sqlite3UnlinkAndDeleteTable	build.c	/^void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){$/;"	f
sqlite3UnlinkAndDeleteTrigger	sqliteInt.h	1513;"	d
sqlite3UnlinkAndDeleteTrigger	trigger.c	/^void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){$/;"	f
sqlite3Update	update.c	/^void sqlite3Update($/;"	f
sqlite3UpperToLower	tool/mkkeywordhash.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3UpperToLower	util.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3VMPrintf	printf.c	/^char *sqlite3VMPrintf(const char *zFormat, va_list ap)$/;"	f
sqlite3Vacuum	vacuum.c	/^void sqlite3Vacuum(Parse *pParse, Token *pTableName){$/;"	f
sqlite3ValueApplyAffinity	vdbe.c	/^void sqlite3ValueApplyAffinity(sqlite3_value *pVal, u8 affinity, u8 enc){$/;"	f
sqlite3ValueBytes	vdbemem.c	/^int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){$/;"	f
sqlite3ValueFree	vdbemem.c	/^void sqlite3ValueFree(sqlite3_value *v){$/;"	f
sqlite3ValueFromExpr	vdbemem.c	/^int sqlite3ValueFromExpr($/;"	f
sqlite3ValueNew	vdbemem.c	/^sqlite3_value* sqlite3ValueNew(){$/;"	f
sqlite3ValueSetStr	vdbemem.c	/^void sqlite3ValueSetStr($/;"	f
sqlite3ValueText	vdbemem.c	/^const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){$/;"	f
sqlite3VarintLen	util.c	/^int sqlite3VarintLen(u64 v)$/;"	f
sqlite3VdbeAddOp	vdbeaux.c	/^int sqlite3VdbeAddOp(Vdbe *p, int op, int p1, int p2){$/;"	f
sqlite3VdbeAddOpList	vdbeaux.c	/^int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){$/;"	f
sqlite3VdbeAggReset	vdbeaux.c	/^int sqlite3VdbeAggReset(sqlite3 *db, Agg *pAgg, KeyInfo *pKeyInfo){$/;"	f
sqlite3VdbeChangeEncoding	vdbemem.c	/^int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){$/;"	f
sqlite3VdbeChangeP1	vdbeaux.c	/^void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP2	vdbeaux.c	/^void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){$/;"	f
sqlite3VdbeChangeP3	vdbeaux.c	/^void sqlite3VdbeChangeP3(Vdbe *p, int addr, const char *zP3, int n){$/;"	f
sqlite3VdbeComment	vdbeaux.c	/^void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeCountChanges	vdbeaux.c	/^void sqlite3VdbeCountChanges(Vdbe *v){$/;"	f
sqlite3VdbeCreate	vdbeaux.c	/^Vdbe *sqlite3VdbeCreate(sqlite3 *db){$/;"	f
sqlite3VdbeCurrentAddr	vdbeaux.c	/^int sqlite3VdbeCurrentAddr(Vdbe *p){$/;"	f
sqlite3VdbeCursorMoveto	vdbeaux.c	/^int sqlite3VdbeCursorMoveto(Cursor *p){$/;"	f
sqlite3VdbeDb	vdbeaux.c	/^sqlite3 *sqlite3VdbeDb(Vdbe *v){$/;"	f
sqlite3VdbeDelete	vdbeaux.c	/^void sqlite3VdbeDelete(Vdbe *p){$/;"	f
sqlite3VdbeDeleteAuxData	vdbeaux.c	/^void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){$/;"	f
sqlite3VdbeDequoteP3	vdbeaux.c	/^void sqlite3VdbeDequoteP3(Vdbe *p, int addr){$/;"	f
sqlite3VdbeExec	vdbe.c	/^int sqlite3VdbeExec($/;"	f
sqlite3VdbeFinalize	vdbeaux.c	/^int sqlite3VdbeFinalize(Vdbe *p){$/;"	f
sqlite3VdbeFindOp	vdbeaux.c	/^int sqlite3VdbeFindOp(Vdbe *p, int addr, int op, int p2){$/;"	f
sqlite3VdbeFreeCursor	vdbeaux.c	/^void sqlite3VdbeFreeCursor(Cursor *pCx){$/;"	f
sqlite3VdbeGetOp	vdbeaux.c	/^VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){$/;"	f
sqlite3VdbeHalt	vdbeaux.c	/^int sqlite3VdbeHalt(Vdbe *p){$/;"	f
sqlite3VdbeIdxKeyCompare	vdbeaux.c	/^int sqlite3VdbeIdxKeyCompare($/;"	f
sqlite3VdbeIdxRowid	vdbeaux.c	/^int sqlite3VdbeIdxRowid(BtCursor *pCur, i64 *rowid){$/;"	f
sqlite3VdbeIdxRowidLen	vdbeaux.c	/^int sqlite3VdbeIdxRowidLen(int nKey, const u8 *aKey){$/;"	f
sqlite3VdbeIntValue	vdbemem.c	/^i64 sqlite3VdbeIntValue(Mem *pMem){$/;"	f
sqlite3VdbeKeylistFree	vdbeaux.c	/^void sqlite3VdbeKeylistFree(Keylist *p){$/;"	f
sqlite3VdbeList	vdbeaux.c	/^int sqlite3VdbeList($/;"	f
sqlite3VdbeMakeLabel	vdbeaux.c	/^int sqlite3VdbeMakeLabel(Vdbe *p){$/;"	f
sqlite3VdbeMakeReady	vdbeaux.c	/^void sqlite3VdbeMakeReady($/;"	f
sqlite3VdbeMemCopy	vdbemem.c	/^int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){$/;"	f
sqlite3VdbeMemDynamicify	vdbemem.c	/^int sqlite3VdbeMemDynamicify(Mem *pMem){$/;"	f
sqlite3VdbeMemFromBtree	vdbemem.c	/^int sqlite3VdbeMemFromBtree($/;"	f
sqlite3VdbeMemHandleBom	utf.c	/^int sqlite3VdbeMemHandleBom(Mem *pMem){$/;"	f
sqlite3VdbeMemIntegerify	vdbemem.c	/^int sqlite3VdbeMemIntegerify(Mem *pMem){$/;"	f
sqlite3VdbeMemMakeWriteable	vdbemem.c	/^int sqlite3VdbeMemMakeWriteable(Mem *pMem){$/;"	f
sqlite3VdbeMemMove	vdbemem.c	/^int sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){$/;"	f
sqlite3VdbeMemNulTerminate	vdbemem.c	/^int sqlite3VdbeMemNulTerminate(Mem *pMem){$/;"	f
sqlite3VdbeMemPrettyPrint	vdbe.c	/^void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf, int nBuf){$/;"	f
sqlite3VdbeMemRealify	vdbemem.c	/^int sqlite3VdbeMemRealify(Mem *pMem){$/;"	f
sqlite3VdbeMemRelease	vdbemem.c	/^void sqlite3VdbeMemRelease(Mem *p){$/;"	f
sqlite3VdbeMemSanity	vdbemem.c	/^void sqlite3VdbeMemSanity(Mem *pMem, u8 db_enc){$/;"	f
sqlite3VdbeMemSetDouble	vdbemem.c	/^void sqlite3VdbeMemSetDouble(Mem *pMem, double val){$/;"	f
sqlite3VdbeMemSetInt64	vdbemem.c	/^void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){$/;"	f
sqlite3VdbeMemSetNull	vdbemem.c	/^void sqlite3VdbeMemSetNull(Mem *pMem){$/;"	f
sqlite3VdbeMemSetStr	vdbemem.c	/^int sqlite3VdbeMemSetStr($/;"	f
sqlite3VdbeMemShallowCopy	vdbemem.c	/^void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){$/;"	f
sqlite3VdbeMemStringify	vdbemem.c	/^int sqlite3VdbeMemStringify(Mem *pMem, int enc){$/;"	f
sqlite3VdbeMemTranslate	utf.c	/^int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){$/;"	f
sqlite3VdbeOp3	vdbeaux.c	/^int sqlite3VdbeOp3(Vdbe *p, int op, int p1, int p2, const char *zP3,int p3type){$/;"	f
sqlite3VdbeOpcodeNoPush	vdbeaux.c	/^int sqlite3VdbeOpcodeNoPush(u8 op){$/;"	f
sqlite3VdbePrintOp	vdbeaux.c	/^void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){$/;"	f
sqlite3VdbePrintSql	vdbeaux.c	/^void sqlite3VdbePrintSql(Vdbe *p){$/;"	f
sqlite3VdbeRealValue	vdbemem.c	/^double sqlite3VdbeRealValue(Mem *pMem){$/;"	f
sqlite3VdbeRecordCompare	vdbeaux.c	/^int sqlite3VdbeRecordCompare($/;"	f
sqlite3VdbeReset	vdbeaux.c	/^int sqlite3VdbeReset(Vdbe *p){$/;"	f
sqlite3VdbeResolveLabel	vdbeaux.c	/^void sqlite3VdbeResolveLabel(Vdbe *p, int x){$/;"	f
sqlite3VdbeSerialGet	vdbeaux.c	/^int sqlite3VdbeSerialGet($/;"	f
sqlite3VdbeSerialPut	vdbeaux.c	/^int sqlite3VdbeSerialPut(unsigned char *buf, Mem *pMem){$/;"	f
sqlite3VdbeSerialType	vdbeaux.c	/^u32 sqlite3VdbeSerialType(Mem *pMem){$/;"	f
sqlite3VdbeSerialTypeLen	vdbeaux.c	/^int sqlite3VdbeSerialTypeLen(u32 serial_type){$/;"	f
sqlite3VdbeSetChanges	vdbeaux.c	/^void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){$/;"	f
sqlite3VdbeSetColName	vdbeaux.c	/^int sqlite3VdbeSetColName(Vdbe *p, int idx, const char *zName, int N){$/;"	f
sqlite3VdbeSetNumCols	vdbeaux.c	/^void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){$/;"	f
sqlite3VdbeSorterReset	vdbeaux.c	/^void sqlite3VdbeSorterReset(Vdbe *p){$/;"	f
sqlite3VdbeTrace	vdbeaux.c	/^void sqlite3VdbeTrace(Vdbe *p, FILE *trace){$/;"	f
sqlite3ViewGetColumnNames	build.c	/^int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){$/;"	f
sqlite3ViewGetColumnNames	sqliteInt.h	1410;"	d
sqlite3WhereBegin	where.c	/^WhereInfo *sqlite3WhereBegin($/;"	f
sqlite3WhereEnd	where.c	/^void sqlite3WhereEnd(WhereInfo *pWInfo){$/;"	f
sqlite3_aggregate_context	vdbeapi.c	/^void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){$/;"	f
sqlite3_aggregate_count	vdbeapi.c	/^int sqlite3_aggregate_count(sqlite3_context *p){$/;"	f
sqlite3_bind_blob	vdbeapi.c	/^int sqlite3_bind_blob($/;"	f
sqlite3_bind_double	vdbeapi.c	/^int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){$/;"	f
sqlite3_bind_int	vdbeapi.c	/^int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){$/;"	f
sqlite3_bind_int64	vdbeapi.c	/^int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){$/;"	f
sqlite3_bind_null	vdbeapi.c	/^int sqlite3_bind_null(sqlite3_stmt* p, int i){$/;"	f
sqlite3_bind_parameter_count	vdbeapi.c	/^int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_bind_parameter_index	vdbeapi.c	/^int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){$/;"	f
sqlite3_bind_parameter_name	vdbeapi.c	/^const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_text	vdbeapi.c	/^int sqlite3_bind_text( $/;"	f
sqlite3_bind_text16	vdbeapi.c	/^int sqlite3_bind_text16($/;"	f
sqlite3_btree_trace	btree.c	/^int sqlite3_btree_trace=0;  \/* True to enable tracing *\/$/;"	v
sqlite3_busy_handler	main.c	/^int sqlite3_busy_handler($/;"	f
sqlite3_busy_timeout	main.c	/^int sqlite3_busy_timeout(sqlite3 *db, int ms)$/;"	f
sqlite3_callback	sqlite3.h	/^typedef int (*sqlite3_callback)(void*,int,char**, char**);$/;"	t
sqlite3_changes	main.c	/^int sqlite3_changes(sqlite3 *db)$/;"	f
sqlite3_clear_bindings	experimental.c	/^int sqlite3_clear_bindings(sqlite3_stmt *pStmt){$/;"	f
sqlite3_close	main.c	/^int sqlite3_close(sqlite3 *db)$/;"	f
sqlite3_collation_needed	main.c	/^int sqlite3_collation_needed($/;"	f
sqlite3_collation_needed16	main.c	/^int sqlite3_collation_needed16($/;"	f
sqlite3_column_blob	vdbeapi.c	/^const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes	vdbeapi.c	/^int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes16	vdbeapi.c	/^int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_count	vdbeapi.c	/^int sqlite3_column_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_column_database_name	vdbeapi.c	/^const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_database_name16	vdbeapi.c	/^const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype	vdbeapi.c	/^const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype16	vdbeapi.c	/^const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_double	vdbeapi.c	/^double sqlite3_column_double(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int	vdbeapi.c	/^int sqlite3_column_int(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int64	vdbeapi.c	/^sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_name	vdbeapi.c	/^const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_name16	vdbeapi.c	/^const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name	vdbeapi.c	/^const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name16	vdbeapi.c	/^const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name	vdbeapi.c	/^const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name16	vdbeapi.c	/^const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_text	vdbeapi.c	/^const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_text16	vdbeapi.c	/^const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_type	vdbeapi.c	/^int sqlite3_column_type(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_commit_hook	main.c	/^void *sqlite3_commit_hook($/;"	f
sqlite3_complete	tokenize.c	/^int sqlite3_complete(const char *zSql){$/;"	f
sqlite3_complete16	tokenize.c	/^int sqlite3_complete16(const void *zSql){$/;"	f
sqlite3_context	sqlite3.h	/^typedef struct sqlite3_context sqlite3_context;$/;"	t
sqlite3_context	vdbeInt.h	/^struct sqlite3_context {$/;"	s
sqlite3_create_collation	main.c	/^int sqlite3_create_collation($/;"	f
sqlite3_create_collation16	main.c	/^int sqlite3_create_collation16($/;"	f
sqlite3_create_function	main.c	/^int sqlite3_create_function($/;"	f
sqlite3_create_function16	main.c	/^int sqlite3_create_function16($/;"	f
sqlite3_current_time	os_aros.c	/^int sqlite3_current_time = 0;$/;"	v
sqlite3_data_count	vdbeapi.c	/^int sqlite3_data_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_db_handle	vdbeapi.c	/^sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){$/;"	f
sqlite3_diskfull_pending	os_common.h	/^int sqlite3_diskfull_pending = 0;$/;"	v
sqlite3_errcode	main.c	/^int sqlite3_errcode(sqlite3 *db)$/;"	f
sqlite3_errmsg	main.c	/^const char *sqlite3_errmsg(sqlite3 *db)$/;"	f
sqlite3_errmsg16	main.c	/^const void *sqlite3_errmsg16(sqlite3 *db)$/;"	f
sqlite3_exec	legacy.c	/^int sqlite3_exec($/;"	f
sqlite3_expired	vdbeapi.c	/^int sqlite3_expired(sqlite3_stmt *pStmt){$/;"	f
sqlite3_finalize	main.c	/^int sqlite3_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_free	main.c	/^void sqlite3_free(char *p){ free(p); }$/;"	f
sqlite3_free_table	table.c	/^void sqlite3_free_table($/;"	f
sqlite3_fullsync_count	os_aros.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_get_autocommit	main.c	/^int sqlite3_get_autocommit(sqlite3 *db){$/;"	f
sqlite3_get_auxdata	vdbeapi.c	/^void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){$/;"	f
sqlite3_get_table	table.c	/^int sqlite3_get_table($/;"	f
sqlite3_get_table_cb	table.c	/^static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){$/;"	f	file:
sqlite3_global_recover	main.c	/^int sqlite3_global_recover(){$/;"	f
sqlite3_iMallocFail	util.c	/^int sqlite3_iMallocFail;     \/* Fail sqliteMalloc() after this many calls *\/$/;"	v
sqlite3_iMallocReset	util.c	/^int sqlite3_iMallocReset = -1; \/* When iMallocFail reaches 0, set to this *\/$/;"	v
sqlite3_interrupt	main.c	/^void sqlite3_interrupt(sqlite3 *db)$/;"	f
sqlite3_interrupt_count	vdbe.c	/^int sqlite3_interrupt_count = 0;$/;"	v
sqlite3_io_error_pending	os_common.h	/^int sqlite3_io_error_pending = 0;$/;"	v
sqlite3_last_insert_rowid	main.c	/^sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db)$/;"	f
sqlite3_libversion	main.c	/^const char *sqlite3_libversion(void){ return sqlite3_version; }$/;"	f
sqlite3_libversion_number	main.c	/^int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }$/;"	f
sqlite3_malloc_failed	util.c	/^int sqlite3_malloc_failed = 0;$/;"	v
sqlite3_mprintf	printf.c	/^char *sqlite3_mprintf(const char *zFormat, ...)$/;"	f
sqlite3_nFree	util.c	/^int sqlite3_nFree;           \/* Number of sqliteFree() calls *\/$/;"	v
sqlite3_nMalloc	util.c	/^int sqlite3_nMalloc;         \/* Number of sqliteMalloc() calls *\/$/;"	v
sqlite3_open	main.c	/^int sqlite3_open( const char *zFilename, sqlite3 **ppDb )$/;"	f
sqlite3_open16	main.c	/^int sqlite3_open16( const void *zFilename, sqlite3 **ppDb )$/;"	f
sqlite3_open_file_count	os_common.h	/^int sqlite3_open_file_count = 0;$/;"	v
sqlite3_opentemp_count	pager.c	/^int sqlite3_opentemp_count = 0;$/;"	v
sqlite3_os_trace	os_common.h	/^int sqlite3_os_trace = 0;$/;"	v
sqlite3_prepare	prepare.c	/^int sqlite3_prepare($/;"	f
sqlite3_prepare16	prepare.c	/^int sqlite3_prepare16($/;"	f
sqlite3_progress_handler	main.c	/^void sqlite3_progress_handler($/;"	f
sqlite3_reset	main.c	/^int sqlite3_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_result_blob	vdbeapi.c	/^void sqlite3_result_blob($/;"	f
sqlite3_result_double	vdbeapi.c	/^void sqlite3_result_double(sqlite3_context *pCtx, double rVal){$/;"	f
sqlite3_result_error	vdbeapi.c	/^void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){$/;"	f
sqlite3_result_error16	vdbeapi.c	/^void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){$/;"	f
sqlite3_result_int	vdbeapi.c	/^void sqlite3_result_int(sqlite3_context *pCtx, int iVal){$/;"	f
sqlite3_result_int64	vdbeapi.c	/^void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){$/;"	f
sqlite3_result_null	vdbeapi.c	/^void sqlite3_result_null(sqlite3_context *pCtx){$/;"	f
sqlite3_result_text	vdbeapi.c	/^void sqlite3_result_text($/;"	f
sqlite3_result_text16	vdbeapi.c	/^void sqlite3_result_text16($/;"	f
sqlite3_result_text16be	vdbeapi.c	/^void sqlite3_result_text16be($/;"	f
sqlite3_result_text16le	vdbeapi.c	/^void sqlite3_result_text16le($/;"	f
sqlite3_result_value	vdbeapi.c	/^void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){$/;"	f
sqlite3_search_count	vdbe.c	/^int sqlite3_search_count = 0;$/;"	v
sqlite3_set_authorizer	auth.c	/^int sqlite3_set_authorizer($/;"	f
sqlite3_set_auxdata	vdbeapi.c	/^void sqlite3_set_auxdata($/;"	f
sqlite3_sleep	experimental.c	/^int sqlite3_sleep(int ms){$/;"	f
sqlite3_snprintf	printf.c	/^char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...)$/;"	f
sqlite3_sort_count	vdbe.c	/^int sqlite3_sort_count = 0;$/;"	v
sqlite3_step	vdbeapi.c	/^int sqlite3_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt	sqlite3.h	/^typedef struct sqlite3_stmt sqlite3_stmt;$/;"	t
sqlite3_sync_count	os_aros.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_temp_directory	os_aros.c	/^STRPTR sqlite3_temp_directory = NULL;$/;"	v
sqlite3_total_changes	main.c	/^int sqlite3_total_changes(sqlite3 *db)$/;"	f
sqlite3_trace	main.c	/^void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg)$/;"	f
sqlite3_transfer_bindings	vdbeapi.c	/^int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){$/;"	f
sqlite3_user_data	vdbeapi.c	/^void *sqlite3_user_data(sqlite3_context *p){$/;"	f
sqlite3_value	sqlite3.h	/^typedef struct Mem sqlite3_value;$/;"	t
sqlite3_value_blob	vdbeapi.c	/^const void *sqlite3_value_blob(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes	vdbeapi.c	/^int sqlite3_value_bytes(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes16	vdbeapi.c	/^int sqlite3_value_bytes16(sqlite3_value *pVal){$/;"	f
sqlite3_value_double	vdbeapi.c	/^double sqlite3_value_double(sqlite3_value *pVal){$/;"	f
sqlite3_value_int	vdbeapi.c	/^int sqlite3_value_int(sqlite3_value *pVal){$/;"	f
sqlite3_value_int64	vdbeapi.c	/^sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){$/;"	f
sqlite3_value_text	vdbeapi.c	/^const unsigned char *sqlite3_value_text(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16	vdbeapi.c	/^const void *sqlite3_value_text16(sqlite3_value* pVal){$/;"	f
sqlite3_value_text16be	vdbeapi.c	/^const void *sqlite3_value_text16be(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16le	vdbeapi.c	/^const void *sqlite3_value_text16le(sqlite3_value *pVal){$/;"	f
sqlite3_value_type	vdbeapi.c	/^int sqlite3_value_type(sqlite3_value* pVal){$/;"	f
sqlite3_vdbe_addop_trace	vdbeaux.c	/^int sqlite3_vdbe_addop_trace = 0;$/;"	v
sqlite3_version	main.c	/^const char sqlite3_version[] = SQLITE_VERSION;$/;"	v
sqlite3_vmprintf	printf.c	/^char *sqlite3_vmprintf(const char *zFormat, va_list ap)$/;"	f
sqlite3atoi64	util.c	/^BOOL sqlite3atoi64(const char *zNum, i64 *pNum)$/;"	f
sqlite3one	main.c	/^const int sqlite3one = 1;$/;"	v
sqlite3pager_begin	pager.c	/^int sqlite3pager_begin(void *pData, int exFlag){$/;"	f
sqlite3pager_close	pager.c	/^int sqlite3pager_close(Pager *pPager){$/;"	f
sqlite3pager_commit	pager.c	/^int sqlite3pager_commit(Pager *pPager){$/;"	f
sqlite3pager_dirname	pager.c	/^const char *sqlite3pager_dirname(Pager *pPager){$/;"	f
sqlite3pager_dont_rollback	pager.c	/^void sqlite3pager_dont_rollback(void *pData){$/;"	f
sqlite3pager_dont_write	pager.c	/^void sqlite3pager_dont_write(Pager *pPager, Pgno pgno){$/;"	f
sqlite3pager_filename	pager.c	/^const char *sqlite3pager_filename(Pager *pPager){$/;"	f
sqlite3pager_get	pager.c	/^int sqlite3pager_get(Pager *pPager, Pgno pgno, void **ppPage){$/;"	f
sqlite3pager_isreadonly	pager.c	/^int sqlite3pager_isreadonly(Pager *pPager){$/;"	f
sqlite3pager_iswriteable	pager.c	/^int sqlite3pager_iswriteable(void *pData){$/;"	f
sqlite3pager_journalname	pager.c	/^const char *sqlite3pager_journalname(Pager *pPager){$/;"	f
sqlite3pager_lockstate	pager.c	/^int sqlite3pager_lockstate(Pager *pPager){$/;"	f
sqlite3pager_lookup	pager.c	/^void *sqlite3pager_lookup(Pager *pPager, Pgno pgno){$/;"	f
sqlite3pager_movepage	pager.c	/^int sqlite3pager_movepage(Pager *pPager, void *pData, Pgno pgno){$/;"	f
sqlite3pager_open	pager.c	/^int sqlite3pager_open($/;"	f
sqlite3pager_opentemp	pager.c	/^static int sqlite3pager_opentemp(char *zFile, OsFile *fd){$/;"	f	file:
sqlite3pager_overwrite	pager.c	/^int sqlite3pager_overwrite(Pager *pPager, Pgno pgno, void *pData){$/;"	f
sqlite3pager_pagecount	pager.c	/^int sqlite3pager_pagecount(Pager *pPager){$/;"	f
sqlite3pager_pagenumber	pager.c	/^Pgno sqlite3pager_pagenumber(void *pData){$/;"	f
sqlite3pager_read_fileheader	pager.c	/^void sqlite3pager_read_fileheader(Pager *pPager, int N, unsigned char *pDest){$/;"	f
sqlite3pager_ref	pager.c	/^int sqlite3pager_ref(void *pData){$/;"	f
sqlite3pager_refdump	pager.c	/^void sqlite3pager_refdump(Pager *pPager){$/;"	f
sqlite3pager_reset	pager.c	/^int sqlite3pager_reset(Pager *pPager){$/;"	f
sqlite3pager_rollback	pager.c	/^int sqlite3pager_rollback(Pager *pPager){$/;"	f
sqlite3pager_set_busyhandler	pager.c	/^void sqlite3pager_set_busyhandler(Pager *pPager, BusyHandler *pBusyHandler){$/;"	f
sqlite3pager_set_cachesize	pager.c	/^void sqlite3pager_set_cachesize(Pager *pPager, int mxPage){$/;"	f
sqlite3pager_set_codec	pager.c	/^void sqlite3pager_set_codec($/;"	f
sqlite3pager_set_destructor	pager.c	/^void sqlite3pager_set_destructor(Pager *pPager, void (*xDesc)(void*,int)){$/;"	f
sqlite3pager_set_pagesize	pager.c	/^int sqlite3pager_set_pagesize(Pager *pPager, int pageSize){$/;"	f
sqlite3pager_set_reiniter	pager.c	/^void sqlite3pager_set_reiniter(Pager *pPager, void (*xReinit)(void*,int)){$/;"	f
sqlite3pager_set_safety_level	pager.c	/^void sqlite3pager_set_safety_level(Pager *pPager, int level){$/;"	f
sqlite3pager_stats	pager.c	/^int *sqlite3pager_stats(Pager *pPager){$/;"	f
sqlite3pager_stmt_begin	pager.c	/^int sqlite3pager_stmt_begin(Pager *pPager){$/;"	f
sqlite3pager_stmt_commit	pager.c	/^int sqlite3pager_stmt_commit(Pager *pPager){$/;"	f
sqlite3pager_stmt_rollback	pager.c	/^int sqlite3pager_stmt_rollback(Pager *pPager){$/;"	f
sqlite3pager_sync	pager.c	/^int sqlite3pager_sync(Pager *pPager, const char *zMaster, Pgno nTrunc){$/;"	f
sqlite3pager_truncate	pager.c	/^int sqlite3pager_truncate(Pager *pPager, Pgno nPage){$/;"	f
sqlite3pager_unref	pager.c	/^int sqlite3pager_unref(void *pData){$/;"	f
sqlite3pager_write	pager.c	/^int sqlite3pager_write(void *pData){$/;"	f
sqlite3utf16ByteLen	utf.c	/^int sqlite3utf16ByteLen(const void *zIn, int nChar){$/;"	f
sqlite3utf16Substr	utf.c	/^void sqlite3utf16Substr($/;"	f
sqlite3utf8CharLen	utf.c	/^int sqlite3utf8CharLen(const char *z, int nByte){$/;"	f
sqlite3utfSelfTest	utf.c	/^void sqlite3utfSelfTest(){$/;"	f
sqliteAuthBadReturnCode	auth.c	/^static void sqliteAuthBadReturnCode(Parse *pParse, int rc){$/;"	f	file:
sqliteCharVal	func.c	319;"	d	file:
sqliteDefaultBusyCallback	main.c	/^static int sqliteDefaultBusyCallback($/;"	f	file:
sqliteDeleteIndex	build.c	/^static void sqliteDeleteIndex(sqlite3 *db, Index *p){$/;"	f	file:
sqliteFree	sqliteInt.h	272;"	d
sqliteFree	sqliteInt.h	277;"	d
sqliteHashCount	hash.h	107;"	d
sqliteHashData	hash.h	100;"	d
sqliteHashFirst	hash.h	98;"	d
sqliteHashKey	hash.h	101;"	d
sqliteHashKeysize	hash.h	102;"	d
sqliteHashNext	hash.h	99;"	d
sqliteMalloc	sqliteInt.h	270;"	d
sqliteMalloc	sqliteInt.h	278;"	d
sqliteMallocRaw	sqliteInt.h	271;"	d
sqliteMallocRaw	sqliteInt.h	279;"	d
sqliteNextChar	func.c	318;"	d	file:
sqlitePersistTriggerStep	trigger.c	/^static void sqlitePersistTriggerStep(TriggerStep *p){$/;"	f	file:
sqliteProcessJoin	select.c	/^static int sqliteProcessJoin(Parse *pParse, Select *p){$/;"	f	file:
sqliteRealloc	sqliteInt.h	273;"	d
sqliteRealloc	sqliteInt.h	280;"	d
sqliteResetColumnNames	build.c	/^static void sqliteResetColumnNames(Table *pTable){$/;"	f	file:
sqliteStrDup	sqliteInt.h	274;"	d
sqliteStrDup	sqliteInt.h	281;"	d
sqliteStrNDup	sqliteInt.h	275;"	d
sqliteStrNDup	sqliteInt.h	282;"	d
sqliteViewResetAll	build.c	/^static void sqliteViewResetAll(sqlite3 *db, int idx){$/;"	f	file:
sqliteViewResetAll	build.c	1590;"	d	file:
sqlite_int64	sqlite3.h	/^  typedef __int64 sqlite_int64;$/;"	t
sqlite_int64	sqlite3.h	/^  typedef long long int sqlite_int64;$/;"	t
sqlite_uint64	sqlite3.h	/^  typedef unsigned __int64 sqlite_uint64;$/;"	t
sqlite_uint64	sqlite3.h	/^  typedef unsigned long long int sqlite_uint64;$/;"	t
stack	www/vdbe.tcl	/^proc stack args {$/;"	p
stacksize	tool/lemon.c	/^  char *stacksize;         \/* Size of the parser stack *\/$/;"	m	struct:lemon	file:
start	tool/lemon.c	/^  char *start;             \/* Name of the start symbol for the grammar *\/$/;"	m	struct:lemon	file:
state	pager.c	/^  u8 state;                   \/* PAGER_UNLOCK, _SHARED, _RESERVED, etc. *\/$/;"	m	struct:Pager	file:
state	tool/lemon.c	/^  } state;                   \/* The state of the parser *\/$/;"	m	struct:pstate	file:
state	tool/lemon.c	/^struct state {$/;"	s	file:
statecmp	tool/lemon.c	/^PRIVATE int statecmp(a,b)$/;"	f
statehash	tool/lemon.c	/^PRIVATE int statehash(a)$/;"	f
stateno	lempar.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
stateno	parse.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
stateno	tool/lempar.c	/^  int stateno;       \/* The state-number *\/$/;"	m	struct:yyStackEntry	file:
statline	tool/spaceanal.tcl	/^proc statline {title value {extra {}}} {$/;"	p
status	tool/lemon.c	/^  } status;$/;"	m	struct:config	file:
step_list	sqliteInt.h	/^  TriggerStep *step_list; \/* Link list of trigger program steps             *\/$/;"	m	struct:Trigger
stepsql	test/tester.tcl	/^proc stepsql {dbptr sql} {$/;"	p
stfd	pager.c	/^  OsFile stfd;                \/* File descriptor for the statement subjournal*\/$/;"	m	struct:Pager	file:
stifle_history	shell.c	54;"	d	file:
stmtAutoopen	pager.c	/^  u8 stmtAutoopen;            \/* Open stmt journal when main journal is opened*\/$/;"	m	struct:Pager	file:
stmtCksum	pager.c	/^  i64 stmtCksum;              \/* cksumInit when statement was started *\/$/;"	m	struct:Pager	file:
stmtHdrOff	pager.c	/^  i64 stmtHdrOff;             \/* First journal header written this statement *\/$/;"	m	struct:Pager	file:
stmtInUse	pager.c	/^  u8 stmtInUse;               \/* True we are in a statement subtransaction *\/$/;"	m	struct:Pager	file:
stmtJSize	pager.c	/^  i64 stmtJSize;              \/* Size of journal at stmt_begin() *\/$/;"	m	struct:Pager	file:
stmtLast	tclsqlite.c	/^  SqlPreparedStmt *stmtLast; \/* Last statement in the list *\/$/;"	m	struct:SqliteDb	file:
stmtList	tclsqlite.c	/^  SqlPreparedStmt *stmtList; \/* List of prepared statements*\/$/;"	m	struct:SqliteDb	file:
stmtNRec	pager.c	/^  int stmtNRec;               \/* Number of records in stmt subjournal *\/$/;"	m	struct:Pager	file:
stmtOpen	pager.c	/^  u8 stmtOpen;                \/* True if the statement subjournal is open *\/$/;"	m	struct:Pager	file:
stmtSize	pager.c	/^  int stmtSize;               \/* Size of database (in pages) at stmt_begin() *\/$/;"	m	struct:Pager	file:
store32bits	pager.c	/^static void store32bits(u32 val, PgHdr *p, int offset){$/;"	f	file:
storeTypeInfo	vdbe.c	144;"	d	file:
stp	tool/lemon.c	/^    struct state *stp;     \/* The new state, if a shift *\/$/;"	m	union:action::<anonymous>	file:
stp	tool/lemon.c	/^  struct state *stp;       \/* Pointer to state which contains this *\/$/;"	m	struct:config	file:
stp	tool/lemon.c	/^  struct state *stp;   \/* A pointer to a state *\/$/;"	m	struct:axset	file:
strCompare	hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strHash	hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
stream	www/vdbe.tcl	/^processing stream (see the <a href="arch.html">architecture diagram<\/a>)$/;"	p
strftimeFunc	date.c	/^static void strftimeFunc($/;"	f	file:
strhash	tool/lemon.c	/^PRIVATE int strhash(x)$/;"	f
subreport	tool/spaceanal.tcl	/^proc subreport {title where} {$/;"	p
substExpr	select.c	/^static void substExpr(Expr *pExpr, int iTable, ExprList *pEList){$/;"	f	file:
substExprList	select.c	/^static void substExprList(ExprList *pList, int iTable, ExprList *pEList){$/;"	f	file:
substSelect	select.c	/^static void substSelect(Select *p, int iTable, ExprList *pEList){$/;"	f	file:
substrFunc	func.c	/^static void substrFunc($/;"	f	file:
substrId	tool/mkkeywordhash.c	/^  int substrId;        \/* Id to another keyword this keyword is embedded in *\/$/;"	m	struct:Keyword	file:
substrOffset	tool/mkkeywordhash.c	/^  int substrOffset;    \/* Offset into substrId for start of this keyword *\/$/;"	m	struct:Keyword	file:
sum	func.c	/^  double sum;     \/* Sum of terms *\/$/;"	m	struct:StdDevCtx	file:
sum	func.c	/^  double sum;     \/* Sum of terms *\/$/;"	m	struct:SumCtx	file:
sum2	func.c	/^  double sum2;    \/* Sum of the squares of terms *\/$/;"	m	struct:StdDevCtx	file:
sumFinalize	func.c	/^static void sumFinalize(sqlite3_context *context){$/;"	f	file:
sumStep	func.c	/^static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
symbol	tool/lemon.c	/^struct symbol {$/;"	s	file:
symbols	tool/lemon.c	/^  struct symbol **symbols; \/* Sorted array of pointers to symbols *\/$/;"	m	struct:lemon	file:
syncJournal	pager.c	/^static int syncJournal(Pager *pPager){$/;"	f	file:
synthCollSeq	callback.c	/^static int synthCollSeq(sqlite3 *db, CollSeq *pColl){$/;"	f	file:
table	sqliteInt.h	/^  char *table;            \/* The table or view to which the trigger applies *\/$/;"	m	struct:Trigger
tableOfTrigger	trigger.c	/^static Table *tableOfTrigger(sqlite3 *db, Trigger *pTrigger){$/;"	f	file:
tableOrder	where.c	/^static int tableOrder(SrcList *pList, int iCur){$/;"	f	file:
tablesize	tool/lemon.c	/^  int tablesize;           \/* Size of the parse tables *\/$/;"	m	struct:lemon	file:
target	sqliteInt.h	/^  Token target;        \/* Valid for DELETE, UPDATE, INSERT steps *\/$/;"	m	struct:TriggerStep
targetSrcList	trigger.c	/^static SrcList *targetSrcList($/;"	f	file:
tbl	tool/lemon.c	/^  struct s_x1node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x1	file:
tbl	tool/lemon.c	/^  struct s_x2node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x2	file:
tbl	tool/lemon.c	/^  struct s_x3node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x3	file:
tbl	tool/lemon.c	/^  struct s_x4node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x4	file:
tblHash	sqliteInt.h	/^	Hash tblHash;        \/* All tables indexed by name *\/$/;"	m	struct:Db
tclCollateNeeded	tclsqlite.c	/^static void tclCollateNeeded($/;"	f	file:
tclSqlCollate	tclsqlite.c	/^static int tclSqlCollate($/;"	f	file:
tclSqlFunc	tclsqlite.c	/^static void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){$/;"	f	file:
tcons	parse.y	/^tcons ::= CHECK expr onconf.$/;"	l
tcons	parse.y	/^tcons ::= CONSTRAINT nm.$/;"	l
tcons	parse.y	/^tcons ::= FOREIGN KEY LP idxlist(FA) RP$/;"	l
tcons	parse.y	/^tcons ::= PRIMARY KEY LP idxlist(X) autoinc(I) RP onconf(R).$/;"	l
tcons	parse.y	/^tcons ::= UNIQUE LP idxlist(X) RP onconf(R).$/;"	l
tempFile	pager.c	/^  u8 tempFile;                \/* zFilename is a temporary file *\/$/;"	m	struct:Pager	file:
temp_master_schema	prepare.c	144;"	d	file:
temp_store	sqliteInt.h	/^  u8 temp_store;                \/* 1: file 2: memory 0: default *\/$/;"	m	struct:sqlite3
test_auxdata	func.c	/^static void test_auxdata($/;"	f	file:
test_destructor	func.c	/^static void test_destructor($/;"	f	file:
test_destructor_count	func.c	/^static void test_destructor_count($/;"	f	file:
test_destructor_count_var	func.c	/^static int test_destructor_count_var = 0;$/;"	v	file:
test_error	func.c	/^static void test_error($/;"	f	file:
that	www/different.tcl	/^  process that wants to access the database reads and writes$/;"	p
that	www/lang.tcl	/^process that opened the database and is automatically deleted when$/;"	p
the	www/faq.tcl	/^  process, the default behavior is to return SQLITE_BUSY.  You can$/;"	p
thread_cnt	test/threadtest1.c	/^int thread_cnt = 0;$/;"	v
timeFunc	date.c	/^static void timeFunc($/;"	f	file:
tkCREATE	tokenize.c	447;"	d	file:
tkEND	tokenize.c	450;"	d	file:
tkEXPLAIN	tokenize.c	446;"	d	file:
tkOTHER	tokenize.c	445;"	d	file:
tkSEMI	tokenize.c	443;"	d	file:
tkTEMP	tokenize.c	448;"	d	file:
tkTRIGGER	tokenize.c	449;"	d	file:
tkWS	tokenize.c	444;"	d	file:
tnum	sqliteInt.h	/^  int tnum;        \/* Page containing root of this index in database file *\/$/;"	m	struct:Index
tnum	sqliteInt.h	/^  int tnum;        \/* Root BTree node for this table (see note above) *\/$/;"	m	struct:Table
to	www/fileformat.tcl	/^process to open the database can use the journal file to restore$/;"	p
token	sqliteInt.h	/^  Token token;           \/* An operand token *\/$/;"	m	struct:Expr
tokendest	tool/lemon.c	/^  char *tokendest;         \/* Code to execute to destroy token data *\/$/;"	m	struct:lemon	file:
tokendestln	tool/lemon.c	/^  int  tokendestln;        \/* Line number for token destroyer code *\/$/;"	m	struct:lemon	file:
tokenlineno	tool/lemon.c	/^  int tokenlineno;      \/* Linenumber at which current token starts *\/$/;"	m	struct:pstate	file:
tokenprefix	tool/lemon.c	/^  char *tokenprefix;       \/* A prefix added to token names in the .h file *\/$/;"	m	struct:lemon	file:
tokenstart	tool/lemon.c	/^  char *tokenstart;     \/* Text of current token *\/$/;"	m	struct:pstate	file:
tokentype	tool/lemon.c	/^  char *tokentype;         \/* Type of terminal symbols in the parser stack *\/$/;"	m	struct:lemon	file:
top	sqliteInt.h	/^  int top;             \/* First instruction of interior of the loop *\/$/;"	m	struct:WhereLevel
total_changes	func.c	/^static void total_changes($/;"	f	file:
tplt_linedir	tool/lemon.c	/^PRIVATE void tplt_linedir(out,lineno,filename)$/;"	f
tplt_open	tool/lemon.c	/^PRIVATE FILE *tplt_open(lemp)$/;"	f
tplt_print	tool/lemon.c	/^PRIVATE void tplt_print(out,lemp,str,strln,lineno)$/;"	f
tplt_xfer	tool/lemon.c	/^PRIVATE void tplt_xfer(name,in,out,lineno)$/;"	f
tr_tm	sqliteInt.h	/^  u8 tr_tm;               \/* One of TRIGGER_BEFORE, TRIGGER_AFTER *\/$/;"	m	struct:Trigger
trace	vdbeInt.h	/^  FILE *trace;        \/* Write an execution trace here, if not NULL *\/$/;"	m	struct:Vdbe
trans_opt	parse.y	/^trans_opt ::= .$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION nm.$/;"	l
trans_opt	parse.y	/^trans_opt ::= TRANSACTION.$/;"	l
translate_code	tool/lemon.c	/^PRIVATE void translate_code(struct lemon *lemp, struct rule *rp){$/;"	f
trigHash	sqliteInt.h	/^	Hash trigHash;       \/* All triggers indexed by name *\/$/;"	m	struct:Db
trigStack	sqliteInt.h	/^  TriggerStack *trigStack;  \/* Trigger actions being coded *\/$/;"	m	struct:Parse
triggers_exist	delete.c	126;"	d	file:
triggers_exist	insert.c	251;"	d	file:
triggers_exist	update.c	114;"	d	file:
type	parse.c	/^struct AttachKey { int type;  Token key; };$/;"	m	struct:AttachKey	file:
type	parse.y	/^type ::= .$/;"	l
type	parse.y	/^type ::= typename(X) LP signed COMMA signed RP(Y).$/;"	l
type	parse.y	/^type ::= typename(X) LP signed RP(Y).    {sqlite3AddColumnType(pParse,&X,&Y);}$/;"	l
type	parse.y	/^type ::= typename(X).                    {sqlite3AddColumnType(pParse,&X,&X);}$/;"	l
type	printf.c	/^	etByte type;           \/* Conversion paradigm *\/$/;"	m	struct:et_info	file:
type	tool/lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR} type;$/;"	m	struct:s_options	file:
type	tool/lemon.c	/^  } type;                  \/* Symbols are all either TERMINALS or NTs *\/$/;"	m	struct:symbol	file:
type	tool/lemon.c	/^  } type;$/;"	m	struct:action	file:
type	vdbeInt.h	/^  u8  type;           \/* One of MEM_Null, MEM_Str, etc. *\/$/;"	m	struct:Mem
typeofFunc	func.c	/^static void typeofFunc($/;"	f	file:
tz	date.c	/^  int tz;          \/* Timezone offset in minutes *\/$/;"	m	struct:DateTime	file:
u16	sqliteInt.h	/^typedef UINT16_TYPE u16;           \/* 2-byte unsigned integer *\/$/;"	t
u32	sqliteInt.h	/^typedef UINT32_TYPE u32;           \/* 4-byte unsigned integer *\/$/;"	t
u64	sqliteInt.h	/^typedef UINT64_TYPE u64;           \/* 8-byte unsigned integer *\/$/;"	t
u8	sqliteInt.h	/^typedef UINT8_TYPE u8;             \/* 1-byte unsigned integer *\/$/;"	t
uint32	md5.c	44;"	d	file:
uniqueCnt	vdbeInt.h	/^  unsigned uniqueCnt;     \/* Used by OP_MakeRecord when P2!=0 *\/$/;"	m	struct:Vdbe
unlinkHashChain	pager.c	/^static void unlinkHashChain(Pager *pPager, PgHdr *pPg){$/;"	f	file:
unlinkPage	pager.c	/^static void unlinkPage(PgHdr *pPg){$/;"	f	file:
unlockBtreeIfUnused	btree.c	/^static void unlockBtreeIfUnused(Btree *pBt){$/;"	f	file:
updateConf	sqliteInt.h	/^  u8 updateConf;    \/* How to resolve conflicts that occur on UPDATE *\/$/;"	m	struct:FKey
upperFunc	func.c	/^static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
usableSize	btree.c	/^  u16 usableSize;       \/* Number of usable bytes on each page *\/$/;"	m	struct:Btree	file:
usage	shell.c	/^static void usage(BOOL showDetail)$/;"	f	file:
usage	tool/memleak3.tcl	/^proc usage {} {$/;"	p
useJournal	pager.c	/^  u8 useJournal;              \/* Use a rollback journal on this file *\/$/;"	m	struct:Pager	file:
useRandomRowid	vdbeInt.h	/^  Bool useRandomRowid;  \/* Generate new record numbers semi-randomly *\/$/;"	m	struct:Cursor
valid	shell.c	/^	int valid;        \/* Is there legit data in here? *\/$/;"	m	struct:previous_mode_data	file:
validHMS	date.c	/^  char validHMS;   \/* True if h,m,s are valid *\/$/;"	m	struct:DateTime	file:
validJD	date.c	/^  char validJD;    \/* True if rJD is valid *\/$/;"	m	struct:DateTime	file:
validTZ	date.c	/^  char validTZ;    \/* True if tz is valid *\/$/;"	m	struct:DateTime	file:
validYMD	date.c	/^  char validYMD;   \/* True if Y,M,D are valid *\/$/;"	m	struct:DateTime	file:
value	parse.c	/^  struct {int value; int mask;} yy47;$/;"	m	file:
vardest	tool/lemon.c	/^  char *vardest;           \/* Code for the default non-terminal destructor *\/$/;"	m	struct:lemon	file:
vardestln	tool/lemon.c	/^  int  vardestln;          \/* Line number for default non-term destructor code*\/$/;"	m	struct:lemon	file:
vartype	tool/lemon.c	/^  char *vartype;           \/* The default type of non-terminal symbols *\/$/;"	m	struct:lemon	file:
vdbeCommit	vdbeaux.c	/^static int vdbeCommit(sqlite3 *db){$/;"	f	file:
vdbeUnbind	vdbeapi.c	/^static int vdbeUnbind(Vdbe *p, int i){$/;"	f	file:
verbose	test/threadtest1.c	/^static int verbose = 0;$/;"	v	file:
versionFunc	func.c	/^static void versionFunc($/;"	f	file:
vxprintf	printf.c	/^static int vxprintf($/;"	f	file:
walkExprList	expr.c	/^static int walkExprList(ExprList *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
walkExprTree	expr.c	/^static int walkExprTree(Expr *pExpr, int (*xFunc)(void*,Expr*), void *pArg){$/;"	f	file:
walkSelectExpr	expr.c	/^static int walkSelectExpr(Select *p, int (*xFunc)(void *, Expr*), void *pArg){$/;"	f	file:
wants	www/lockingv3.tcl	/^process wants to write a busy database, it can set a PENDING lock which$/;"	p
were	www/fileformat.tcl	/^process were to continue using the old schema, it could potentially$/;"	p
whereTempTriggers	alter.c	/^static char *whereTempTriggers(Parse *pParse, Table *pTab)$/;"	f	file:
worker	test/threadtest2.c	/^void *worker(void *notUsed){$/;"	f
worker_bee	test/threadtest1.c	/^static void *worker_bee(void *pArg){$/;"	f	file:
wrFlag	btree.c	/^  u8 wrFlag;                \/* True if writable *\/$/;"	m	struct:BtCursor	file:
write32bits	pager.c	/^static int write32bits(OsFile *fd, u32 val){$/;"	f	file:
writeCache	os_test.c	/^static int writeCache(OsTestFile *pFile){$/;"	f	file:
writeCache2	os_test.c	/^static int writeCache2(OsTestFile *pFile, int crash){$/;"	f	file:
writeJournalHdr	pager.c	/^static int writeJournalHdr(Pager *pPager){$/;"	f	file:
writeMask	sqliteInt.h	/^  u32 writeMask;       \/* Start a write transaction on these databases *\/$/;"	m	struct:Parse
writeMasterJournal	pager.c	/^static int writeMasterJournal(Pager *pPager, const char *zMaster){$/;"	f	file:
write_history	shell.c	53;"	d	file:
writing	www/c_interface.tcl	/^process writing to the database file or it might happen due to an $/;"	p
x	tool/lemon.c	/^  } x;$/;"	m	struct:action	file:
x1a	tool/lemon.c	/^static struct s_x1 *x1a;$/;"	v	file:
x1node	tool/lemon.c	/^} x1node;$/;"	t	file:
x2a	tool/lemon.c	/^static struct s_x2 *x2a;$/;"	v	file:
x2node	tool/lemon.c	/^} x2node;$/;"	t	file:
x3a	tool/lemon.c	/^static struct s_x3 *x3a;$/;"	v	file:
x3node	tool/lemon.c	/^} x3node;$/;"	t	file:
x4a	tool/lemon.c	/^static struct s_x4 *x4a;$/;"	v	file:
x4node	tool/lemon.c	/^} x4node;$/;"	t	file:
xAuth	sqliteInt.h	/^  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);$/;"	m	struct:sqlite3
xCmp	sqliteInt.h	/^  int (*xCmp)(void*,int, const void*, int, const void*);$/;"	m	struct:CollSeq
xCodec	pager.c	/^  void (*xCodec)(void*,void*,Pgno,int); \/* Routine for en\/decoding data *\/$/;"	m	struct:Pager	file:
xCollNeeded	sqliteInt.h	/^  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);$/;"	m	struct:sqlite3
xCollNeeded16	sqliteInt.h	/^  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);$/;"	m	struct:sqlite3
xCommitCallback	sqliteInt.h	/^  int (*xCommitCallback)(void*);\/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xCompare	btree.c	/^  int (*xCompare)(void*,int,const void*,int,const void*); \/* Key comp func *\/$/;"	m	struct:BtCursor	file:
xDel	vdbeInt.h	/^  void (*xDel)(void *);  \/* If not null, call this function to delete Mem.z *\/$/;"	m	struct:Mem
xDelete	vdbeInt.h	/^    void (*xDelete)(void *);      \/* Destructor for the aux data *\/$/;"	m	struct:VdbeFunc::AuxData
xDestructor	pager.c	/^  void (*xDestructor)(void*,int); \/* Call this routine when freeing pages *\/$/;"	m	struct:Pager	file:
xFinalize	sqliteInt.h	/^  void (*xFinalize)(sqlite3_context*);                \/* Aggregate finializer *\/$/;"	m	struct:FuncDef
xFreeAux	sqliteInt.h	/^	void (*xFreeAux)(void*);  \/* Routine to free pAux *\/$/;"	m	struct:Db
xFunc	sqliteInt.h	/^  int (*xFunc)(void *,int);  \/* The busy callback *\/$/;"	m	struct:BusyHandler
xFunc	sqliteInt.h	/^  void (*xFunc)(sqlite3_context*,int,sqlite3_value**); \/* Regular function *\/$/;"	m	struct:FuncDef
xProgress	sqliteInt.h	/^  int (*xProgress)(void *);     \/* The progress callback *\/$/;"	m	struct:sqlite3
xRealloc	printf.c	/^	void *(*xRealloc)(void*,int);  \/* Function used to realloc memory *\/$/;"	m	struct:sgMprintf	file:
xReiniter	pager.c	/^  void (*xReiniter)(void*,int);   \/* Call this routine when reloading pages *\/$/;"	m	struct:Pager	file:
xStep	sqliteInt.h	/^  void (*xStep)(sqlite3_context*,int,sqlite3_value**); \/* Aggregate step *\/$/;"	m	struct:FuncDef
xTrace	sqliteInt.h	/^  void (*xTrace)(void*,const char*);     \/* Trace function *\/$/;"	m	struct:sqlite3
xtra_utf8_bits	utf.c	/^static const int xtra_utf8_bits[4] =  {$/;"	v	file:
xtra_utf8_bytes	utf.c	/^static const u8 xtra_utf8_bytes[256]  = {$/;"	v	file:
yy0	parse.c	/^  sqlite3ParserTOKENTYPE yy0;$/;"	m	file:
yy132	parse.c	/^  struct AttachKey yy132;$/;"	m	file:
yy2	parse.c	/^  Expr* yy2;$/;"	m	file:
yy210	parse.c	/^  struct TrigEvent yy210;$/;"	m	file:
yy240	parse.c	/^  IdList* yy240;$/;"	m	file:
yy244	parse.c	/^  struct LimitVal yy244;$/;"	m	file:
yy258	parse.c	/^  Token yy258;$/;"	m	file:
yy347	parse.c	/^  TriggerStep* yy347;$/;"	m	file:
yy412	parse.c	/^  int yy412;$/;"	m	file:
yy438	parse.c	/^  struct LikeOp yy438;$/;"	m	file:
yy459	parse.c	/^  Select* yy459;$/;"	m	file:
yy47	parse.c	/^  struct {int value; int mask;} yy47;$/;"	m	file:
yy481	parse.c	/^  int yy481;$/;"	m	file:
yy67	parse.c	/^  SrcList* yy67;$/;"	m	file:
yy82	parse.c	/^  ExprList* yy82;$/;"	m	file:
yyFallback	lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyFallback	parse.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyFallback	tool/lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyParser	lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	lempar.c	/^typedef struct yyParser yyParser;$/;"	t	file:
yyParser	parse.c	/^struct yyParser {$/;"	s	file:
yyParser	parse.c	/^typedef struct yyParser yyParser;$/;"	t	file:
yyParser	tool/lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	tool/lempar.c	/^typedef struct yyParser yyParser;$/;"	t	file:
yyRuleInfo	lempar.c	/^} yyRuleInfo[] = {$/;"	v	file:
yyRuleInfo	parse.c	/^} yyRuleInfo[] = {$/;"	v	file:
yyRuleInfo	tool/lempar.c	/^} yyRuleInfo[] = {$/;"	v	file:
yyRuleName	lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyRuleName	parse.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyRuleName	tool/lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyStackEntry	lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	file:
yyStackEntry	parse.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	parse.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	file:
yyStackEntry	tool/lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	tool/lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	file:
yyTokenName	lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTokenName	parse.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTokenName	tool/lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTraceFILE	lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTraceFILE	parse.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTraceFILE	tool/lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTracePrompt	lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTracePrompt	parse.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTracePrompt	tool/lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yy_accept	lempar.c	/^static void yy_accept($/;"	f	file:
yy_accept	parse.c	/^static void yy_accept($/;"	f	file:
yy_accept	tool/lempar.c	/^static void yy_accept($/;"	f	file:
yy_action	parse.c	/^static const YYACTIONTYPE yy_action[] = {$/;"	v	file:
yy_default	parse.c	/^static const YYACTIONTYPE yy_default[] = {$/;"	v	file:
yy_destructor	lempar.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_destructor	parse.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_destructor	tool/lempar.c	/^static void yy_destructor(YYCODETYPE yymajor, YYMINORTYPE *yypminor){$/;"	f	file:
yy_find_reduce_action	lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_reduce_action	parse.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_reduce_action	tool/lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_shift_action	lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_find_shift_action	parse.c	/^static int yy_find_shift_action($/;"	f	file:
yy_find_shift_action	tool/lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_lookahead	parse.c	/^static const YYCODETYPE yy_lookahead[] = {$/;"	v	file:
yy_parse_failed	lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_parse_failed	parse.c	/^static void yy_parse_failed($/;"	f	file:
yy_parse_failed	tool/lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_pop_parser_stack	lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_pop_parser_stack	parse.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_pop_parser_stack	tool/lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_reduce	lempar.c	/^static void yy_reduce($/;"	f	file:
yy_reduce	parse.c	/^static void yy_reduce($/;"	f	file:
yy_reduce	tool/lempar.c	/^static void yy_reduce($/;"	f	file:
yy_reduce_ofst	parse.c	/^static const short yy_reduce_ofst[] = {$/;"	v	file:
yy_shift	lempar.c	/^static void yy_shift($/;"	f	file:
yy_shift	parse.c	/^static void yy_shift($/;"	f	file:
yy_shift	tool/lempar.c	/^static void yy_shift($/;"	f	file:
yy_shift_ofst	parse.c	/^static const short yy_shift_ofst[] = {$/;"	v	file:
yy_syntax_error	lempar.c	/^static void yy_syntax_error($/;"	f	file:
yy_syntax_error	parse.c	/^static void yy_syntax_error($/;"	f	file:
yy_syntax_error	tool/lempar.c	/^static void yy_syntax_error($/;"	f	file:
yyerrcnt	lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyerrcnt	parse.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyerrcnt	tool/lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyidx	lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidx	parse.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidx	tool/lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yystack	lempar.c	/^  yyStackEntry yystack[YYSTACKDEPTH];  \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystack	parse.c	/^  yyStackEntry yystack[YYSTACKDEPTH];  \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystack	tool/lempar.c	/^  yyStackEntry yystack[YYSTACKDEPTH];  \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
z	func.c	/^  char *z;         \/* The best so far *\/$/;"	m	struct:MinMaxCtx	file:
z	sqliteInt.h	/^  const unsigned char *z; \/* Text of the token.  Not NULL-terminated! *\/$/;"	m	struct:Token
z	vdbeInt.h	/^  char *z;            \/* String or BLOB value *\/$/;"	m	struct:Mem
zAlias	sqliteInt.h	/^    char *zAlias;     \/* The "B" part of a "A AS B" phrase.  zName is the "A" *\/$/;"	m	struct:SrcList::SrcList_item
zAuth	tclsqlite.c	/^  char *zAuth;          \/* The authorization callback routine *\/$/;"	m	struct:SqliteDb	file:
zAuthContext	sqliteInt.h	/^  const char *zAuthContext;   \/* Put saved Parse.zAuthContext here *\/$/;"	m	struct:AuthContext
zAuthContext	sqliteInt.h	/^  const char *zAuthContext; \/* The 6th parameter to db->xAuth callbacks *\/$/;"	m	struct:Parse
zBase	printf.c	/^	char *zBase;     \/* A base allocation *\/$/;"	m	struct:sgMprintf	file:
zBuf	func.c	/^  char zBuf[28];   \/* Space that can be used for storage *\/$/;"	m	struct:MinMaxCtx	file:
zBusy	tclsqlite.c	/^  char *zBusy;          \/* The busy callback routine *\/$/;"	m	struct:SqliteDb	file:
zCol	sqliteInt.h	/^    char *zCol;        \/* Name of column in zTo.  If 0 use PRIMARY KEY *\/$/;"	m	struct:FKey::sColMap
zColAff	sqliteInt.h	/^  char *zColAff;     \/* String defining the affinity of each column *\/$/;"	m	struct:Table
zColAff	sqliteInt.h	/^  char *zColAff;   \/* String defining the affinity of each column *\/$/;"	m	struct:Index
zCommit	tclsqlite.c	/^  char *zCommit;        \/* The commit hook callback routine *\/$/;"	m	struct:SqliteDb	file:
zCrashFile	os_test.c	/^char zCrashFile[256];$/;"	v
zDatabase	sqliteInt.h	/^    char *zDatabase;  \/* Name of database holding this table *\/$/;"	m	struct:SrcList::SrcList_item
zDb	sqliteInt.h	/^  const char *zDb;    \/* Make sure all objects are contained in this database *\/$/;"	m	struct:DbFixer
zDbFilename	shell.c	/^	CONST_STRPTR zDbFilename; \/* name of the database file *\/$/;"	m	struct:callback_data	file:
zDestTable	shell.c	/^	char *zDestTable;	\/* Name of destination table when MODE_Insert *\/$/;"	m	struct:callback_data	file:
zDirectory	pager.c	/^  char *zDirectory;           \/* Directory hold database and journal files *\/$/;"	m	struct:Pager	file:
zErrMsg	btree.c	/^	STRPTR zErrMsg; \/* An error message.  NULL of no errors seen. *\/$/;"	m	struct:IntegrityCk	file:
zErrMsg	sqliteInt.h	/^  char *zErrMsg;                \/* Most recent error message (UTF-8 encoded) *\/$/;"	m	struct:sqlite3
zErrMsg	sqliteInt.h	/^  char *zErrMsg;       \/* An error message *\/$/;"	m	struct:Parse
zErrMsg	table.c	/^  char *zErrMsg;$/;"	m	struct:TabResult	file:
zErrMsg	vdbeInt.h	/^  char *zErrMsg;          \/* Error message written here *\/$/;"	m	struct:Vdbe
zErrMsg16	sqliteInt.h	/^  char *zErrMsg16;              \/* Most recent error message (UTF-16 encoded) *\/$/;"	m	struct:sqlite3
zFile	test/threadtest1.c	/^  const char *zFile;  \/* Filename - used for error reporting *\/$/;"	m	struct:QueryResult	file:
zFilename	pager.c	/^  char *zFilename;            \/* Name of the database file *\/$/;"	m	struct:Pager	file:
zHelp	shell.c	/^static char zHelp[] =$/;"	v	file:
zJournal	pager.c	/^  char *zJournal;             \/* Name of the journal file *\/$/;"	m	struct:Pager	file:
zKey	shell.c	/^	char *zKey;			\/* Encryption key *\/$/;"	m	struct:callback_data	file:
zKey	vdbeInt.h	/^  char *zKey;          \/* The key to this AggElem *\/$/;"	m	struct:AggElem
zKey	vdbeInt.h	/^  char *zKey;         \/* The key by which we will sort *\/$/;"	m	struct:Sorter
zMagicHeader	btree.c	/^static const char zMagicHeader[] = "SQLite format 3";$/;"	v	file:
zMainloop	tclsqlite.c	/^static char zMainloop[] = $/;"	v	file:
zMainloop	tclsqlite.c	/^static char zMainloop[] =$/;"	v	file:
zName	os_test.h	/^  char *zName;      \/* File name *\/$/;"	m	struct:OsTestFile
zName	sqliteInt.h	/^	char *zName;         \/* Name of this database *\/$/;"	m	struct:Db
zName	sqliteInt.h	/^    char *zName;           \/* Token associated with this expression *\/$/;"	m	struct:ExprList::ExprList_item
zName	sqliteInt.h	/^    char *zName;      \/* Name of the identifier *\/$/;"	m	struct:IdList::IdList_item
zName	sqliteInt.h	/^    char *zName;      \/* Name of the table *\/$/;"	m	struct:SrcList::SrcList_item
zName	sqliteInt.h	/^  char *zName;         \/* Name of the collating sequence, UTF-8 encoded *\/$/;"	m	struct:CollSeq
zName	sqliteInt.h	/^  char *zName;         \/* SQL name of the function *\/$/;"	m	struct:FuncDef
zName	sqliteInt.h	/^  char *zName;     \/* Name of the table *\/$/;"	m	struct:Table
zName	sqliteInt.h	/^  char *zName;     \/* Name of this column *\/$/;"	m	struct:Column
zName	sqliteInt.h	/^  char *zName;     \/* Name of this index *\/$/;"	m	struct:Index
zName	tool/mkkeywordhash.c	/^  char *zName;         \/* The keyword name *\/$/;"	m	struct:Keyword	file:
zNull	tclsqlite.c	/^  char *zNull;          \/* Text to substitute for an SQL NULL value *\/$/;"	m	struct:SqliteDb	file:
zOptions	shell.c	/^static const char zOptions[] =$/;"	v	file:
zProgress	tclsqlite.c	/^  char *zProgress;      \/* The progress callback routine *\/$/;"	m	struct:SqliteDb	file:
zScript	tclsqlite.c	/^  char *zScript;        \/* The script to be run *\/$/;"	m	struct:SqlCollate	file:
zScript	tclsqlite.c	/^  char *zScript;        \/* The script to be run *\/$/;"	m	struct:SqlFunc	file:
zShellStatic	shell.c	/^static CONST_STRPTR zShellStatic = NULL;$/;"	v	file:
zShort	vdbeInt.h	/^  char zShort[NBFS];  \/* Space for short strings *\/$/;"	m	struct:Mem
zSql	sqliteInt.h	/^  const char *zSql;    \/* All SQL text *\/$/;"	m	struct:Parse
zSql	tclsqlite.c	/^  char zSql[1];            \/* Text of the SQL statement *\/$/;"	m	struct:SqlPreparedStmt	file:
zTail	sqliteInt.h	/^  const char *zTail;   \/* All SQL text past the last semicolon parsed *\/$/;"	m	struct:Parse
zText	printf.c	/^	char *zText;     \/* The string collected so far *\/$/;"	m	struct:sgMprintf	file:
zTo	sqliteInt.h	/^  char *zTo;        \/* Name of table that the key points to *\/$/;"	m	struct:FKey
zTokenType	tool/mkkeywordhash.c	/^  char *zTokenType;    \/* Token value for this keyword *\/$/;"	m	struct:Keyword	file:
zTrace	tclsqlite.c	/^  char *zTrace;         \/* The trace callback routine *\/$/;"	m	struct:SqliteDb	file:
zType	sqliteInt.h	/^  char *zType;     \/* Data type for this column *\/$/;"	m	struct:Column
zType	sqliteInt.h	/^  const char *zType;  \/* Type of the container - used for error messages *\/$/;"	m	struct:DbFixer
zeroData	btree.c	/^  u8 zeroData;         \/* True if table stores keys only *\/$/;"	m	struct:MemPage	file:
zeroPage	btree.c	/^static void zeroPage(MemPage *pPage, int flags){$/;"	f	file:
zeroed	vdbeInt.h	/^  Bool zeroed;          \/* True if zeroed out and ready for reuse *\/$/;"	m	struct:Cursor
