                       > This is only for MS-DOG users <

This is port of my Unix program xaos for MS_DOG called Chappy. It was done
in DJGPP and is licensed by GPL. Original was done on GNU/Linux.
Please read following article if you don't know, what this mean.


FOR USERS OF BORLAND, MICROSOFT OR WATCOM COMPILERS:

This program was developed under djgpp-gnu c compiler for dos. This is
>FREE< compiler (you may get it from simtel) that is _MUCH_ better that
all commercial compilers I know (bcc,Microsoft,watcom). It is completely 32bit
c compiler with its own dos extender. Also borland like user interface, lots 
of libraries, debugger, profiler, documentation, Pascal compiler and other 
stuff available. Main purpose for porting this program was to show power of 
this compiler. Whole xaos is done in about 15 000 lines in C. 
                            >NO ASSEMBLY< 
It is possible in such speed on other compilers? For example following program


main()
{int i,a=1,b=0;
 for(i=0;i<9999;i++)
	a=a+b,b=2*a;
 printf("%i\n",a);
}

compile into: (Assembly syntax bit differs from "normal" dos syntax but I hope
it is still readable for you)
	.file	"example.c"
gcc2_compiled.:
___gnu_compiled_c:
.text
LC0:
	.ascii "%i\12\0"
	.align 2
.globl _main
_main:
	call ___main		#small and fast inicialization
	movl $1,%eax		#All variables in registers
	xorl %ecx,%ecx
	movl $9998,%edx		#Cycle goes from 9998 to zero instead 0 to 9999
	.align 2,0x90		#body is aligned to fit better in caches...
L11:
	addl %ecx,%eax		#whole body is in just two instructions
	leal (%eax,%eax),%ecx	#do you know this "trick"? I seen it first in gcc output
	decl %edx		#test of cycle is at the end, because compiler
	jns L11			#was sure that it will turn more than once
	pushl %eax		#typical calling of printf..new versions 
	pushl $LC0		#experimentally supports passing in registers..
	call _printf		#no libraries available for now..
	addl $8,%esp		#shorter and faster than pops...
	ret

The following is output generated by borland compiler with optimizations
enabled:
< LONG CUT >
   ;	
   ;	main()
   ;	
	assume	cs:_TEXT
_main	proc	near
	enter	2,0		#not required at all, VERY uneffective at pentium
	push	si		#why this pops? main is first function!
	push	di
   ;	
   ;	{int i,a=1,b=0;
   ;	
	mov	si,1		#just some registers are in memory
	mov	word ptr [bp-2],0
   ;	
   ;	 for(i=0;i<9999;i++)
   ;	
	xor	di,di
	jmp	short @1@98	#unnecesary jump to test...
@1@50:
   ;	
   ;		a=a+b,b=2*a;
   ;	
	mov	ax,si		#5 instructions instead of two.
	add	ax,word ptr [bp-2]#slow memory access required...
	mov	si,ax		
	shl	ax,1
	mov	word ptr [bp-2],ax
	inc	di		#cycle is in normal order...more complicated
@1@98:				#comparing required..(one cmp instruction +)
	cmp	di,9999
	jl	short @1@50
   ;	
   ;	 printf("%i\n",a);
   ;	
	push	si		#calling of printf
	push	offset DGROUP:s@
	call	near ptr _printf
	pop	cx		#another unrequired instruction..
	pop	cx
   ;	
   ;	}
   ;	
	pop	di		#unnecesarry
	pop	si
	leave			#up to now..
	ret	


Here is speed comparsion of internal XaoS loop at various compilers:

  |            |                                       |                     |
  |compiler    |  options                              |  loops per second   |
  |____________|_______________________________________|_________________    |
  |pgcc2.7.2p  | -O6 -ffast-math -mpentium -frisc      |  5 464 480          |
  |            | -fomit-frame-pointer -funroll-loops   |                     |
  |            | -fopt-reg-use -frisc                  |                     |
  |egcs970828  |  -O3 -ffast-math -mpentium            |  5 405 405          |
  |            |  -fomit-frame-pointer -funroll-loops  |                     |
  |egcs970828  |  -O3 -ffast-math -m486                |  4 807 692          |
  |            |  -fomit-frame-pointer -funroll-loops  |                     |
  |gcc2.6.3    |  -O3 -ffast-math -m486                |  4 233 641          |
  |            |  -fomit-frame-pointer -funroll-loops  |                     |
  |gcc2.7.2.1  | -O3 -ffast-math -m486                 |  4 149 377          |
  |            | -fomit-frame-pointer -funroll-loops   |                     |
  |gpc2.0      | -O3 -ffast-math -m486                 |  3 433 962          |
  |            | -fomit-frame-pointer -funroll-loops   |                     |
  |vc5.0       | (optimalizace na max)                 |  3 060 908          |
  |wc10.0      |  -7 -5 -ol -ol+ -om -op -or -ot -fp5  |  2 222 222          |
  |            |  -fpi87                               |                     |
  |wc10.0      |  -5 -7                                |  2 217 249          |
  |delphi      |                                       |  2 012 012          |
  |plan9       | (v IDE-586,speed+size optim.)         |  1 623 376          |
  |vc1.0       | (v IDE-586,speed+size optim.)         |  1 531 393          |
  |bc4.5       | (v IDE-486,fastest executable)        |  1 455 604          |
  |bc3.1       | (v IDE-386,fastest executable)        |  1 433 070          |
  |gcc2.7.2.1  |  (no optimizations)                   |  1 281 348          |
  |gpc2.0      |  (no optimizations)                   |  1 109 756          |
  |bp7.0       |                                       |  901 713            |
  |tc2.0       | -1 -f87 -O -r -Z -G -a -mt            |  846 511            |
  |bc4.0       | (v IDE-486,speed optimizations)       |  755 857            |
  |bc2.0       |                                       |  716 535            |
  |bc2.0       | -G -O -2 -Z -r                        |  716 535            |
  |tc2.0       |                                       |  546 546            |
  |bc4.0       | (v IDE-486,speed+size optim.)         |  -3.6676456...      |

                      Comparsion at Pentium in FP version

  bc is Borland C, bp is Borland Pascal, egcs is development version of GNU C,
  gcc is GNU C, gpc is GNU pascal compiler, pgcc is GNU C with experimental 
  pentium patches, plan9 is C compiler from plan9, vc is Microsoft Visual C
  and wc is Watcom C

  Note that it is just an small benchmark. Sometimes situation should be
  different. But it shows that GCC is very well comparable with best
  commercial compilers and in this thest it is fastest even it is known to
  be weak in floating point optimizations at Intel platforms...

  |            |                                      |                     |
  |compiler    |  options                             |  loops per second   |
  |____________|______________________________________|_________________    |
  |gcc2.7.0    | -O3 -ffast-math -fomit-frame-pointer |  925 925            |
  |            |  -funroll-loops                      |                     |
  |cc          | -O                                   |  840 336            |

                          comparsions at SUN

  |            |                                       |                    |
  |compiler    |  options                              |  loops per second  |
  |____________|_______________________________________|_________________   |
  |gcc2.7.0    | -O3 -ffast-math -fomit-frame-pointer |  2 688 172          |
  |            |  -funroll-loops                      |                     |
  |cc          | -O                                   |  2 096 436          |

                          comparsions at SGI

  |            |                                       |                     |
  |compiler    |  options                              |  loops per second   |
  |____________|_______________________________________|_________________    |
  |pgcc2.7.2p  | -O6 -ffast-math -mpentium -frisc      |  3 464 480          |
  |            | -fomit-frame-pointer -funroll-loops   |                     |
  |            | -fopt-reg-use -frisc                  |                     |
  |egcs970828  |  -O3 -ffast-math -mpentium            |  3 311 258          |
  |            |  -fomit-frame-pointer -funroll-loops  |                     |
  |gcc2.7.2.1  | -O3 -ffast-math -m486                 |  3 250 000          |
  |            | -fomit-frame pointer -funroll-loops   |                     |
  |wc10.0      | -fpi87 -fp5 -5 -7 -ol -ol+ -om -on    |  3 246 753          |
  |            | -or -ot                               |                     |
  |wc10.0      | -5 -7                                 |  3 194 888          |
  |plan9       |                                       |  2 973 176          |
  |gpc2.0      | -O3 -ffast-math -fstrength reduce     |  2 888 888          |
  |            | -fomit-frame pointer -funroll-loops   |                     |
  |gcc2.7.2.1  |  (bez optimalizace)                   |  2 394 736          |
  |gpc2.0      |  (bez optimalizace)                   |  2 219 512          |
  |bc2.0       | -G -O -2 -Z -r                        |  2 166 666          |
  |bp7.0       |                                       |  1 956 947          |
  |tc2.0       | -1 -O -r -G -Z -a -mt                 |  892 156            |
  |tc2.0       |                                       |  846 511            |

                  comparsions at Pentium in integer version

For more informations read http://www.delorie.com!
If you want use this compiler carefully read its license.

GNU LICENSE:

This program and whole djgpp compiler os under GNU public license. If this
is something new for you read copying file. Shortly GNU is organization making
free software as djgpp compiler. Its name is recursive and means GNU not Unix!
Program under this license can be freely distributed and modified but still
under this license. Also source codes MUST be available. There is some ways
how to avoid this so making of commercial software under GNU tools is also
possible. So look at xaos homepage(http://www.paru.cas.cz/~hubicka/XaoS) and
get wole sources archive. (license is included in file COPYING in standard 
distribution)

LINUX:

This program was originally developed under GNU/Linux operating system. It is also
completely free(you may get it from ftp(ftp://sunsite.unc.edu/pub/Linux for 
example) or on some very cheap CD-ROM(distributed by for example Info magic or 
RedHat). Linux is modern 32bit Unix clone originally developed for Intel but 
ports for other architectures(as Atari and Amiga) are also available. It comes 
with complete set of GNU utilities so it is one of best environments for
development. Lots of free applications are available (games for example doom, 
quake, abuse, koules and much more) Trial version called minilinux can be
installed into few(about 7.5) megabytes to your dos drive.

PROBLEMS WITH THIS PROGRAM:

This program is completely 32bit so if you have buggy dpmi(as novell dos or 
qemm 7.5 have) it may cause problems. In qemm case get patches to 7.53 from
its ftp site in novell case get Linux! Also memory requirements are bit 
higher than in normal dos programs. If program is too slow get faster version
from its homepage at http://www.paru.cas.cz/~hubicka/XaoS. And use lover
resolution. 

AUTHOR: (of the DOS port and most of XaoS routines)

I am Jan Hubicka. You may browse my homepage at http://www.paru.cas.cz/~hubicka
for more informations and software. One of main purposes for making this 
program was to get some money to buy new computer(my 486 is too slow for XaoS)
but then I decided to release this program freely. But PLEASE if you want to
help me develop more such software send small amount of money to my address

Jan Hubicka
Dukeslkych bojovniky 1944
Tabor
390 03
Czech Republic

You may also contact me at email hubicka@paru.cas.cz
