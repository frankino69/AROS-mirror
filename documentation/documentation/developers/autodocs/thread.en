======
thread
======

.. This document is automatically generated. Don't edit it!

`Index <index>`_

----------

======================================= ======================================= ======================================= ======================================= 
`BroadcastCondition()`_                 `CreateCondition()`_                    `CreateMutex()`_                        `CreateThread()`_                       
`CurrentThread()`_                      `DestroyCondition()`_                   `DestroyMutex()`_                       `DetachThread()`_                       
`ExitThread()`_                         `LockMutex()`_                          `SignalCondition()`_                    `TryLockMutex()`_                       
`UnlockMutex()`_                        `WaitAllThreads()`_                     `WaitCondition()`_                      `WaitThread()`_                         

======================================= ======================================= ======================================= ======================================= 

-----------

BroadcastCondition()
====================

Synopsis
~~~~~~~~
::

 void BroadcastCondition(
          void * cond );

Function
~~~~~~~~
::

     Signals all threads waiting on a condition variable.


Inputs
~~~~~~
::

     cond - the condition to signal.


Result
~~~~~~
::

     This function always succeeds.


Example
~~~~~~~
::

     LockMutex(mutex);
     BroadcastCondition(cond);
     UnlockMutex(mutex);


Notes
~~~~~
::

     Before calling this function you should lock the mutex that protects
     the condition. WaitCondition() atomically unlocks the mutex and waits
     on the condition, so by locking the mutex first before sending the
     signal, you ensure that the signal cannot be missed. See
     WaitCondition() for more details.

     If no threads are waiting on the condition, nothing happens.



See also
~~~~~~~~

`CreateCondition()`_ `DestroyCondition()`_ `WaitCondition()`_ `SignalCondition()`_ 

----------

CreateCondition()
=================

Synopsis
~~~~~~~~
::

 void * CreateCondition();

Function
~~~~~~~~
::

     Creates a condition variable.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     The newly created condition, or NULL if one couldn't be created.


Notes
~~~~~
::

     Condition cond = CreateCondition();



See also
~~~~~~~~

`DestroyCondition()`_ `WaitCondition()`_ `SignalCondition()`_ `BroadcastCondition()`_ 

----------

CreateMutex()
=============

Synopsis
~~~~~~~~
::

 void * CreateMutex();

Function
~~~~~~~~
::

     Creates a mutual exclusion device (aka lock).


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     The newly created mutex, or NULL if a mutex couldn't be created.


Example
~~~~~~~
::

     Mutex mutex = CreateMutex();



See also
~~~~~~~~

`DestroyMutex()`_ `LockMutex()`_ `TryLockMutex()`_ `UnlockMutex()`_ 

----------

CreateThread()
==============

Synopsis
~~~~~~~~
::

 uint32_t CreateThread(
          ThreadEntryFunction entry,
          void * data );

Function
~~~~~~~~
::

     Creates a new thread.


Inputs
~~~~~~
::

     entry - pointer to a function to run in the new thread
     data  - pointer to pass in the first in the first argument to function
             pointed to by entry


Result
~~~~~~
::

     Numeric thread ID, or 0 if the thread could not be started.


Example
~~~~~~~
::

     uint32_t id = CreateThread(entry, data);
     if (id < 0)
         printf("thread creation failed\n");
     else
         printf("thread %d created\n", id);



See also
~~~~~~~~

`CurrentThread()`_ `DetachThread()`_ `WaitThread()`_ `WaitAllThreads()`_ 

----------

CurrentThread()
===============

Synopsis
~~~~~~~~
::

 uint32_t CurrentThread();

Function
~~~~~~~~
::

     Get the ID of the running thread.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     Numeric thread ID, or 0 if this is not a thread.


Example
~~~~~~~
::

     uint32_t id = CurrentThread();
     printf("this is thread %d\n", id);



See also
~~~~~~~~

`CreateThread()`_ `DetachThread()`_ `WaitThread()`_ `WaitAllThreads()`_ 

----------

DestroyCondition()
==================

Synopsis
~~~~~~~~
::

 BOOL DestroyCondition(
          void * cond );

Function
~~~~~~~~
::

     Destroys a condition variable.


Inputs
~~~~~~
::

     cond - the condition variable to destroy.


Result
~~~~~~
::

     TRUE if the condition was destroyed, otherwise FALSE.


Example
~~~~~~~
::

     DestroyCondition(cond);


Notes
~~~~~
::

     You cannot destroy a condition variable if other threads are waiting on
     it.



See also
~~~~~~~~

`CreateCondition()`_ `WaitCondition()`_ `SignalCondition()`_ `BroadcastCondition()`_ 

----------

DestroyMutex()
==============

Synopsis
~~~~~~~~
::

 BOOL DestroyMutex(
          void * mutex );

Function
~~~~~~~~
::

     Destroys a mutex.


Inputs
~~~~~~
::

     mutex - the mutex to destroy.


Result
~~~~~~
::

     TRUE if the mutex was destroyed, otherwise FALSE.


Example
~~~~~~~
::

     DestroyMutex(mutex)


Notes
~~~~~
::

     You cannot destroy a mutex that is currently locked or has tasks
     waiting to lock it.



See also
~~~~~~~~

`CreateMutex()`_ `LockMutex()`_ `TryLockMutex()`_ `UnlockMutex()`_ 

----------

DetachThread()
==============

Synopsis
~~~~~~~~
::

 BOOL DetachThread(
          uint32_t thread_id );

Function
~~~~~~~~
::

     Detaches a thread from the parent process.


Inputs
~~~~~~
::

     thread_id - ID of thread to detach.


Result
~~~~~~
::

     TRUE if the thread was detached, FALSE if the thread was already
     detached or another error occured.


Example
~~~~~~~
::

     DetachThread(id);


Notes
~~~~~
::

     You cannot detach a thread that is already detached.

     Once detached, the thread is no longer accessible from any other
     thread.


Bugs
~~~~
::

     Currently this doesn't really do anything other than make it so you
     can't call WaitThread() on the thread. Threads can't truly be detached
     from the parent process since they run in the same address space, and
     so when the process exits the program code and all its other resources
     a freed.
     
     thread.library protects against this by waiting for all threads to
     complete (detached or not) before allowing the main process to exit.
     
     Detached threads can't be truly implemented until a thread task and its
     allocated resources can exist independently of the process that created
     it.



See also
~~~~~~~~

`CreateThread()`_ `CurrentThread()`_ `WaitThread()`_ `WaitAllThreads()`_ 

----------

ExitThread()
============

Synopsis
~~~~~~~~
::

 void ExitThread(
          void * result );

Function
~~~~~~~~
::

     Exits the calling thread.


Inputs
~~~~~~
::

     result    - pointer to storage for the thread's return value. You can
                 pass NULL here if you don't care about the return value.


Result
~~~~~~
::

     None, this function never returns.


Example
~~~~~~~
::

     ExitThread(5);


Notes
~~~~~
::

     This function is similar to the exit() function of arosc library.



See also
~~~~~~~~

`WaitThread()`_ `WaitAllThreads()`_ `clib.library/exit() <./clib#exit>`_ 

----------

LockMutex()
===========

Synopsis
~~~~~~~~
::

 void LockMutex(
          void * mutex );

Function
~~~~~~~~
::

     Locks a mutex. If the lock is already held, this function blocks.


Inputs
~~~~~~
::

     mutex - mutex to lock.


Result
~~~~~~
::

     This function always succeeds.


Example
~~~~~~~
::

     LockMutex(mutex);



See also
~~~~~~~~

`CreateMutex()`_ `DestroyMutex()`_ `TryLockMutex()`_ `UnlockMutex()`_ 

----------

SignalCondition()
=================

Synopsis
~~~~~~~~
::

 void SignalCondition(
          void * cond );

Function
~~~~~~~~
::

     Signals a thread waiting on condition variable.


Inputs
~~~~~~
::

     cond - the condition to signal.


Result
~~~~~~
::

     This function always succeeds.


Example
~~~~~~~
::

     LockMutex(mutex);
     SignalCondition(cond);
     UnlockMutex(mutex);


Notes
~~~~~
::

     Before calling this function you should lock the mutex that protects
     the condition. WaitCondition() atomically unlocks the mutex and waits
     on the condition, so by locking the mutex first before sending the
     signal, you ensure that the signal cannot be missed. See
     WaitCondition() for more details.

     If no threads are waiting on the condition, nothing happens. If more
     than one thread is waiting, only one will be signalled. Which one is
     undefined.



See also
~~~~~~~~

`CreateCondition()`_ `DestroyCondition()`_ `WaitCondition()`_ `BroadcastCondition()`_ 

----------

TryLockMutex()
==============

Synopsis
~~~~~~~~
::

 BOOL TryLockMutex(
          void * mutex );

Function
~~~~~~~~
::

     Tries to lock a mutex. If the lock is already held, this function
     fails.


Inputs
~~~~~~
::

     mutex - mutex to lock.


Result
~~~~~~
::

     TRUE if the lock was acquired, FALSE if the lock is already held.


Example
~~~~~~~
::

     TryLockMutex(mutex);



See also
~~~~~~~~

`CreateMutex()`_ `DestroyMutex()`_ `LockMutex()`_ `UnlockMutex()`_ 

----------

UnlockMutex()
=============

Synopsis
~~~~~~~~
::

 void UnlockMutex(
          void * mutex );

Function
~~~~~~~~
::

     Unlocks a locked mutex.


Inputs
~~~~~~
::

     mutex - mutex to unlock.


Result
~~~~~~
::

     This function always succeeds.


Example
~~~~~~~
::

     UnlockMutex(mutex);



See also
~~~~~~~~

`CreateMutex()`_ `DestroyMutex()`_ `LockMutex()`_ `TryLockMutex()`_ 

----------

WaitAllThreads()
================

Synopsis
~~~~~~~~
::

 void WaitAllThreads();

Function
~~~~~~~~
::

     Blocks the current task until all threads exit.


Inputs
~~~~~~
::

     None.


Result
~~~~~~
::

     This function always succeeds.


Example
~~~~~~~
::

     WaitAllThreads();


Notes
~~~~~
::

     This function will ignore detached threads.



See also
~~~~~~~~

`CreateThread()`_ `CurrentThread()`_ `DetachThread()`_ `WaitThread()`_ 

----------

WaitCondition()
===============

Synopsis
~~~~~~~~
::

 BOOL WaitCondition(
          void * cond,
          void * mutex );

Function
~~~~~~~~
::

     Blocks until a condition is signaled.


Inputs
~~~~~~
::

     cond - the condition variable to wait on.
     mutex - a mutex that protects the condition


Result
~~~~~~
::

     TRUE if the condition was signaled, FALSE if an error occured.


Example
~~~~~~~
::

     LockMutex(mutex);
     WaitCondition(cond, mutex);
     UnlockMutex(mutex);


Notes
~~~~~
::

     This function will atomically unlock the mutex and wait on the
     condition. The thread is suspended until the condition is signalled.
     After the condition is signalled, the mutex is relocked before
     returning to the caller.

     The use of a mutex in conjunction with waiting on and signalling the
     condition ensures that no signals are missed. See SignalCondition() for
     more details.



See also
~~~~~~~~

`CreateCondition()`_ `DestroyCondition()`_ `SignalCondition()`_ `BroadcastCondition()`_ 

----------

WaitThread()
============

Synopsis
~~~~~~~~
::

 BOOL WaitThread(
          uint32_t thread_id,
          void ** result );

Function
~~~~~~~~
::

     Blocks the current task until the requested thread exits.


Inputs
~~~~~~
::

     thread_id - ID of thread to detach.
     result    - pointer to storage for the thread's return value. You can
                 pass NULL here if you don't care about the return value.


Result
~~~~~~
::

     TRUE when the thread completed successfully. FALSE if thread could not
     be waited on.


Example
~~~~~~~
::

     void *ret;
     WaitThread(id, &ret);


Notes
~~~~~
::

     A thread cannot wait on itself. A thread cannot be waited on if it is
     detached.

     If the thread has already completed, this call returns immediately with
     the thread result. Further calls to this function for that thread will
     fail.

     Multiple threads can wait for a thread to complete. They will all
     be notified when the thread completes, and will all receive the result.



See also
~~~~~~~~

`CreateThread()`_ `CurrentThread()`_ `DetachThread()`_ 

